
<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<link href="data:," rel="icon"/>
<!-- (optional weitere <meta>/<link>/<style>/<script>) -->

<script id="ppk-textsafe-polyfill-early">
(function(){
  try{
    if (window.__ppkSetTextSafe) return;
    window.__ppkSetTextSafe = function(el, txt){
      if (!el) return;
      var s = (txt === undefined || txt === null) ? "" : String(txt);
      el.textContent = s;
    };
  }catch(e){}
})();
</script>




<style id="feld7-icons-cursor">
#feld7-menu .feld7-item span{ display:none !important; }
#feld7-menu .feld7-item img{ width:28px; height:28px; cursor: grab !important; }
#feld7-menu .feld7-item{ cursor: grab !important; }
</style>
<style id="feld7-cursor-fix">
#feld7{ cursor: grab !important; }
#feld7-menu .feld7-item{ cursor: grab !important; }
#feld7-menu .feld7-item img{ cursor: grab !important; }
</style>
<style id="feld7-pe-fix">
#feld7-dd, #feld7-menu, #feld7-menu *{ pointer-events:auto !important; user-select:auto !important; }
</style>
<style>
  .spruchregal{margin-top:8px; background:#fff; border:1px solid #ccc; border-radius:10px; padding:8px; max-width:520px;}
  .spruchregal-head{font-weight:600; margin-bottom:6px; display:flex; align-items:center; justify-content:space-between; gap:6px;}
  .spruchchips{display:flex; flex-wrap:wrap; gap:6px; max-height:140px; overflow:auto; padding:4px 0;}
  .chip{border:1px solid #ddd; border-radius:999px; padding:6px 10px; font-size:14px; cursor:grab; user-select:none; background:#f9f9f9; white-space:nowrap;}
  .chip:active{cursor:grabbing;}
  .chip.free{background:#fffef5; border-color:#e6d88a;}
  .chip::-webkit-scrollbar{height:6px;}

  /* Spruch-Regal: Close-Button oben rechts */
  .spruchregal{
    position: relative;
  }
  .spruchregal-head{
    position: relative;
    padding-right: 32px; /* Platz für X-Button */
  }
  .spruchregal-clear{
    position: absolute;
    top: 6px;
    right: 6px;
  }
</style><style id="spruchchips-radius-8">
/* Spruchregal-Chips mit 8px Eckenradius */
.spruchchips .chip{
  border-radius: 8px !important;
}
</style>
<style>
  /* Feld 6 (Spruch) – altes Gelb dauerhaft ausblenden */
  #spruchSelect,
  #spruchDragCard,
  label[for="spruchSelect"] {
    display: none !important;
    visibility: hidden !important;
  }

</style>
<style>
  /* Spruch-Accordion + Regal unter der Karte:
     - Buttons horizontal bündig mit Smiley
     - Regal klappt absolut nach unten auf und verschiebt keine anderen Elemente */
  .spruch-acc {
    margin: 0 0 10px 0;
    position: relative;
  }
  .spruch-acc[open] > .spruch-acc-summary {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }
  .spruch-acc-summary {
    list-style: none;
    display: inline-flex;
    align-items: flex-start;
    gap: 8px;
    background: #ffd86b;
    border: 1px solid #e0c25a;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
    user-select: none;
  }
  .spruch-acc-summary::-webkit-details-marker { display:none; }

  /* Weißes Regal: als Overlay direkt unter dem Spruch-Button,
     damit es den Smiley-Bereich nicht mehr verschiebt. */
  .spruchregal{
    position: absolute;
    left: 0;
    top: calc(100% + 8px);
    background:#fff;
    border:1px solid #ccc;
    border-radius:10px;
    padding:8px;
    max-width:520px;
    box-sizing: border-box;
    z-index: 20;
  }
  .spruchchips{
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    max-height:180px;
    overflow-y:auto;
    margin-bottom:8px;
  }
.chip{border:1px solid #ddd; border-radius:999px; padding:6px 10px; font-size:14px; cursor:grab; user-select:none; background:#f9f9f9; white-space:nowrap;}
  .chip:active{cursor:grabbing;}
  .chip.free{background:#fffef5; border-color:#e6d88a;}
  /* Freitext area inside the panel */
  #spruchFreeArea{ width:100%; box-sizing:border-box; border:2px solid #e6d88a; border-radius:10px; padding:8px 10px; resize:none; line-height:20px; }
  #spruchFreeCounters{ font-size:12px; margin-top:2px; opacity:.9;}
  .drag-handle{ display:inline-block; margin-top:6px; border:1px solid #ddd; border-radius:999px; padding:6px 10px; user-select:none; cursor:grab; background:#f9f9f9; }
</style>
<style>
  /* Ensure Feld 6 overlay accepts drag events */
  #feld6_slot { pointer-events: auto !important; }
  #spruchAnzeige { pointer-events: auto !important; }
</style>
<style>
  /* Ensure Feld 7 drop area is interactive */
  #symbolAnzeige { pointer-events: auto !important; }
</style>
<style>
  /* Container unter der Kartenvorderseite für Feld 6 & 7 */
  #underCardSelectors {
    display: grid;
    grid-template-columns: auto auto auto;
    gap: 12px;
    align-items: center;
    margin-top: 10px;
  }

  /* bei 150% alles unter der Karte leicht nach links schieben,
     damit alle drei Buttons genug Platz haben */
  body.zoom-150 #underCardSelectors{
    margin-left:-15mm;
  }

  @media (max-width: 900px){
    #underCardSelectors { grid-template-columns: 1fr; }
  }
  .uc-panel {
    display:flex;
    justify-content:center;
    align-items:center;
    background:transparent;
    border:none;
    padding:0;
  }
  .uc-panel h3 { display:none !important; }
</style>
<style id="uc-panel-hide-visual">
  /* uc-panel-Container nur als logische Halter verwenden, aber optisch ausblenden */
  #underCardSelectors .uc-panel{
    background: transparent !important;
    border: none !important;
    padding: 0 !important;
    box-shadow: none !important;
  }
</style>
<style>
  /* Feld 7 fallback select styling */
  .uc-panel select#smileySelect {
    display: block !important;
    visibility: visible !important;
    min-width: 240px;
    height: 40px;
    padding: 6px 10px;
    border: 1px solid #c9c9c9;
    border-radius: 10px;
    background: #fff7cc;
  }
  .uc-panel .picker-row{ display:flex; align-items:center; gap:8px; }
  .uc-panel .picker-row label{ font-size:13px; opacity:.8; }
</style>
<style>
  /* Tighter spacing to the card */
  #underCardSelectors {
    margin-top: 6px !important;
    gap: 10px !important;
  }
  .uc-panel { position: relative; padding-top: 16px; }
  .uc-panel:empty { display:none !important; }

  /* Upward arrows that can point to slots */
  
  /* small ring to emphasise relationship */
  
  #underCardSelectors 
</style>
<script id="rb-kose-kachel-js">
document.addEventListener('DOMContentLoaded', function(){
  try{
    if (document.getElementById('rb-kose-kachel')) return;

    var btnTop    = document.getElementById('btn-kosename');              // oberer Kosename-Button
    var btnBottom = document.getElementById('btn-uebernehmen-kosename');  // "Kosename übernehmen"
    var anchor    = document.getElementById('rb-kose-hint-anchor');
    if (!btnTop || !anchor) return;

    var parent = btnTop.parentNode;
    if (!parent) return;

    var wrap = document.createElement('div');
    wrap.id = 'rb-kose-kachel';

    // Neue Kachel an Stelle des oberen Buttons einfügen
    parent.insertBefore(wrap, btnTop);

    // Reihenfolge in der Kachel: oberer Button -> Hinweis-Anker -> (optional) unterer Button
    wrap.appendChild(btnTop);

    if (anchor.parentNode !== wrap){
      try{ anchor.parentNode && anchor.parentNode.removeChild(anchor); }catch(e){}
      wrap.appendChild(anchor);
    }

    if (btnBottom && btnBottom.parentNode === parent){
      wrap.appendChild(btnBottom);
    }
  }catch(e){
    if (window.console && console.warn){
      console.warn('rb-kose-kachel-fix failed', e);
    }
  }
});
</script>
<style id="hide-old-spruch-block">
  /* Alte gelbe Spruch-Auswahl (Accordion) komplett ausblenden,
     ohne Logik für Feld 6/7 anzutasten. */
  #front-controls .spruch-acc {
    display: none !important;
    visibility: hidden !important;
  }
</style>
<style id="spruchDragHandle-tuning">
/* Feintuning: Freitext-Griff wie Hinweis-Button */
#spruchDragHandle,
.drag-handle#spruchDragHandle{
  font-size: 13px;
  padding: 4px 10px;
  border-radius: 8px;
  line-height: 1.2;
  border: 2px solid #e6d88a;
  background:#fffef5;
}
</style>
<style id="underCardSelectors-arrow-and-positions">
  /* Weiße Hilfspfeile im unterCardSelectors-Bereich ausblenden */
  #underCardSelectors 

  /* Zoom-abhängige Positionskorrektur für Spruch/Smiley unter der Karte */
  /* 100 %: Spruch 1 cm nach links, Smiley zusätzlich 7 mm */
  body.zoom-100 #underCardSelectors{
    margin-left:-10mm;
  }
  body.zoom-100 #feld7-trigger{
    margin-left:5mm;
  }

  /* 150 %: gleiche Position wie bei 100 % – Buttons bleiben komplett sichtbar */
  body.zoom-150 #underCardSelectors{
    margin-left:-10mm !important;
  }
</style>

<style id="help-button-style">
/* Hilfe-Button "Anleitung / Hinweise" im linken Pflegehinweis-Panel */
#spalte-links .help-button-row{
  margin:8px 0 12px;
  display:flex;
  justify-content:flex-end; /* weiter rechts, nahe Trenner */
  position:sticky;
  top:4px;
  z-index:5;
}
#spalte-links .help-link{
  text-decoration:none;
}
#spalte-links .help-pill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  background:#ffffff;
  border-radius:8px;
  padding:4px 10px;
  box-shadow:0 2px 4px rgba(0,0,0,0.25);
}
#spalte-links .help-icon{
  width:32px;
  height:32px;
  border-radius:50%;
  background:#0057d8;
  color:#ffffff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-family:"Adobe Caslon Pro","Times New Roman",serif;
  font-weight:700;
  font-size:24px;
  line-height:1;
}
#spalte-links .help-text{
  font-weight:700;
  line-height:1.1;
  color:#000000;
  font-size:13px;
}
#spalte-links .help-text span{
  display:block;
}
</style>


<style id="pointer-events-switch">
  /* Karte vorn/hinten: nur die aktive Seite darf Eingaben erhalten.
     Zusätzlich: Feld 6 (Spruch) ist bei aktiver Rückseite komplett „stumm“,
     damit keine Sticker-Drops mehr dort landen können. */

  /* Grundlogik: nur die jeweils aktive Kartenseite ist interaktiv */
  #kartenbereich.back-top #karte-vorderseite {
    pointer-events: none !important;
  }
  #kartenbereich.front-top #karte-rueckseite {
    pointer-events: none !important;
  }

  /* Speziell für Feld 6:
     Wenn die Rückseite aktiv ist, darf der Slot für Feld 6
     (sowohl die Anzeige als auch das Drop-Div) keine Events mehr annehmen.
     Damit fällt der Drop automatisch auf die Rückseite durch. */
  #kartenbereich.back-top #feld6_slot,
  #kartenbereich.back-top #spruchAnzeige {
    pointer-events: none !important;
  }
</style>

</head>
<body>
<!-- dein restlicher Inhalt -->
<script id="kill-native-dialogs-early">
// runs before other scripts
(function(){
  try { window.alert  = function(){ /* no-op */ }; } catch(e){}
  try { window.confirm= function(){ return false; /* behave like Cancel */ }; } catch(e){}
  try { window.prompt = function(){ return ""; }; } catch(e){}
  try {
    if (window.HTMLDialogElement){
      var p = window.HTMLDialogElement.prototype;
      if (p.showModal) p.showModal = function(){};
      if (p.show)      p.show      = function(){};
    }
  } catch(e){}
})();
</script>
<script>
  // Zähler-Schutz gegen Zurücksetzen bei vollem Warenkorb
  function safeSetCount(selector, val) {
    if (val === '–' && window.cart && Object.keys(window.cart).length > 0) {
      window.__DEBUG__ && console.warn('Zähler-Schutz: Warenkorb ist nicht leer, Zähler bleibt erhalten');
      return;
    }
    const el = document.querySelector(selector);
    if (el) el.textContent = val;
  }

  // Ersetze die bisherigen Zähler-Setzfunktionen (sofern vorhanden)
  window.safeSetOkCount = (val) => safeSetCount('#okCount', val);
  window.safeSetAvailableCount = (val) => safeSetCount('#availableCount', val);

  document.addEventListener('DOMContentLoaded', () => {
    if (!window.cart) window.cart = {};
  });
</script>
<!-- Block mit #ppk-availability-slot für Wix entfernt -->
<script id="rb-datacat-guard">
(function(){
  try{
    const _set = Element.prototype.setAttribute;
    Element.prototype.setAttribute = function(name, value){
      try {
        if (name === 'data-cat'){
          const cur = this.getAttribute('data-cat');
          const v = (value==null ? '' : String(value));
          if (cur === v) return; // keine redundante Mutation
        }
      } catch(_) {}
      return _set.call(this, name, value);
    };
  }catch(_){}
})();
</script>
<!-- Projekt: Pflanzenpflegekarten – Vorschauseite (Dokublatt) Status: konsolidiert (Rahmen-Konstanten, Dropdown-Tints/-Styles, JS-Patches) Kern-IDs/Knoten #kartenbereich → steuert Klassen 'front-top' / 'back-top' #karte-vorderseite / #karte-rueckseite .aktiv → zeigt grünen Rahmen (.rahmen-overlay) #rb-boxes → Container der roten Boxen (.rb-row, .rb-box, .rb-box-titel) #rb-dropdown → Dropdown-Overlay (.rb-dd-item, #rb-dd-free) Slots → Sticker: feld2–5, feld8–16 | Text: feld17–25 Nicht ändern (ohne explizite Freigabe) SVGs, Koordinaten, Größen, Mapping Box↔Felder, Zoom-Logik, Umschalter, Lineal Zähler-Logik (kurz) Gemeinsamer Zähler window.__rbUsage → färbt .rb-box via .rb-used (count>0)
 Sticker: Ursprung aus .rb-icon-Drag; Slot.dataset.rbOriginSticker; Mülleimer dekrementiert
 Texte: Ursprung aus Dropdown-Drag; Slot.dataset.rbOrigin; Mülleimer dekrementiert

Aktiver Rahmen
 Variablen: --active-frame-color #1B5E20, --active-frame-width 4px
 Sync via MutationObserver auf #kartenbereich (front-top/back-top) → setzt .aktiv

Wartung/Struktur
 CSS: #active-frame-style (Rahmen), #rb-dd-tint (Tints), #rb-dd-style-consolidated (Dropdown-Styles)
 JS: #rb-patches-consolidated (alle Patch-Skripte, Reihenfolge erhalten)
-->
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Konfigurator</title>
<style data-group="base" id="base-css-001">
    :root{
      /* fester Einbettungsrahmen für Wix */
      --frame-width: 980px;
      --gutter-right: 5mm;           /* Platz für künftigen Aktiv-Rahmen / Scrollbar */
      --zoom: 1;                     /* 1 = 100 %, 1.5 = 150 % */
      --card_w_mm: 54mm;
      --card_h_mm: 85mm;
      --gap: 12px;
      --radius: 6px;
    }
    *{ box-sizing: border-box; }
    body{ margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#111; background:#fff; }
    .frame{ width: var(--frame-width); margin: 0 auto; border:2px solid #333; background:#fff; }

    /* Kopfbereich */
    .toolbar{ display:grid; grid-template-columns: 1.2fr 1fr 1fr; gap:16px; padding:12px; border-bottom:2px solid #333; background:#f3f5f4; align-items:center; }
    .toolbar .block{ display:flex; gap:8px; align-items:center; }
    .toolbar input[type="text"]{ padding:8px 10px; border:1px solid #bbb; border-radius:6px; min-width:240px; }
    .toolbar button{ padding:8px 12px; border:1px solid #888; background:#fff; border-radius:6px; cursor:pointer; }
    .toolbar button:hover{ background:#f7f7f7; }

    /* Zwei Spalten */
    .content{ padding:12px 12px 72px; }
    .columns{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start; }
    .panel{ border:2px solid #333; border-radius:var(--radius); padding:12px; background:#fff; }
/* Paper block behind "Ausführung (pro Karte)" */
.abschluss-paper{
  background:#fff;                      /* same as panels (Spalte 1 & 2) */
  border:2px solid #333;
  border-radius:var(--radius);
  padding:12px 14px;
  display:block;
  width:fit-content;
  max-width:100%;
  box-shadow:0 2px 0 rgba(0,0,0,.15);
  margin:8px 0 14px 0;                  /* a bit of breathing space */
}

    .panel h2{ margin:0 0 8px 0; font-size:16px; font-weight:700; }

    /* Werkzeuge der rechten Spalte */
    .panel-tools{ display:flex; gap:8px; align-items:center; margin-bottom:10px; flex-wrap:nowrap; }
    .panel-tools .icon{ display:inline-flex; width:32px; height:32px; border:1px solid #888; border-radius:6px; align-items:center; justify-content:center; background:#fff; user-select:none; }
    .panel-tools button{ padding:6px 10px; border:1px solid #888; background:#fff; border-radius:6px; cursor:pointer; white-space:nowrap; }
    .panel-tools button:hover, .panel-tools .icon:hover{ background:#f7f7f7; }

    /* Kartenbereich */
    #spalte-rechts{ overflow-y:auto; overflow-x:hidden; padding-right: calc(16px + var(--gutter-right)); }

    /* Bei 150% mehr Luft nach unten, damit das Spruch-Regal nicht abgeschnitten wird */
    body.zoom-150 #spalte-rechts{ padding-bottom:160px; height:auto !important; }  /* ca. 2 cm extra Platz + Editor kann höher werden */
    .kartenbereich{ display:flex; gap:var(--gap); align-items:flex-start; flex-wrap:nowrap; }
    figure{ margin:0; display:inline-block; position:relative; }
    /* Karten exakt 54x85 mm bei 100 %, skaliert mit --zoom */
    .karte{
      height: calc(var(--card_h_mm) * var(--zoom));
      width:  calc(var(--card_w_mm) * var(--zoom));
      background:#fff;
      overflow:hidden;
      display:block;
    }
    .karte img{ width:100%; height:100%; display:block; object-fit:cover; }

    /* Dropdowns “anklammern”: am unteren Rand der VORDERSEITE */
    .front-wrapper{ position:relative; }
    .front-controls{
      position:absolute;
      top: calc(100% + 2mm);       /* direkt unter der Karte, unabhängig vom Zoom */
      left: 0;
      width: 100%;
      display:flex;
      gap:4px;
      align-items:center;
    }
    .front-controls select{
      height:28px;
      border:1px solid #888;
      border-radius:6px;
      background:#fff;
    }
    /* Lineal – skaliert wie Karten; bei 150% ausblenden */
    .lineal img{ height: calc(87mm * var(--zoom)); width:auto; display:block; }
    body.zoom-150 .lineal{ display:none; }

    /* Überlapp-Logik: wir verschieben die RÜCKSEITE nach links, wenn der Platz knapp wird */
    .tight #karte-rueckseite{ position:relative; z-index:1; }
    .tight #karte-vorderseite{ position:relative; z-index:2; } /* liegt oben, Umschaltbutton kann es ändern */

    /* Umschalt-Status (welche Karte vorne liegt) */
    .front-top #karte-vorderseite{ z-index:3; }
    .front-top #karte-rueckseite{ z-index:1; }
    .back-top  #karte-vorderseite{ z-index:1; }
    .back-top  #karte-rueckseite{ z-index:3; }

    /* kleine Hilfen für Fokus */
    .is-active{ outline:2px solid #2a7; outline-offset:2px; }
  

/* Steuerleiste – wie in Referenz */
.steuerleiste{
  display:flex;
  align-items:center;
  gap:16px;
  padding:12px;
  border-bottom:2px solid #333;
  background:#f3f5f4;
}
.steuerleiste .block{
  display:flex;
  align-items:center;
  gap:8px;
  flex-wrap:wrap;
}
.steuerleiste .block.column{ flex-direction:column; align-items:stretch; }
.steuerleiste .block.column button{ width:100%; }
.steuerleiste input[type="text"]{
  padding:8px 10px;
  border:1px solid #bbb;
  border-radius:6px;
  min-width:240px;
}
.steuerleiste button{
  padding:8px 12px;
  border:1px solid #888;
  background:#fff;
  border-radius:6px;
  cursor:pointer;
  white-space:nowrap;
}
.steuerleiste button:hover{ background:#f7f7f7; }

/* Autocomplete under-field: wrapper positions both list and 'no match' toast */
.ac-wrap{ position:relative; display:inline-block; }
.ac-wrap > input{ vertical-align:top; }
.ac-anchor{
  position:absolute;
  left:0;
  top:100%;
  margin-top:4px;
  width:100%;
  transform: translateY(-21px); /* gleicht Row-Offset aus, Liste direkt unter dem Feld */
  z-index: 1200; /* über dem Editor-Bereich anzeigen */
  will-change: transform;
}
.ac-list{
  position:relative;
  background:#fff;
  border:1px solid #bbb;
  border-radius:6px;
  box-shadow:0 4px 16px rgba(0,0,0,.08);
  max-height:240px;
  overflow-y:auto;
  width:100%;
  z-index:2000;
}
.ac-item{ padding:8px 10px; cursor:pointer; }
.ac-item:hover, .ac-item.active{ background:#f2f4f6; }
.ac-empty{ padding:8px 10px; color:#777; }
.nohit-toast{
  position:absolute; left:0; top:100%; margin-top:6px; width:max(320px, 100%);
  background: transparent !important; /* neutralized */ /* border neutralized */ color: inherit !important; /* neutralized */
  border-radius:6px; padding:10px 12px; line-height:1.2;
  box-shadow:0 6px 20px rgba(0,0,0,.08); z-index:1999;
}

/* === RB MODULE (scoped) =============================================== */
.rb-scope{ margin-top:8px; }
.rb-status{ font-size:12px; color:#333; margin:8px 0 10px 0; }
.rb-status .rb-link{ text-decoration: underline; cursor: pointer; }
.rb-boxes{ display:flex; flex-direction:column; gap:12px; }

.rb-box{
  width: 200px;
  background-color: #f44336;
  border: 1.417px solid #000;
  border-radius: 6px;
  padding: 0;
  display: flex;
  flex-direction: row;
  margin-bottom: 0;
  position: relative;
}
.rb-icon{
  width: 36px; height: 36px;
  background: #ffffff;
  border: 1.42px solid #000000;
  border-radius: 6px;
  padding: 2px;
  box-sizing: content-box;
  object-fit: contain;
  margin: 10px;
  flex: 0 0 auto;
}
.rb-box-inhalt{ margin: 12px 0 0 6px; flex-grow: 1; }
.rb-box-titel, .rb-box-rect{
  width: 120px;
  min-height: 30px;
  background: #ffffff;
  border: 1.42px solid #000;
  border-radius: 5px;
  display: flex; align-items: center; justify-content: center;
  margin-bottom: 6px;
  box-sizing: border-box;
  font-weight: 700; font-size: 12.5px; line-height: 14px; text-align: center; padding: 0 6px;
}
.rb-box-titel{ white-space: normal; overflow-wrap: normal; word-break: normal; hyphens: manual; }
.rb-box-rect.selectable{ cursor: pointer; user-select: none; }
.rb-box-rect.droptarget--over{ outline: 2px dashed #000; outline-offset: -3px; }

/* Dropdown (fixed, anchored to selection rect) */
.rb-dd{
  position: fixed;
  z-index: 1000;
  width: 260px;
  max-height: 360px;
  background: #fff;
  border: 1px solid #000;
  border-radius: 6px;
  box-shadow: 0 8px 24px rgba(0,0,0,.15);
  display: none;
  overflow: hidden;
}
.rb-dd.open{ display:block; }
.rb-dd-body{ max-height: 260px; overflow:auto; }
.rb-dd-item{ padding:8px 10px; border-bottom:1px solid #eee; cursor:grab; }
.rb-dd-item:active{ cursor:grabbing; }
.rb-dd-item:hover{ background:#f2f2f2; }
.rb-dd-foot{ padding:8px; border-top:1px solid #000; display:none; }
.rb-dd-free{ display:block; width:100%; min-height:30px; border:1px solid #bbb; border-radius:4px; padding:6px 8px; font-size:12px; line-height:16px; background:#fff; }
.rb-dd-free[contenteditable="true"]{ outline:none; }
.rb-muted{ color:#666; font-size:12px; padding:6px 0 0 0; }

/* === Fix A: RB rechts in Spalte 1 andocken (ohne Logikänderung) === */
#spalte-links #rb-scope{ float:right; }
#spalte-links::after{ content:""; display:block; clear:both; }

/* === Fix B2: Panel-Rahmen nach unten verlängern, ohne Controls zu verschieben === */
#spalte-rechts::after{ content:""; display:block; height:72px; }

/* === RB: Hinweisbox links neben jeder roten Box === */
.rb-row{ display:flex; align-items:flex-start; gap:8px; }
.rb-hint{
  width: 220px;
  min-height: 30px;
  background:#fffbe6; /* sehr leichtes Gelb */
  border: 1px solid #000;
  border-radius: 6px;
  padding: 8px;
  font-size: 12px;
  line-height: 1.3;
  box-sizing: border-box;
  white-space: pre-wrap;
  word-break: break-word;
}
.rb-row.hidden{ display:none; }

#spalte-links h2, #spalte-links > p{
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

#spalte-links{
  overflow-y: auto;
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
}

/* === RB: Sticker-Icon in den roten Boxen === */
.rb-box{ display:flex; align-items:center; gap:8px; }
.rb-icon{ width:28px; height:28px; flex:0 0 auto; display:flex; align-items:center; justify-content:center; }
.rb-icon img{ width:24px; height:24px; display:block; }

/* === RB: Iconfeld auf ~15 mm (≈56.7px) & Symbol größer darstellen === */
.rb-box-rect{ width:56.7px !important; height:56.7px !important; }
.rb-icon{ width:56.7px !important; height:56.7px !important; display:flex; align-items:center; justify-content:center; }
.rb-icon img{ width:85% !important; height:85% !important; display:block; object-fit:contain; }

/* === Fix: Auswahl-Feld unverändert lassen; nur Iconfeld 15mm, Symbol größer === */
.rb-row .rb-box-rect{ width:120px !important; height:auto !important; min-height:30px !important; } /* zurück auf Standard */
.rb-row .rb-icon{ width:56.7px !important; height:56.7px !important; }
.rb-row .rb-icon img{ width:94% !important; height:94% !important; }

/* === RB: engerer Abstand zwischen Sticker und Text/Buttons === */
.rb-row .rb-icon{
  margin: 6px 6px 6px 10px !important; /* top right bottom left */
}
.rb-row .rb-box-inhalt{
  margin: 6px 0 0 2px !important; /* weniger Abstand links & oben */
}

/* === RB: harmonische Innenabstände in der roten Box === */
.rb-row .rb-box{ 
  padding: 10px 12px !important;           /* Innenabstand: oben/unten + rechts/links */
  box-sizing: border-box;
}
.rb-row .rb-box-right{
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  gap: 8px;                                 /* definierter Abstand zwischen Titel und Button */
  min-width: 0;                             /* verhindert Überlauf */
}
.rb-row .rb-box-titel,
.rb-row .rb-box-cta{
  max-width: 100%;                          /* nie über den Rand hinaus */
}
/* Stickerfeld näher an den Inhalt, aber klar getrennt */
.rb-row .rb-icon{
  margin: 0 10px 0 6px !important;          /* top right bottom left */
}
/* Inhalt bündig ohne extra Außenabstände */
.rb-row .rb-box-inhalt{
  margin: 0 !important;
}

/* === RB: Positions-Feintuning — Icon 3mm links, Titel/CTA 5mm links === */
.rb-row .rb-icon{
  transform: translateX(-3mm);
}
.rb-row .rb-box-right{
  transform: translateX(-5mm);
}

/* === RB: Titel/CTA vollständig in der roten Box halten === */
/* Transforms entfernen: keine optische Verschiebung mehr, wir arbeiten über Breiten/Gaps */
.rb-row .rb-icon{ transform: none !important; }
.rb-row .rb-box-right{ transform: none !important; max-width: calc(100% - 96px) !important; /* 56.7px Icon + ~10px Gap + 2*12px Padding + etwas Reserve */ }
.rb-row .rb-box{ overflow: hidden; } /* Sicherheitsgurt: nichts ragt sichtbar heraus */
.rb-row .rb-box-titel, .rb-row .rb-box-cta{ white-space: normal !important; } /* Zeilenumbruch zulassen */

/* === RB Feintuning (Soll-Layout): Sticker ~17mm, Kapseln voll in der roten Box === */
.rb-row .rb-box{
  padding: 12px 14px !important;        /* harmonischer Innenabstand */
  box-sizing: border-box;
  overflow: hidden;                      /* nichts ragt sichtbar heraus */
}
.rb-row .rb-icon{
  width: 64px !important;                /* ≈ 17 mm */
  height: 64px !important;
  margin: 0 10px 0 6px !important;       /* näher an den Inhalt */
  transform: none !important;
  display: flex; align-items: center; justify-content: center;
}
.rb-row .rb-icon img{
  width: 92% !important;                 /* größer, aber nicht anstoßend */
  height: 92% !important;
  display: block; object-fit: contain;
}
.rb-row .rb-box-right{
  align-items: flex-start !important;
  gap: 8px !important;
  transform: none !important;
  /* Platz für Icon (64) + Abstand (10) + Padding-L/R (14+14=28) = 102 px */
  max-width: calc(100% - 102px) !important;
  min-width: 0 !important;
}
.rb-row .rb-box-inhalt{ margin: 0 !important; }
.rb-row .rb-box-titel, .rb-row .rb-box-cta{ white-space: normal !important; max-width: 100% !important; }

/* === RB Feintuning: weiter nach links (wie Soll) === */
/* Linken Innenabstand verringern, damit Icon + Kapseln näher an die rote Boxkante rücken */
.rb-row .rb-box{
  padding-left: 6px !important;           /* vorher 14px */
}
/* Icon näher an die Kante, interner Abstand etwas kleiner */
.rb-row .rb-icon{
  margin-left: 0 !important;              /* vorher 6px */
  margin-right: 8px !important;           /* vorher 10px */
}
/* Rechte Spalte entsprechend mehr nutzbare Breite, sauber begrenzen */
.rb-row .rb-box-right{
  max-width: calc(100% - 92px) !important; /* 64 (Icon) + 8 (Gap) + 14 (Padding rechts) + 6 (Padding links) */
}

/* === RB Feintuning: Stickerrahmen etwas kleiner, damit Kapseln voll reinpassen === */
.rb-row .rb-icon{
  width: 60px !important;   /* vorher 64px */
  height: 60px !important;
  margin-left: 0 !important;
  margin-right: 8px !important;
}
.rb-row .rb-icon img{
  width: 92% !important;
  height: 92% !important;
}
/* Breitenkalkulation anpassen: 60 (Icon) + 8 (Gap) + 6 (Padding links) + 14 (Padding rechts) = 88px */
.rb-row .rb-box-right{
  max-width: calc(100% - 88px) !important;
}

/* === RB Feintuning v10: Icon 58px, Gap = linker Innenabstand (6px) === */
.rb-row .rb-icon{
  width: 58px !important;
  height: 58px !important;
  margin-left: 0 !important;
  margin-right: 6px !important; /* gleich wie padding-left der roten Box */
}
.rb-row .rb-icon img{
  width: 92% !important;
  height: 92% !important;
}
/* Breitenkalkulation: 58 (Icon) + 6 (Gap) + 6 (Padding links) + 14 (Padding rechts) = 84px */
.rb-row .rb-box-right{
  max-width: calc(100% - 84px) !important;
}

/* === RB: Box 5mm breiter (≈ 19px) — Erweiterung nach rechts === */
.rb-row .rb-box{ width: 260px !important; }

/* Overlay für die Kartenflächen: nimmt Drops an und skaliert mit var(--zoom) */
.karte-overlay{ position:absolute; inset:0; pointer-events:auto; }
.karte-overlay img{ display:block; width:100%; height:100%; object-fit:contain; }
/* Hinweis-Pille bei Rückseiten-Stickern (nur manuell wegklickbar) */
.slot-hint{ position:absolute; left: calc(100% + 4px * var(--zoom)); top: 0; max-width: calc(220px * var(--zoom)); z-index: 99; font-size: calc(10px * var(--zoom)); line-height: 1.3; background: rgba(255,243,205,0.96); color:#5c3d00; border: 1px solid rgba(230,200,120,0.95); border-radius: calc(6px * var(--zoom)); padding: calc(6px * var(--zoom)) calc(8px * var(--zoom)); box-shadow: 0 1px 2px rgba(0,0,0,0.12);}
.slot-hint .slot-hint-close{ position:absolute; top: calc(2px * var(--zoom)); right: calc(4px * var(--zoom));
  cursor:pointer; font-weight:bold; opacity:0.6; }
.slot-hint .slot-hint-close:hover{ opacity:1; }
.slot-hint .slot-hint-title{ font-weight:600; margin-bottom: calc(2px * var(--zoom)); display:block; }
</style>
<link href="https://fonts.googleapis.com" rel="preconnect"/><link crossorigin="True" href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&amp;display=swap" rel="stylesheet"/><style data-group="other" id="rb-backtext-typography">
/* Einzelschritt: Rückseiten-Typografie (nur Felder 17–25) */
#feld17, #feld18, #feld19, #feld20, #feld21, #feld22, #feld23, #feld24, #feld25 {
  color: #000 !important;                 /* echtes Schwarz */
  font-family: 'Playfair Display', serif !important;
  font-weight: 700 !important;            /* etwas dicker */
  font-size: calc(20px * var(--zoom)) !important; /* +3px gegenüber 12px-Basis */
}</style><style data-group="other" id="feld6-playfair">
/* Einzelschritt: Feld 6 (Spruch) nur Schriftfamilie auf Playfair Display */
#spruchAnzeige { 
  font-family: 'Playfair Display', serif !important; 
}
</style><style data-group="other" id="feld1-playfair">
/* Einzelschritt: Feld 1 (Name) nur Schriftfamilie auf Playfair Display */
#feld1NameAnzeige { 
  font-family: 'Playfair Display', serif !important; 
}
</style><style data-group="other" id="feld1-strong">
/* Einzelschritt A: Feld 1 (Name) kräftiger, ohne Größenänderung */
#feld1NameAnzeige {
  color: #000 !important;
  font-weight: 700 !important;
}
</style><style data-group="other" id="rb-box-yellow-base">
/* Box-Grundfläche kräftiger (Option M): warmes Gelb + schwarze Kontur */
.rb-box {
  background-color: #FFD86B !important;
  border: 0.5mm solid #000 !important;
}
</style><style data-group="other" id="rb-hint-typography">
/* Schritt 2: Hinweisboxen besser lesbar */
.rb-hint {
  color: #000 !important;
  font-size: 13px !important;
}
</style><style data-group="other" id="feld6-color">
/* Feld 6 (Spruch): nur Farbe auf echtes Schwarz */
#spruchAnzeige {
  color: #000 !important;
}
</style>
<style data-group="other" id="feinarbeit-step5-used-contrast">
/* Einzelschritt 2025-08-25: Aktive Box besser erkennbar (ruhig) */
.rb-box.rb-used {
  background-color: #FFC74D !important;
  /* Zusätzliche, innere Kontur ohne Layout-Verschiebung */
  box-shadow: inset 0 0 0 0.5mm #000000;
}
</style>
<style data-group="base" id="feinarbeit-step7-slot-hint-in-feld17">
/* Einzelschritt 2025-08-25: Slot‑Hinweis gehört IN den vorgesehenen Rahmen (Feld 17).
   Keine Logik. Wir spiegeln die bekannten Koordinaten von Feld 17 in CSS – zoomfest. */
:root{
  --f17-left: 43.297px;
  --f17-top: 12.404px;
  --f17-w: 152.771px;
  --f17-h: 18.917px;
}
/* Slot-Hinweis exakt in Feld 17 platzieren */
.slot-hint{
  position: absolute !important;
  left: calc(var(--f17-left) * var(--zoom)) !important;
  top:  calc(var(--f17-top)  * var(--zoom)) !important;
  width: calc(var(--f17-w)   * var(--zoom)) !important;
  max-width: none !important;
  height: auto !important;                /* Text darf wachsen */
  white-space: normal !important;         /* normaler Umbruch */
  overflow-wrap: anywhere !important;     /* lange Worte umbrechen */
  z-index: 10000 !important;              /* über Karteninhalten, unter Toolbar */
  margin: 0 !important;
  transform: none !important;
}
/* Close-Button innerhalb der Kapsel halten */
.slot-hint .slot-hint-close{
  position: absolute !important;
  top: 2px !important;
  right: 4px !important;
}
</style>
<style data-group="other" id="feinarbeit-step8-catstripe-nordfenster">
/* Einzelschritt 2025-08-25: Kategorie-Farbstreifen (Muster) – „Nordfenster“ = standort.
   Reine CSS-Lösung – 4 px Streifen links in der Box. */
.rb-box { position: relative; }
</style>
<style data-group="base" id="feinarbeit-step19-cat-palette-update">/* Kategorie-Palette – gemäß Vorgabe 2025-08-25 */
:root{
  --cat-standort:   #69B07F; /* Mittelgrün */
  --cat-giessen:    #4D8DFF; /* dunkleres Blau */
  --cat-duengen:    #9B7BD1; /* Flieder */
  --cat-boden:      #6B4E2E; /* Blumenerde-Braun */
  --cat-templija: #FF8C3A; /* kräftiges Aprikosen-Orange */
  --cat-sonstiges:  #6B7280; /* Schiefergrau */
  --cat-wachstum:   #2F7D4B; /* dunkles Grün */

  /* Optionale Tints (für spätere Hintergründe) */
  --tint-standort:   #EAF7EE;
  --tint-giessen:    #E1EBFF;
  --tint-duengen:    #F1E9FF;
  --tint-boden:      #EDE3D6;
  --tint-templija: #FFE6D1;
  --tint-sonstiges:  #EEF0F3;
  --tint-wachstum:   #E5F3EB;
}
</style>
<style data-group="base" id="feinarbeit-step25-pill-instead-of-stripe">
/* Farb-Streifen deaktivieren und farbige "Pille" im Titel einsetzen – nur CSS. */
:root{
  --pill-d: 10px;        /* Durchmesser der Pille/Kugel */
  --pill-left: 8px;      /* Abstand von der linken Innenkante des Titel-Rechtecks */
}

.rb-row[data-cat] .rb-box { background-image: none !important; }           /* alten Streifen aus */
.rb-row[data-cat] .rb-box > :first-child { margin-left: 0 !important; }    /* Verschiebung zurücknehmen */

.rb-row[data-cat] .rb-box-rect { position: relative; } /* Titel-Rechteck wird Anker für die Pille */
.rb-row[data-cat] .rb-box-rect::before {
  content: "";
  position: absolute;
  left: var(--pill-left);
  top: 50%;
  transform: translateY(-50%);
  width: var(--pill-d);
  height: var(--pill-d);
  border-radius: 9999px;
  pointer-events: none;
  box-shadow: 0 0 0 1px #00000033; /* leichte Kontur, sehr dezent */
}

/* Farbe pro Kategorie (nutzt bereits gesetzte --cat-… Variablen) */

</style>
<style data-group="other" id="einzelschritt-feld6-7-dropdown-yellow">
/* Einzelschritt: Dropdowns für Feld 6 (Spruch) & Feld 7 (Smiley) farblich wie gelbe Boxen */
#front-controls #spruchSelect,
#front-controls #smileySelect{
  background: #FFF7CC !important;      /* ruhiges Gelb (wie Boxen) */
  border: 0.5mm solid #000 !important;  /* schwarze Kontur */
  color: #000 !important;
  border-radius: 6px !important;
}
#front-controls #spruchSelect:hover,
#front-controls #smileySelect:hover{ background: #FFD86B !important; }      /* Hover */
#front-controls #spruchSelect:focus,
#front-controls #smileySelect:focus,
#front-controls #spruchSelect:active,
#front-controls #smileySelect:active{
  background: #FFC74D !important; 
  outline: 0.5mm solid #000 !important; 
  outline-offset: 0 !important;
}
</style>
<style data-group="other" id="einzelschritt-mittelstreifen-minus-3mm">
/* Einzelschritt: ~3mm aus der Mitte nehmen, Spalte 2 unverändert */
/* 1) Gap weiter reduzieren */
.columns{ gap: 2px !important; }  /* vorher 10px */

/* 2) Facing Panel-Ränder schmaler machen (je 1px) */
#spalte-links{ border-right-width: 1px !important; }
#spalte-rechts{ border-left-width: 1px !important; }
</style>
<style data-group="other" id="einzelschritt-karte-fertig-style-v4">

#btn-karte-fertig-ok{
  padding: 10px 16px;
  border: 1px solid #000;
  background: #69B07F;            /* Grün (wie Hoffnung), im Farbschema vorhanden */
  color: #000;                     /* UI-weit schwarze Schrift beibehalten */
  border-radius: 8px;
  font: inherit;
  cursor: pointer;
}
#btn-karte-fertig-ok:hover{ filter: brightness(0.97); }
#btn-karte-fertig-ok:active{ filter: brightness(0.94); }
</style>
<style data-group="other" id="einzelschritt-kartenbereich-sticky">
/* Einzelschritt: Kartenbereich immer sichtbar machen (Weg minimieren) */
#spalte-rechts .kartenbereich{
  position: sticky;
  top: 8px;               /* klebt 8px unter dem Rahmen/Buttons */
  z-index: 2;
}
</style>
<style data-group="other" id="einzelschritt-scrollbar-spalte1-dunkler">
/* Sichtbare, dunkle Scrollleiste NUR für Spalte 1 */
#spalte-links{
  scrollbar-width: auto;                 /* Firefox */
  scrollbar-color: #222 #d9d9d9;
}
#spalte-links::-webkit-scrollbar{        /* Chrome/Edge/WebKit */
  width: 12px;
}
#spalte-links::-webkit-scrollbar-thumb{
  background: #222;
  border-radius: 10px;
}
#spalte-links::-webkit-scrollbar-thumb:hover{
  background: #111;
}
#spalte-links::-webkit-scrollbar-track{
  background: #d9d9d9;
}
</style>
<style data-group="other" id="einzelschritt-spalten-hoehe-25cm">
/* Einzelschritt: Sichtbare Spaltenhöhe = 25 cm */
.columns{
  height: 25cm !important;
}
</style>
<style data-group="other" id="einzelschritt-spalte2-ohne-scroll">
/* Einzelschritt: Spalte 2 ohne Scrollleiste */
#spalte-rechts{
  overflow-y: hidden !important; /* keine Scrollbar mehr */
}
</style>
<style data-group="other" id="einzelschritt-pflanzensuche-focus-dunkelgruen">
/* Einzelschritt: Fokus-Rahmen der Pflanzensuche von Blau → Dunkelgrün */
#pflanzensuche:focus,
#pflanzensuche:focus-visible{
  outline: 2px solid #1B5E20 !important;   /* Dunkelgrün */
  outline-offset: 2px;
  border-color: #1B5E20 !important;
  box-shadow: 0 0 0 3px rgba(27, 94, 32, 0.25) !important; /* sanfter grüner Schein */
}
</style>
<style data-group="other" id="einzelschritt-suchlupe-css">
/* Einzelschritt A: Lupe in der Pflanzensuche (optisch, kein JS) */
#pflanzensuche{
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%231B5E20' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='11' cy='11' r='7'/><line x1='21' y1='21' x2='16.65' y2='16.65'/></svg>");
  background-repeat: no-repeat;
  background-position: 10px center;  /* links innen */
  background-size: 16px 16px;
  padding-left: 36px;                /* Platz für Lupe */
}
/* Fokus bleibt dunkelgrün wie gewünscht; Icon bleibt gleichfarbig */
#pflanzensuche:focus, #pflanzensuche:focus-visible{
  outline: 2px solid #1B5E20 !important;
  outline-offset: 2px;
  border-color: #1B5E20 !important;
  box-shadow: 0 0 0 3px rgba(27, 94, 32, 0.25) !important;
}
</style>
<style data-group="card" id="einzelschritt-rueckseite-lineal-1cm-rechts-v2">
/* KartenRÜCKSEITE + Lineal jeweils exakt 1 cm nach rechts verschieben.
   SVGs/Koordinaten/Zoom unverändert; Abstand zueinander bleibt konstant. */
#karte-rueckseite,
#kartenbereich #lineal{
  transform: translateX(10mm) !important;
}
</style>
<style data-group="other" id="einzelschritt-spaltenbreite-delta-4mm">
/* Einzelschritt: Spalte 1 +4mm, Spalte 2 −4mm, Gesamtbreite unverändert */
.columns{
  grid-template-columns: calc(50% + 4mm) calc(50% - 4mm) !important;
}
</style>
<style data-group="other" id="einzelschritt-panel-tools-left-3mm">
/* Einzelschritt: Buttonleiste über den Karten 3 mm nach links verschieben */
#spalte-rechts .panel-tools{
  position: relative;
  left: -3mm; /* 3 mm nach links */
}
</style>
<style data-group="other" id="einzelschritt-spalte1-scrollbar-schmaler">
/* Einzelschritt: Linke Scrollleiste schmaler + mehr Platz für die gelben Boxen */
#spalte-links{
  scrollbar-gutter: stable both-edges;
  padding-right: 10px !important;   /* vorher höher – gibt Content rechts wieder frei */
  box-sizing: border-box;
  overflow-y: auto;                  /* Sicherheitsnetz */
}
/* Firefox */
#spalte-links{ scrollbar-width: thin; scrollbar-color: #222 #e2e2e2; }
/* Chrome/Edge/WebKit */
#spalte-links::-webkit-scrollbar{ width: 8px; }              /* schmaler */
#spalte-links::-webkit-scrollbar-thumb{ background:#222; border-radius:10px; }
#spalte-links::-webkit-scrollbar-track{ background:#e2e2e2; }
</style>
<style data-group="other" id="einzelschritt-spalte1-minus3mm-spalte2-plus3mm">

.columns{
  grid-template-columns: calc(50% + 1mm) calc(50% - 1mm) !important; /* vorher +4/-4mm */
}
</style>
<style data-group="other" id="force-scroll-bottom-padding">
  /* +1cm (zoom-synchron) Scroll-Reserve direkt im Scroll-Container */
  #spalte-rechts{
    padding-bottom: calc(10mm * var(--zoom)) !important;
  }
</style>
<style data-group="other" id="rb-kose-plant-hint-padding">
  /* Gleiches Innenpadding wie beim "Pflanze noch nicht in datenbank"-Hinweis */
  #rb-kose-hint, #rb-plant-hint{
    padding: calc(6px * var(--zoom)) calc(8px * var(--zoom));
    box-sizing: border-box;
    display: block;
  }
</style>
<style data-group="other" id="rb-plant-hint-raise-z">
  /* Pflanzennamen-Längenhinweis sicher sichtbar über der Steuerleiste */
  #rb-plant-hint{
    position: relative !important;
    z-index: 9999 !important;
  }
</style>

<style data-group="other" id="rb-hints-opaque-white">
  /* Lesbarkeit: alle Hinweis-Boxen deckend weiß (insb. Rückseiten-Sticker-Hinweis) */
  [id$="-hint"]{
    background: #FFFFFF !important;
    opacity: 1 !important;
    -webkit-backdrop-filter: none !important;
    backdrop-filter: none !important;
  }
</style>
<style data-group="other" id="rb-hints-opaque-strong">
  /* Hints wirklich deckend: kein Durchscheinen */
  [id$="-hint"]{
    background: #FFFFFF !important;
    opacity: 1 !important;
    mix-blend-mode: normal !important;
    filter: none !important;
    -webkit-backdrop-filter: none !important;
    backdrop-filter: none !important;
    isolation: isolate !important; /* eigener stacking context */
  }
  /* Falls das Layout das Weiß auf ein Kindelement legt, erzwingen wir es auch dort */
  [id$="-hint"] *{
    background: transparent !important; /* Kinder nicht grau einfärben */
    mix-blend-mode: normal !important;
    filter: none !important;
  }
</style>
<style data-group="card" id="hint-raise-style">
#karte-vorderseite.hint-raise, #karte-rueckseite.hint-raise { position: relative; z-index: 20000; }
</style>
<style data-group="other" id="steuerleiste-bg-980-px-fix">

/* === Blätter-Hintergrund über volle 980px in der Steuerleiste === */
.steuerleiste{ position:relative; overflow:hidden; }
.steuerleiste::before{
  content:"";
  position:absolute;
  left:-12px;                  /* gleicht das 12px Padding links aus */
  top:0;
  width: calc(100% + 24px);    /* +12px links +12px rechts = volle Innenbreite des 980px-Rahmens */
  height: 100%;
  
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover;      /* füllt die Leiste ohne Lücken */
  z-index: 0;
}
/* Inhalt darüber legen */
.steuerleiste > *{ position:relative; z-index:1; }

</style>
<style data-group="other" id="other-css-042">
/* Feld 7 – Custom-Dropdown (ikonisch) – isoliert */
#smileySelect{ display:none !important; } /* bleibt Datenquelle */
#feld7-dd{ position:relative; display:inline-block; width:100%; max-width: 240px; }
#feld7-trigger{
  display:flex; align-items:center; gap:8px;
  width:100%; height:34px;
  border:1px solid #888; border-radius:8px; background:#ffd86b;
  padding:6px 10px; cursor:pointer; color:#000;
}
#feld7-trigger img{ width:20px; height:20px; display:block; }
#feld7-trigger .label{ flex:1; text-align:left; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
#feld7-menu{
  position:absolute; left:0; top:100%; margin-top:6px; z-index:9999;
  min-width:100%; background:#FFF7CC; border:1px solid #000; border-radius:8px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.12);
  display:none; max-height:240px; overflow:auto; color:#000;
}
#feld7-dd.open #feld7-menu{ display:block; }
.feld7-item{ display:flex; align-items:center; gap:10px; padding:8px 10px; cursor:pointer; }
.feld7-item img{ width:22px; height:22px; }
.feld7-item:hover, .feld7-item[aria-selected="true"]{ background:#FFD86B; }
</style><style id="toolbar-final-980">
/* FINAL: Steuerleisten-Hintergrund als externe PNG (980px), bündig im 980er Wix-Rahmen */
.steuerleiste{
  width: 980px !important;
  max-width: 980px !important;
  margin: 0 auto !important;
  box-sizing: border-box !important;
  padding-left: 16px !important;
  padding-right: 16px !important;
  background: url('steuerleiste_bg_980.png') left center / 100% 100% no-repeat #e6efe6 !important;
  background-origin: border-box !important;
  background-clip: border-box !important;
}
.steuerleiste::before{ content: none !important; background: none !important; }

/* Use cropped background (980 px), same path base '' */
.steuerleiste{
  background-image: url('steuerleiste_bg_980_cropped.png') !important;
  background-size: 100% 100% !important;
  background-position: left center !important;
}
</style>
<style data-group="dropdown" id="o1q-dd-z">
/* O1q: Sicherheit, dass Panel über allem liegt */
#rb-dropdown{ z-index: 9999; }
</style>
<style data-group="base" id="o2n-vertical-inside-panel">
/* O2n: Im Panel (#rb-dropdown) die Pillen strikt untereinander anordnen */
#rb-dropdown #rb-dd-body{
  display: block !important;
  flex-direction: column !important;
  align-items: stretch !important;
  gap: 6px !important;
}
#rb-dropdown .rb-dd-item{
  display: block !important;
  width: 100% !important;
  margin: 0 !important;
}
</style>
<style data-group="dropdown" id="o2p-center-items-panel">
/* O2p: Texte in den Dropdown-Pillen optisch exakt zentrieren (nur im Panel) */
#rb-dropdown .rb-dd-item{
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
  padding: 0 !important;
  height: calc(18.917px * var(--zoom)) !important;
  line-height: calc(18.917px * var(--zoom)) !important;
  box-sizing: border-box !important;
}
</style>
<style data-group="card" id="field17-25-white-bg-fix">
/* Unsichtbare weiße Rechtecke unter Feldern 17–25 */
#karte-rueckseite .slot:nth-child(17),
#karte-rueckseite .slot:nth-child(18),
#karte-rueckseite .slot:nth-child(19),
#karte-rueckseite .slot:nth-child(20),
#karte-rueckseite .slot:nth-child(21),
#karte-rueckseite .slot:nth-child(22),
#karte-rueckseite .slot:nth-child(23),
#karte-rueckseite .slot:nth-child(24),
#karte-rueckseite .slot:nth-child(25) {
    background-color: #fff !important;
    z-index: 0 !important;
}
</style><style data-group="card" id="hint-layer-style-step2">/* === Einzelschritt 2: fester Hint-Layer über den Feldern (stabil, rückbaubar) === */
#karte-rueckseite { position: relative; }
#karte-rueckseite #hint-layer{
  position: absolute;
  inset: 0;
  z-index: 12000;          /* über Slots/Dragtext, unter globalen Modals */
  pointer-events: none;    /* Layer selbst klickt nicht */
  isolation: isolate;      /* eigener Stacking-Context für Sicherheit */
}
#karte-rueckseite #hint-layer .slot-hint{
  pointer-events: auto;    /* Schließen/X weiterhin klickbar */
}</style>
<style data-step="A-css-alias" id="compat-templija-alias">
/* CSS-only Kompatibilität (keine JS-Änderungen):
   1) --cat-/--tint-temperatur erben die templija-Werte.
   2) data-cat="temperatur" wird wie templija eingefärbt. */
:root{
  --cat-temperatur: var(--cat-templija);
  --tint-temperatur: var(--tint-templija);
}
.rb-row[data-cat="temperatur"] .rb-box-rect::before,
.rb-box-rect[data-cat="temperatur"]::before{
  background: var(--cat-templija) !important;
}
</style>
<style id="s3c-search-hint-correct-id">
/* S3c: Correct element and placement for the 'no hit' hint under the search */
#nohit-toast{
  position: relative;
  top: -14px;       /* weiter hoch als -7px, damit nichts abgeschnitten wird */
  z-index: 9999;    /* sicher über Spalte 1 */
}
</style>
<style id="s21b-hide-empty-hints">
#nohit-toast:empty,
#rb-plant-hint:empty,
#rb-kose-hint:empty {
  display: none !important;
}
</style>
<link href="data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'&gt;&lt;rect width='32' height='32' fill='%23228B22'/&gt;&lt;path d='M8 20 C14 10, 22 10, 24 6 C22 16, 14 22, 12 26 Z' fill='white'/&gt;&lt;/svg&gt;" rel="icon" sizes="any"/>
<script>/* STICKER_HINTS shim (S06 guarded) */ if (!window.STICKER_HINTS) window.STICKER_HINTS = Object.freeze({});</script>
<script id="s12-csv-loader">
(function(){
  'use strict';
  // CSV fetch with timeout, absolute URL resolution, and logging.
  // Usage: fetchCsv(path, { timeoutMs: 8000 }).then(text => ...)
  window.fetchCsv = async function(path, opts){
    opts = opts || {};
    var tId, ctrl = new AbortController();
    var timeout = Math.max(2000, opts.timeoutMs || 8000);
    // Resolve path against the current HTML URL to avoid server-root issues
    var url;
    try{
      url = (typeof path === 'string' && /^https?:/i.test(path))
        ? path
        : new URL(path, window.location.href).toString();
    }catch(_){
      url = path;
    }
    window.__DEBUG__ && console.info('[S12b] Lade CSV:', url);
    try{
      tId = setTimeout(function(){ try{ ctrl.abort(); }catch(_){ } }, timeout);
      var res = await fetch(url, { signal: ctrl.signal, cache: 'no-store' });
      if(!res || !res.ok){ throw new Error('CSV HTTP '+(res && res.status)); }
      var txt = await res.text();
      if(!txt || !String(txt).trim()){ throw new Error('CSV leer'); }
      var head = txt.split(/\r?\n/, 3).join("\n");
      if(!/[;,]/.test(head)){ console.warn('[S12b] CSV ohne Trenner? Prüfe Trennzeichen.', url); }
      return txt;
    }catch(err){
      window.__DEBUG__ && console.warn('[S12b] CSV nicht geladen:', url, (err && err.message) || err);
      try{
        var st = document.getElementById('rb-status');
        if(st){ st.textContent = 'CSV nicht geladen – Fallback aktiv: '+url; }
      }catch(_){ }
      throw err;
    }finally{
      if(tId) try{ clearTimeout(tId); }catch(_){ }
    }
  };
})();
</script>
<script id="s12h-path-guard">
(function(){
  // Feste GitHub-Pfade für CSVs – funktionieren in Wix und lokal im Browser
  window.csvPath = "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/pflanzendaten.csv";
  window.masterPath = "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv";
})();</script>
<style id="abschluss-geruest-css">
#abschluss-trigger-row{ max-width:980px; margin:12px auto 18px; display:flex; justify-content:center; min-width:420px; }
#abschluss-trigger-row #btn-open-abschluss{ border:0.5mm solid #000; background:#fff; border-radius:6px; padding:8px 12px; font:inherit; cursor:pointer; }

#abschluss-panel{ max-width:980px; margin:36px auto 40px; padding:12px 8px; background:transparent; }
#abschluss-controls{ display:flex; gap:8px; flex-wrap:wrap; margin:103px 0 10px; }
#abschluss-controls button, #abschluss-actions button{ border:0.5mm solid #000; background:#fff; border-radius:6px; padding:6px 10px; font:inherit; cursor:pointer; }


#abschluss-card{ position:relative; display:inline-block; }
#abschluss-card .wrap{ position:relative; width:calc(54mm * var(--zoom)); height:calc(85mm * var(--zoom)); overflow:hidden; }
#abschluss-ruler{ position:absolute; width:calc(54mm + 6mm); height:calc(85mm + 6mm); border:0.2mm dashed #666; pointer-events:none; display:none; top: calc(50% - (85mm + 6mm)/2); left: calc(50% - (54mm + 6mm)/2); }
#abschluss-stage.zoom-100 #abschluss-ruler{ display:block; }
#abschluss-stage.zoom-100 .wrap{ transform:none; transform-origin: top left; }

#abschluss-card .side{ position:absolute; inset:0; left:0; top:0; width:calc(54mm * var(--zoom)); height:calc(85mm * var(--zoom)); box-sizing:border-box; margin:0!important; padding:0!important; border:none!important; outline:none!important; transform:none!important; }
#abschluss-card .front-side{ opacity:1; }
#abschluss-card .back-side{ opacity:0; pointer-events:none; }
#abschluss-card.show-back .front-side{ opacity:0; pointer-events:none; }
#abschluss-card.show-back .back-side{ opacity:1; pointer-events:auto; }
#abschluss-card, #abschluss-card *{ transition:none!important; }
#abschluss-card *{ user-select:none!important; pointer-events:none!important; }
#abschluss-controls button, #abschluss-actions button, #abschluss-options input, #abschluss-options label, #abschluss-qty{ pointer-events:auto!important; user-select:auto!important; }

#abschluss-options{ margin:12px 0; display:grid; gap:6px; border:none; padding:0; }
#abschluss-options .opt{ display:flex; align-items:center; gap:8px; }
#abschluss-qtywrap{ display:flex; align-items:center; gap:8px; margin:8px 0 14px; }
#abschluss-qty{ width:72px; }
#abschluss-actions{ display:flex; gap:8px; flex-wrap:wrap; }
#abschluss-cart-msg{ margin-top:8px; min-height:20px; font-size:.95em; }
#abschluss-cart-msg.ok{ color:#0a0; } #abschluss-cart-msg.err{ color:#a00; }

/* Editor-Overlays im Abschluss verbergen */
#abschluss-card .side .rahmen-overlay, 
#abschluss-card .side .editor-rahmen, 
#abschluss-card .side .bearbeitungs-rahmen,
#abschluss-card .side [data-editor-only], 
#abschluss-card .side [data-role="editor-only"]{ display:none!important; }

/* Controls sicher klickbar */
#abschluss-controls, #abschluss-actions, #abschluss-options, #abschluss-qtywrap{
  position: relative; z-index: 2;
}

#abschluss-controls button, #abschluss-actions button, #abschluss-options input, #abschluss-options label, #abschluss-qty{
  pointer-events: auto !important;
}
</style>



<style>
/* [L2-Ausrichten-v3] Abschlussbereich neu anordnen */
#abschluss-panel{ max-width:980px; margin:16px auto; }
#abschluss-controls{ margin-bottom:8px; }

#abschluss-grid{
  margin-top:56px;
  display:grid;
  grid-template-columns: minmax(0, 1fr) 360px;
  gap:16px;
  align-items:start;
}

#abschluss-grid #abschluss-stage{
  width:auto !important;
  margin:0 !important;
  display:grid;
  place-items:start center; /* Karte linksbündig unter Buttons, optisch mittig in eigener Spalte */
  justify-items:start;
}

#abschluss-card{ margin-left: 0 !important; }

#abschluss-sidebar{
  display:grid;
  align-content:start;
  gap:12px;
}

#abschluss-sidebar #abschluss-options,
#abschluss-sidebar #abschluss-qtywrap,
#abschluss-sidebar #abschluss-actions,
#abschluss-sidebar #abschluss-cart-msg{
  margin:0 !important;
}

#abschluss-qtywrap{ margin-top:24px; } /* Menge weiter runter */

/* Feinanpassung: Buttons springen nicht in der Breite */
#abschluss-actions button{ white-space:nowrap; }
</style><style>
/* [L2-Ausrichten-v4] 20px tiefer + weißes Rahmenbrett unter der Karte */

/* Sicherheit: Karte nicht breiter ziehen, zentriert im Rahmen */
#abschluss-card-frame #abschluss-card{ margin: 0 !important; }
#abschluss-card-frame.l2-card-frame{
  /* Fester Anker: oben links, ohne Zentrierung oder Auto-Margins */
  position: relative;
  display: inline-block;
  box-sizing: content-box;
  padding: calc(20px * var(--zoom));
  background: #fff;
  margin-top: calc(20px * var(--zoom));
  margin-left: 10mm; /* Abschluss: Karte + Weißfläche ca. 1cm nach rechts */
}
</style><style>
/* [L2-Ausrichten-v5] Karte zentriert unter Buttons + Sidebar rechts; Rahmen zoom-synchron */
#abschluss-panel{ max-width:980px; margin:16px auto; }
#abschluss-controls{ margin-bottom:8px; }

#abschluss-grid{ display:grid; grid-template-columns: 1fr; gap:16px; align-items:start; }

/* Breit: vier Spalten (Rand | Karte | Sidebar | Rand) -> Karte exakt mittig unter Buttons */
@media (min-width: 1024px){
  #abschluss-grid{
    grid-template-columns: 1fr minmax(0, auto) 360px 1fr;
  }
  #abschluss-stage{ grid-column: 2; justify-self: center; }
  #abschluss-sidebar{ grid-column: 3; }
}

/* Karte selbst nicht festbreiten-gebunden */
#abschluss-stage{
  width: auto !important;
  margin: 0 !important;
  display: grid;
  place-items: start center;
}

/* Weißes Brett unter der Karte, 20px umlaufend – skaliert mit Zoom */
#abschluss-card-frame.l2-card-frame{
  display: grid;
  place-items: center;
  padding: calc(20px * var(--zoom));
  background: #ffffff;
  margin-top: calc(20px * var(--zoom));
  margin-left: 0; /* zentriert: kein zusätzlicher Rechtsversatz */
}
#abschluss-card-frame #abschluss-card{ margin:0 !important; }

/* Menge etwas tiefer halten */
#abschluss-qtywrap{ margin-top: calc(24px * var(--zoom)); }
</style><style>
/* [L2-Ausrichten-v6] Zentrierung unter Buttons, Rahmen zoom-synchron, kein Überlappen bei 150% */
#abschluss-controls{ text-align: center; }

/* Basis-Grid: eine Spalte -> Karte unter den Buttons, Sidebar darunter */
#abschluss-grid{ display:grid; grid-template-columns: 1fr; gap:16px; align-items:start; }

/* Breit + 100% Zoom: Karte links, Sidebar rechts; Karte exakt mittig unter Buttons */
@media (min-width: 1024px){
  body.zoom-100 #abschluss-grid{ grid-template-columns: max-content 360px; }
  body.zoom-100 #abschluss-stage{ justify-self: center; }
  body.zoom-100 #abschluss-sidebar{ align-self: start; }
}

/* Bei 150% Zoom: IMMER 1-Spalten-Layout (Sidebar unter Karte) → keine Überlappung */
body.zoom-150 #abschluss-grid{ grid-template-columns: 1fr !important; }
body.zoom-150 #abschluss-stage{ justify-self: center; }
body.zoom-150 #abschluss-sidebar{ margin-top: 12px; }

/* Weißes Brett: inline-block, padding skaliert, zentriert */
#abschluss-card-frame.l2-card-frame{
  display: inline-block;
  box-sizing: content-box;
  padding: calc(20px * var(--zoom));
  background: #fff;
  margin-top: calc(20px * var(--zoom));
}
#abschluss-stage{ text-align:center; } /* sichere Zentrierung */
#abschluss-card{ margin:0 !important; display:inline-block; }
</style><style>
/* [L2-Ausrichten-v7] Zoom am Rahmen statt an .wrap → Rahmen skaliert mit; Karte mittig unter Buttons */
#abschluss-controls{ text-align:center; }

/* Grundlayout */
#abschluss-grid{ display:grid; grid-template-columns: 1fr; gap:16px; align-items:start; }
#abschluss-stage{ justify-self:center; text-align:center; }

/* 2 Spalten nur bei 100% + breite View */
@media (min-width: 1024px){
  body.zoom-100 #abschluss-grid{ grid-template-columns: max-content 360px; }
  body.zoom-100 #abschluss-stage{ justify-self:center; }
}
/* 150%: immer 1 Spalte -> kein Überlappen */
body.zoom-150 #abschluss-grid{ grid-template-columns: 1fr !important; }
body.zoom-150 #abschluss-sidebar{ margin-top: 12px; }

/* Weißes Brett: umlaufend 20px, skaliert gemeinsam mit Karte */
#abschluss-card-frame{
  display:inline-block;
  background:#fff;
  padding:20px;             /* Basis 20px (wird durch transform mitskaliert) */
  margin-top:20px;
  transform-origin: top center;
}

/* Zoomlogik: Skaliere den Rahmen anstelle der .wrap */
#abschluss-stage.zoom-100 #abschluss-card-frame{ transform:none; }
#abschluss-stage.zoom-150 #abschluss-card-frame{ transform:none; }

/* Und schalte die alte Skalierung der .wrap ab, damit nicht doppelt skaliert wird */
#abschluss-stage.zoom-100 .wrap{ transform:none !important; }
#abschluss-stage.zoom-150 .wrap{ transform:none !important; }

/* Sicherheit: Karte bündig im Rahmen */
#abschluss-card{ display:inline-block; margin:0 !important; position:relative; z-index:1; }
</style><style>
/* [L2-Ausrichten-v8] Ausführung etwas tiefer + kleine Sidebar-Verbesserung */
#abschluss-options{ margin-top: calc(16px * var(--zoom)); }   /* Wunsch: etwas tiefer */
#abschluss-qtywrap{ margin-top: calc(16px * var(--zoom)); }   /* gleichmäßiger Rhythmus */
#abschluss-actions{ display:flex; flex-wrap:wrap; gap:8px; }  /* saubere Button-Reihen ohne Überlappung */
</style><style>
/* [L2-Fix6] 20px tiefer + Warenkorb nie überdeckt (100%/150%) */
#abschluss-controls{ margin-bottom: 8px; text-align: center; }

/* Karte + Papier 20px tiefer unter der Buttonreihe */
#abschluss-stage{
  position: relative;
  margin-top: 20px !important;
  justify-self: center;
  text-align: center;
}

/* Konstanter Papierrand 20px rundum – unabhängig vom Zoom */
#abschluss-card-paper{
  position: absolute;
  z-index: 0;
  left: -20px; top: -20px;
  width:  calc(54mm * var(--zoom) + 40px);
  height: calc(85mm * var(--zoom) + 40px);
  background: #fff;
  border-radius: 10px;
  box-shadow: 0 1px 3px rgba(0,0,0,.08);
}

/* Karte über Papier; .wrap skaliert weiterhin 100%/150% */
#abschluss-card{ position: relative; z-index: 1; display: inline-block; }
#abschluss-stage.zoom-100 .wrap{ transform: none; transform-origin: top left; }
#abschluss-stage.zoom-150 .wrap{ transform: scale(1.5); transform-origin: top left; }

/* WICHTIG: zusätzlicher Platz unter der Karte proportional zum Zoom + 40px Papier (20 oben + 20 unten)
   So überdeckt die Karte NIE den Warenkorb-Überblick. */
#abschluss-stage::after{
  content: "";
  display: block;
  height: calc((85mm * (var(--zoom) - 1)) + 40px);
}
</style><style>
/* [L2-CartTwoRows] Cart-Items zweizeilig: 1) Name oben, 2) Controls unten */
#abschluss-cart-list ul{ margin: 10px 0 0 18px; padding: 0; }
#abschluss-cart-list li{
  display: grid !important;
  grid-template-columns: auto auto auto auto auto 1fr;
  grid-column-gap: 6px;
  grid-row-gap: 4px;
  align-items: center;
  padding: 6px 0;
}
/* Name (erstes Kind) soll die ganze Zeile belegen, Text darf umbrechen */
#abschluss-cart-list li > span:first-child{
  grid-column: 1 / -1;
  line-height: 1.25;
  white-space: normal;
  word-break: break-word;
}

/* Controls gehören in die zweite Zeile */
#abschluss-cart-list li > input[type="number"],
#abschluss-cart-list li > button,
#abschluss-cart-list li > strong{
  grid-row: 2;
}
/* Preis rechtsbündig */
#abschluss-cart-list li > strong{ justify-self: end; }

/* Etwas Luft zwischen Cart-Liste und Folgeelementen */
#abschluss-cart-list{ margin-bottom: 8px; }
</style><style>
/* [L2-CartRight] Cart-Liste in die Sidebar verlegt – kein Überlappen mit der Karte */
@media (min-width: 1024px){
  body.zoom-100 #abschluss-grid{ grid-template-columns: max-content 360px; gap: 20px; }
}

/* Cart-Liste spacing in Sidebar */
#abschluss-sidebar #abschluss-cart-list{ margin-top: 12px; }
#abschluss-sidebar #abschluss-cart-list ul{ margin: 8px 0 0 18px; padding: 0; }
#abschluss-sidebar #abschluss-cart-list li{
  display: grid !important;
  grid-template-columns: auto auto auto auto 1fr;
  grid-row-gap: 4px;
  align-items: center;
  padding: 6px 0;
}
#abschluss-sidebar #abschluss-cart-list li > span:first-child{
  grid-column: 1 / -1;
  line-height: 1.25;
  white-space: normal;
  word-break: break-word;
}
#abschluss-sidebar #abschluss-cart-list li > input[type="number"],
#abschluss-sidebar #abschluss-cart-list li > button,
#abschluss-sidebar #abschluss-cart-list li > strong{ grid-row: 2; }
#abschluss-sidebar #abschluss-cart-list li > strong{ justify-self: end; }

/* Bei 150% bleibt 1-Spalte – Cart steht dann unter der Karte im Fluss, ohne Überlappung (durch Stage-Reserve) */
body.zoom-150 #abschluss-grid{ grid-template-columns: 1fr !important; }
</style><style>
/* [L2-OrderFix] Reihenfolge der 5 Balken: "Ausgewählte Karte aktualisieren" ganz oben */
#abschluss-sidebar #btn-cart-apply-update,
#abschluss-sidebar #btn-cart-copylink,
#abschluss-sidebar #btn-cart-clear,
#abschluss-sidebar #btn-cart-export,
#abschluss-sidebar #btn-cart-import{
  display:block;
  width:100%;
  margin:6px 0;
}
</style><style id="cart_buttons_left_align">
/* Cart-Zeilen kompakter: Label/Qty/Buttons links, freie Fläche ganz rechts */
#abschluss-cart-list li{
  grid-template-columns: max-content auto auto auto 1fr !important;
  justify-items: start !important;
  column-gap: 10px !important; /* etwas Luft zwischen den Buttons */
}
/* Preis/Ende-Elemente am rechten Rand halten (falls vorhanden) */
#abschluss-cart-list li > strong[style*="justify-self: end"],
#abschluss-cart-list li > strong.price{
  justify-self: end !important;
}
</style><style id="cart_compact_and_fix_ruler">
/* Cart-Zeilen kompakter */
#abschluss-cart-list li{
  column-gap: 8px !important;               /* vorher 10px */
}
#abschluss-cart-list li input[type="number"]{
  width: 52px !important;                    /* vorher ~64px */
  margin-top: -16px;                         /* ca. 4mm nach oben verschoben */
}

/* Kartenrahmen (ruler) fix über der Karte pinnen, nicht mit Layout verschieben */
#abschluss-card-frame{ position: relative !important; }
#abschluss-ruler{
  position: absolute !important;
  inset: 0 !important;                       /* top/right/bottom/left = 0 */
  pointer-events: none !important;           /* keine Interaktion */
}
</style><style id="no_ruler_toggle_css">
/* Rahmen bei Übernahme/Checkout ausblenden */
.no-ruler #abschluss-ruler{ display:none !important; }
</style><style id="hide_ruler_in_abschluss">
/* Abschlussbereich: grünen Rahmen (Ruler) dauerhaft ausblenden */
#abschluss-panel #abschluss-ruler{
  display: none !important;
}
</style><style id="ruler_white_abschluss">
/* Abschlussbereich: grünen Rahmen nicht ausblenden, sondern weiß einfärben */
#abschluss-panel #abschluss-ruler{
  display: block !important;
  background: #fff !important;
  border: 1px solid #fff !important;
  box-shadow: none !important;
  outline: none !important;
  opacity: 1 !important;
  pointer-events: none !important;
}
#abschluss-panel #abschluss-ruler::before,
#abschluss-panel #abschluss-ruler::after{
  content: none !important; /* evtl. dekorative Pseudo-Elemente abschalten */
}
</style><style id="force-white-frame-v1">
/* === Einzelschritt: Grünen Rahmen/Lineal in DIESER Datei neutralisieren (weiß) === */
/* 1) Falls der aktive Rahmen über CSS-Variablen gefärbt wird */
:root{
  --active-frame-color: #ffffff !important;
}

/* 2) Editor-/Bearbeitungsrahmen direkt: keine grüne Fläche, Kontur weiß */
.rahmen-overlay,
.editor-rahmen,
.bearbeitungs-rahmen{
  background: transparent !important;
  border-color: #ffffff !important;
  outline-color: #ffffff !important;
  box-shadow: none !important;
  mix-blend-mode: normal !important;
}

/* Wenn die Kontur über outline/box-shadow kommt */
.rahmen-overlay{ 
  outline: 2px solid #ffffff !important;
  box-shadow: none !important;
}

/* 3) Lineal/Lineal-Konturen (Editor + Abschluss) weiß statt grün/grau */
#lineal, .lineal,
#abschluss-ruler{
  background: #ffffff !important;
  border-color: #ffffff !important;
  color: #ffffff !important;
  box-shadow: none !important;
}
#lineal *, .lineal *,
#abschluss-ruler *{
  stroke: #ffffff !important;
  fill: #ffffff !important;
  color: #ffffff !important;
}

/* 4) Fallback: irgend­ein 'active-frame-style' hart überschreiben */
#active-frame-style, .active-frame-style{
  color: #ffffff !important;
  border-color: #ffffff !important;
}
</style><style id="white_frame_outside_not_inner">
/* Weißer Rahmen: Innenmaß der Karte bleibt exakt 54x85mm.
   Wir zeichnen die Kontur NUR außerhalb (outline/box-shadow), keine Border. */

/* Editor-/Overlay-Rahmen */
.rahmen-overlay, .editor-rahmen, .bearbeitungs-rahmen{
  border: 0 !important;                     /* nichts nach innen */
  outline: 2px solid #fff !important;       /* weiße Kontur */
  outline-offset: 0px !important;           /* außen an der Kante */
  box-shadow: 0 0 0 0 #0000 !important;     /* kein Schatten */
  background: transparent !important;
  pointer-events: none !important;
}

/* Abschluss-/Ruler-Komponente ebenfalls ohne "inward"-Kante */
#abschluss-ruler, .abschluss-ruler, #lineal, .lineal{
  border: 0 !important;
  outline: 2px solid #fff !important;
  outline-offset: 0px !important;
  box-shadow: 0 0 0 0 #0000 !important;
  background: transparent !important;
  pointer-events: none !important;
}
#abschluss-ruler *, .abschluss-ruler *{
  stroke: #fff !important;
  fill: #fff !important;
}

/* Fallback für Browser, die outline schlecht rendern: Außenring via box-shadow */
.rahmen-overlay, .editor-rahmen, .bearbeitungs-rahmen,
#abschluss-ruler, .abschluss-ruler, #lineal, .lineal{
  box-shadow: 0 0 0 2px #fff !important; /* außen, frisst keine Innenfläche */
}
</style><style id="no_frame_on_lineal_override">
/* Lineal ohne Rahmen/Kontur – keine outline/box-shadow/border */
#lineal, .lineal{
  outline: 0 !important;
  box-shadow: none !important;
  border: 0 !important;
  background: transparent !important;
  pointer-events: auto !important; /* falls zuvor deaktiviert */
}
</style><style id="white_frame_outside_thicker">
/* Weißer Rahmen: NUR außen breiter, Innenmaß bleibt unverändert */
.rahmen-overlay, .editor-rahmen, .bearbeitungs-rahmen,
#abschluss-ruler, .abschluss-ruler{
  outline: 0 !important;                 /* keine Innenkante */
  box-shadow: 0 0 0 6px #fff !important; /* Außenring: 6px (anstatt 2px) */
  background: transparent !important;
  border: 0 !important;
  mix-blend-mode: normal !important;
}
</style><style id="center_card_in_abschluss">
/* Abschlussbereich: Karte exakt mittig unter die oberen Buttons zentrieren */
#abschluss-panel #abschluss-card-frame{
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;   /* horizontal mittig */
  justify-content: flex-start !important;
}
#abschluss-panel #abschluss-card{
  margin-top: 12px !important;      /* kleiner Abstand unter den Buttons */
}
#abschluss-panel #gate-undercard{
  align-self: center !important;     /* weißes „Papier“ mitnehmen */
}
</style><style id="use_users_lineal_css">
/* Abschlussbereich: Nutzer-Lineal (Klon) links neben der Karte – ohne Layoutverschiebung */
#abschluss-card-frame{ position: relative !important; }
#abschluss-lineal-clone{
  position: absolute !important;
  top: 0; left: 0;
  height: 0; width: auto;
  pointer-events: none !important;
  z-index: 30 !important;
  display: none; /* nur bei 100% */
}
.zoom-100 #abschluss-lineal-clone{ display: block; }

/* Bei anderen Zoomstufen ausblenden */
.zoom-125 #abschluss-lineal-clone,
.zoom-150 #abschluss-lineal-clone,
.zoom-175 #abschluss-lineal-clone,
.zoom-200 #abschluss-lineal-clone{ display: none !important; }
</style><style id="paper_left_extend_5mm">
/* Papier links um 5mm breiter – ohne Layout-Shift */
#gate-undercard{
  position: relative !important;
  --paper-left-ext: 5mm; /* gewünschte Erweiterung */
}
#gate-undercard::before{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  left: calc(-1 * var(--paper-left-ext));
  width: var(--paper-left-ext);
  background: #fff;
  border-top-left-radius: inherit;
  border-bottom-left-radius: inherit;
  pointer-events: none;
  z-index: 0;
}
</style><style id="abschluss_ui_polish_v1">
/* 1) Button-Leiste oben einheitlich */
#abschluss-controls{
  display:flex; gap:8px; align-items:center; flex-wrap:wrap;
}
#abschluss-controls > button{
  height:40px; padding:8px 14px;
  border-radius:10px; font-weight:600;
  line-height:1.1;
  display:inline-flex; align-items:center; justify-content:center;
  white-space:nowrap;
}

/* Einheitliche Minimalbreiten, damit optisch ruhig */
#btn-abschluss-zoom-100, #btn-abschluss-zoom-150{ min-width:72px; }
#btn-abschluss-flip{ min-width:220px; }
#btn-abschluss-back{ min-width:200px; }

/* 2) Primäraktion dezent hervorheben */
#btn-abschluss-addcart{
  background: #ffffff;
  border: 2px solid #1f1f1f;
  box-shadow: 0 1px 0 rgba(0,0,0,.10);
}
#btn-abschluss-addcart:hover{ box-shadow: 0 2px 0 rgba(0,0,0,.12); }

/* 3) Papier sanft anheben (ohne Layout-Shift) */
#gate-undercard{
  box-shadow: 0 1px 2px rgba(0,0,0,.10);
}

/* 4) Lineal dezenter */
#abschluss-lineal-clone{ opacity: .68; }

/* 5) Rechte Spalte glätten */
#abschluss-options legend{
  font-weight:700;
  margin-bottom:8px;
}
#abschluss-options{ margin-bottom:10px; }
#abschluss-options input[type="radio"]{ transform: translateY(0.5px); } /* baseline */

/* 6) Abstände unter der Karte & Balken vereinheitlichen */
#abschluss-card-frame{ margin-bottom:16px; }
#abschluss-sidebar button{
  margin:8px 0;
}

/* Cart-Zeilen: Menge + Buttons vertikal mittig ausrichten */
#abschluss-sidebar li input[type="number"],
#abschluss-sidebar li button{
  vertical-align: middle;
}

/* Optionale gemeinsame Höhe für kleine Buttons, damit Base-Line identisch wirkt */
#abschluss-sidebar li input[type="number"]{
  height: 26px;
  line-height: 26px;
}
#abschluss-sidebar li button{
  height: 26px;
  line-height: 26px;
  padding: 0 8px;
}

/* Menge + Aktionsbuttons in eine durchgehende Zeile zentrieren */
#abschluss-trigger-row{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
#abschluss-qtywrap{ display:inline-flex; align-items:center; gap:8px; }
#abschluss-qty{ height:40px; line-height:40px; padding:0 8px; box-sizing:border-box; }
#abschluss-actions{ display:inline-flex; align-items:center; gap:12px; }
#abschluss-actions > button{ height:40px; display:inline-flex; align-items:center; }

/* Cart-Zeile: alles sauber auf eine Mitte bringen – minimal-invasiv */
#abschluss-sidebar li{
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

/* Einheitliche Mikro-Höhe in der Zeile (Buttons + Zahlfeld) */
#abschluss-sidebar li input[type="number"],
#abschluss-sidebar li button{
  height: 26px;
  line-height: 26px;
  padding-top: 0; padding-bottom: 0;
}

/* Label/Name in der Zeile optisch auf dieselbe Linie ziehen */
#abschluss-sidebar li > span,
#abschluss-sidebar li > strong{
  line-height: 26px;
}

/* Feinausrichtung: Zahlenfeld in den Cart-Zeilen 2px nach unten schieben,
   weil Browser-Controls die optische Baseline leicht anheben */
#abschluss-sidebar li input[type="number"]{
  transform: translateY(2px);
}

/* Robust Ausrichtung der Warenkorb-Reihen: gleiche Zeilenhöhe + optischer Nudge */
#abschluss-sidebar { --cartRowH: 28px; }
#abschluss-sidebar li{
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
#abschluss-sidebar li input[type="number"]{
  height: var(--cartRowH);
  line-height: var(--cartRowH);
  padding: 0 6px;
  box-sizing: border-box;
  position: relative;
  top: 6px;                 /* optische Korrektur: leicht nach unten */
  vertical-align: middle;
}
#abschluss-sidebar li button{
  height: var(--cartRowH);
  line-height: var(--cartRowH);
  padding: 0 8px;
  vertical-align: middle;
}
#abschluss-sidebar li > span,
#abschluss-sidebar li > strong{
  line-height: var(--cartRowH);
}

/* Summe-Zeile: Label auf die Höhe des Betrags ziehen */

</style><style id="sticker_inset_css">
/* --- Sticker-Inset ohne SVG-/Koordinatenänderung ------------------------- */
/* gemeinsame Regeln: Slot-Inhalt innerhalb des Rahmens halten */
#karte_vorderseite_overlay [data-field],
#karte_rueckseite_overlay  [data-field]{
  box-sizing: border-box;
  overflow: hidden;
}

/* Vorderseite: Felder 2–5 jeweils 0,5 mm Abstand zur Slot-Kontur */
#karte_vorderseite_overlay [data-field="2"],
#karte_vorderseite_overlay [data-field="3"],
#karte_vorderseite_overlay [data-field="4"],
#karte_vorderseite_overlay [data-field="5"]{
  padding: 0.5mm;
}

/* Rückseite: Felder 8–16 jeweils 0,4 mm Abstand zur Slot-Kontur */
#karte_rueckseite_overlay [data-field="8"],
#karte_rueckseite_overlay [data-field="9"],
#karte_rueckseite_overlay [data-field="10"],
#karte_rueckseite_overlay [data-field="11"],
#karte_rueckseite_overlay [data-field="12"],
#karte_rueckseite_overlay [data-field="13"],
#karte_rueckseite_overlay [data-field="14"],
#karte_rueckseite_overlay [data-field="15"],
#karte_rueckseite_overlay [data-field="16"]{
  padding: 0.4mm;
}

/* --- präziser Inset: wirkt auf das *erste Kind* im Slot (Sticker) ---------- */
#karte_vorderseite_overlay [data-field],
#karte_rueckseite_overlay  [data-field]{
  position: relative;
}

/* Vorderseite Felder 2–5: 0.5mm ringsum */
#karte_vorderseite_overlay [data-field="2"] > *:first-child,
#karte_vorderseite_overlay [data-field="3"] > *:first-child,
#karte_vorderseite_overlay [data-field="4"] > *:first-child,
#karte_vorderseite_overlay [data-field="5"] > *:first-child{
  position: absolute;
  inset: 0.5mm;           /* top/right/bottom/left */
  width: auto; height: auto;
  object-fit: contain;
}

/* Rückseite Felder 8–16: 0.4mm ringsum */
#karte_rueckseite_overlay [data-field="8"]  > *:first-child,
#karte_rueckseite_overlay [data-field="9"]  > *:first-child,
#karte_rueckseite_overlay [data-field="10"] > *:first-child,
#karte_rueckseite_overlay [data-field="11"] > *:first-child,
#karte_rueckseite_overlay [data-field="12"] > *:first-child,
#karte_rueckseite_overlay [data-field="13"] > *:first-child,
#karte_rueckseite_overlay [data-field="14"] > *:first-child,
#karte_rueckseite_overlay [data-field="15"] > *:first-child,
#karte_rueckseite_overlay [data-field="16"] > *:first-child{
  position: absolute;
  inset: 0.4mm;
  width: auto; height: auto;
  object-fit: contain;
}
</style><style id="abschluss_buttons_tight_primary">
/* Buttons im Abschlussbereich: niedriger & einheitlich */
#abschluss-panel button{
  height: 34px;
  padding: 6px 12px;
  border-radius: 8px;
  font-weight: 600;
  line-height: 1;
}

/* Primärstil für "Bestellung aufgeben" */
#abschluss-panel .btn-primary{
  background: #2f5132 !important;
  color: #fff !important;
  border: 1px solid #2f5132 !important;
}
#abschluss-panel .btn-primary:hover{
  filter: brightness(0.95);
}
</style>
<style id="abschluss-paper-bg-match-spalten">
/* Einzelschritt: 'Ausführung (pro Karte)' – Hintergrund identisch zu Spalte 1/2 */
.absschluss-paper{ /* guard against typos */ }
.absschluss_paper{ /* guard */ }
.absschlusspaper{ /* guard */ }
/* Zielklasse (korrekt): */
.abschluss-paper{
  background-color: #8DD35F !important; /* exakt wie #spalte-links / #spalte-rechts */
}
</style>
<style id="order-floater-css">
/* Einzelschritt: Bestellung unter Karte auf Höhe Import/Export – ohne deren DOM zu ändern */
#abschluss-grid{ position: relative; } /* lokaler Bezug für absolute Positionierung */
#order-floater{
  position: absolute; z-index: 5;
  display: flex; justify-content: center; align-items: center;
  pointer-events: none; /* Container blockt nichts */
}
#order-floater > .holder{ pointer-events: auto; } /* Button bleibt klickbar */
</style>
<style id="side-actions-css">
/* Einzelschritt: Warenkorb/Nächste rechts neben dem grünen Panel untereinander */
.abf-wrap-flex{ display:flex; align-items:flex-start; gap:12px; flex-wrap:nowrap; }
.abf-side-actions{ display:flex; flex-direction:column; gap:8px; min-width:220px; max-width:260px; }
.abf-side-actions > button, .abf-side-actions > [role="button"]{ width:100%; }
</style>
<style id="triple-align-css">
/* Einzelschritt: Oberkanten angleichen (Karte, grünes Panel, 'In den Warenkorb') */
.abf-side-actions{ margin-top: 0; } /* Basis, Feinschliff per JS */
</style>
<style id="uniform-button-typography">
/* Einheitliche Button-Typografie (Editor, Steuerleiste, Abschlussbereich) */
button,
[role="button"],
input[type="button"],
input[type="submit"]{
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif !important;
  font-weight: 600 !important;                      /* überall gleich stark */
  font-variant-numeric: lining-nums tabular-nums;   /* stabilere, gleich breite Ziffern */
  font-feature-settings: "lnum","tnum";
  -webkit-font-feature-settings: "lnum","tnum";
  -moz-font-feature-settings: "lnum","tnum";
}
</style>
<style id="cta-and-yellow-border-fix">
/* 1) Gelbe Buttons: gleiche dunkle 0,5mm-Kontur wie übrige Buttons */
:root{ --btn-border-color: #1a1a1a; }
.btn-yellow{
  border-color: var(--btn-border-color) !important;
}

/* 2) Primär-CTA ("Bestellung aufgeben") etwas stärker gewichten */
.btn-primary-green{
  font-weight: 700 !important;         /* etwas kräftiger als 600 */
  padding: 10px 16px !important;       /* leicht mehr vertikale Präsenz */
  letter-spacing: 0.2px;               /* minimal besser lesbar */
  /* Hintergrund/Farbe bleiben wie zuvor gesetzt */
}
</style>
<style id="btn-yellow-unified">
:root{
  --brand-accent: #E6C768;   /* Gelb wie deine Boxen */
  --btn-fg: #111111;
}
/* Gelber Stil – auch im disabled-Zustand sichtbar gelb */
.btn-yellow,
.btn-yellow:disabled,
.btn-yellow[disabled]{
  background-color: var(--brand-accent) !important;
  color: var(--btn-fg) !important;
  border-color: var(--btn-border-color, #1a1a1a) !important; /* dunkler Rahmen wie alle */
  opacity: 1 !important;
}
.btn-yellow:hover{ filter: brightness(0.96); }
.btn-yellow:active{ filter: brightness(0.93); }
.btn-yellow:disabled,
.btn-yellow[disabled]{ cursor: not-allowed; filter: brightness(0.97); }
</style>
<style id="btn-yellow-unified">
:root{
  --brand-accent: #E6C768;   /* Gelb wie deine Boxen */
  --btn-fg: #111111;
}
/* Gelber Stil – auch im disabled-Zustand sichtbar gelb */
.btn-yellow,
.btn-yellow:disabled,
.btn-yellow[disabled]{
  background-color: var(--brand-accent) !important;
  color: var(--btn-fg) !important;
  border-color: var(--btn-border-color, #1a1a1a) !important; /* dunkler Rahmen wie alle */
  opacity: 1 !important;
}
.btn-yellow:hover{ filter: brightness(0.96); }
.btn-yellow:active{ filter: brightness(0.93); }
.btn-yellow:disabled,
.btn-yellow[disabled]{ cursor: not-allowed; filter: brightness(0.97); }
</style>
<style id="cta-floater-unified-css">
#abschluss-grid{ position: relative; }      /* lokaler Bezug */
#order-floater{
  position: absolute; z-index: 5;
  display: flex; justify-content: center; align-items: center;
  pointer-events: none;                    /* blockt nichts */
}
#order-floater > .holder{ pointer-events: auto; } /* CTA klickbar */
</style>
<style id="button-border-05mm-baseline">
/* Regression-Fix: Einheitliche 0,5mm-Kontur für alle echten Buttons */
:root{ --btn-border-color: #1a1a1a; }
button,
[role="button"],
input[type="button"],
input[type="submit"]{
  border-width: 0.5mm !important;
  border-style: solid !important;
  border-color: var(--btn-border-color) !important;
  box-sizing: border-box;
}
</style>
<style id="status-yellow-by-id-safe">
:root{ --brand-accent: #E6C768; }
/* Nur Textfarbe, keine Box-Modell- oder Layout-Eigenschaften */
#abschluss-cart-msg{ color: var(--brand-accent) !important; }
</style>
<style id="status-yellow-by-id-safe-outline">
/* Mikro-Outline zur besseren Lesbarkeit ohne Layout-Einfluss */
#abschluss-cart-msg{
  text-shadow: 0 0 0.8px rgba(0,0,0,0.45);
}
</style>
<style id="scrollbar-thin-global">
/* Einzelschritt: Schmale Scrollleisten (layout-neutral) */
/* Firefox */
html { scrollbar-width: thin; }
/* Chromium/WebKit */
html::-webkit-scrollbar { width: 8px; height: 8px; }
</style>
<style id="abschluss-actions-right-padding">
/* Nur Innenabstand rechts im Abschlussbereich – kein Einfluss auf Pfeil-/Scrollbar-Positionen */
#abschluss-actions,
#abschluss-cart-list {
  padding-right: 8px;
  box-sizing: border-box;
}
</style>
<style id="abschluss-sidebar-right-padding">
/* Nur die rechte Sidebar bekommt etwas Innenabstand rechts.
   Kein Einfluss auf Pfeil-/Scrollbar-Positionen (box-sizing: border-box). */
#abschluss-sidebar {
  padding-right: 10px;
  box-sizing: border-box;
}
</style>
<style id="einzelschritt-feld6-7-invalid-yellow-fix">
/* Fix: verhindert rosa "invalid"-Hintergrund bei Spruch/Smiley */
#front-controls #spruchSelect:invalid,
#front-controls #spruchSelect:required:invalid,
#front-controls #smileySelect:invalid,
#front-controls #smileySelect:required:invalid{
  background: #FFF7CC !important;
  box-shadow: none !important;
}
</style>
<!-- Einzelschritt-Hotfix: Freitext im Dropdown auf Rahmenbreite ausrichten (ohne Elemente zu löschen) -->
<style id="freitext-align-hotfix">
  /* Breite der rosa Dropdown-Box selbst belassen; nur Inhalte vollflächig ausrichten */
  .rb-dd, .rb-dd * { box-sizing: border-box; }

  /* Freitext-Eingabefeld: volle Rahmenbreite, kein 151.5px-Zwang */
  .rb-dd-free {
    width: 100% !important;
    min-width: 0 !important;
    max-width: 100% !important;
    display: block;
    padding: 6px 8px;
    line-height: 16px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Drag-Einträge ebenfalls rahmenbreit */
  .rb-dd-item {
    width: 100% !important;
    max-width: 100% !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
  }

  /* Footer mit Hinweis sicher sichtbar */
  .rb-dd-foot { display: block !important; }

  /* Kein Verschieben bei Fokus/Hover */
  .rb-dd-free:focus, .rb-dd-free:focus-within {
    outline: none;
    box-shadow: none;
  }
</style>
<style data-origin="ppk" id="anti-flicker">#simBar,#shopSimBar,.sim-only{display:none!important;visibility:hidden!important}</style>
<style id="order-modal-style">
.order-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.35);display:none;align-items:center;justify-content:center;z-index:2147483000}
.order-modal{background:#fff;width:90%;max-width:460px;border-radius:12px;box-shadow:0 10px 40px rgba(0,0,0,.25);padding:16px 18px;font-family:inherit}
.order-modal h3{margin:0 0 8px 0;font-size:18px}
.order-modal p{margin:0 0 10px 0;font-size:14px}
.order-modal form{display:flex;gap:8px}
.order-modal input{flex:1;padding:10px 12px;border:1px solid #bbb;border-radius:8px;font-size:14px}
.order-modal button{padding:10px 14px;border:0;border-radius:8px;cursor:pointer}
.order-modal .primary{background:#1a73e8;color:#fff}
.order-modal .secondary{background:#eee}
.order-modal .error{color:#b00020;font-size:12px;margin-top:8px;display:none}
</style>
<style id="ppk-safe-reset">
/* PPK SAFE RESET (scoped) */
html, body {
  transform: none !important;
  zoom: 1 !important;
}
/* common app roots in this project */
#app, .app, .root, .page-root, .wrapper {
  transform: none !important;
  zoom: 1 !important;
}
/* Prevent accidental text rendering of JS comments at top by hiding stray top-level text nodes spacing */
body::before {
  content: "" !important;
}
</style>
<style id="ppk-back-green-theme">
.ppk-back-green {
  background: #0b6845 !important;   /* dark green */
  border: 2px solid #095c3a !important;
  color: #fff !important;
  font-weight: 700 !important;
  border-radius: 12px !important;
  padding: 10px 18px !important;
  min-width: 180px !important;
  height: 44px !important;
  text-align: center !important;
  white-space: nowrap !important;
  box-shadow: 0 1px 0 rgba(0,0,0,.05), inset 0 -2px 0 rgba(0,0,0,.08) !important;
  transition: transform .05s ease, filter .12s ease !important;
}
.ppk-back-green:hover { transform: translateY(-1px); filter: brightness(1.05); }
.ppk-back-green:active { transform: translateY(0); filter: brightness(.96); }
</style>
<script>
(function(){
  function isBack(el){
    if (!el) return false;
    var t = (el.textContent||'').trim().toLowerCase();
    if (t.indexOf('zurück zum shop') !== -1 || (t.indexOf('zurück')!==-1 && t.indexOf('shop')!==-1)) return true;
    if (el.matches && el.matches('#btn-back-shop, .btn-back-shop, .zurueck-shop, .zurück-shop')) return true;
    return false;
  }
  function applyTheme(){
    var nodes = Array.from(document.querySelectorAll('button, a, .btn, [role="button"]'));
    nodes.forEach(function(n){
      if (isBack(n)) n.classList.add('ppk-back-green');
    });
    // Also style the notice button if present
    var nb = document.querySelector('#ppk-testlimit-notice button');
    if (nb) nb.classList.add('ppk-back-green');
  }
  document.addEventListener('DOMContentLoaded', applyTheme);
  document.addEventListener('ppk:ui:ready', applyTheme);
  // In case the banner is injected later:
  setTimeout(applyTheme, 200);
  setTimeout(applyTheme, 600);
})();
</script>
<style id="ppk-back-green-theme">
.ppk-back-green {
  background: #0b6845 !important;
  border: 2px solid #095c3a !important;
  color: #fff !important;
  font-weight: 700 !important;
  border-radius: 12px !important;
  padding: 10px 18px !important;
  min-width: 180px !important;
  height: 44px !important;
  text-align: center !important;
  white-space: nowrap !important;
  box-shadow: 0 1px 0 rgba(0,0,0,.05), inset 0 -2px 0 rgba(0,0,0,.08) !important;
  transition: transform .05s ease, filter .12s ease !important;
}
.ppk-back-green:hover { transform: translateY(-1px); filter: brightness(1.05); }
.ppk-back-green:active { transform: translateY(0); filter: brightness(.96); }
</style>
<script>
(function(){
  function isBackEl(el){
    if (!el) return false;
    // class/id based
    if (el.matches && el.matches('#btn-back-shop, .btn-back-shop, .zurueck-shop, .zurück-shop')) return true;
    // text based
    var t = (el.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
    return t.indexOf('zurück zum shop') !== -1 || (t.indexOf('zurück')!==-1 && t.indexOf('shop')!==-1);
  }
  function closestClickable(n){
    return n.closest ? n.closest('button, a, [role="button"]') : n;
  }
  function applyThemeOnce(root){
    var nodes = Array.from((root||document).querySelectorAll('button, a, [role="button"], .buyer-banner *, #ppk-testlimit-notice *'));
    nodes.forEach(function(n){
      var el = closestClickable(n);
      if (el && isBackEl(el)) el.classList.add('ppk-back-green');
    });
  }
  function applyThemeRepeated(){
    var tries = 0;
    var iv = setInterval(function(){
      applyThemeOnce();
      tries++;
      if (tries>15) clearInterval(iv); // ~3s
    }, 200);
  }
  function observeMutations(){
    var mo = new MutationObserver(function(muts){
      muts.forEach(function(m){
        if (m.addedNodes && m.addedNodes.length){
          m.addedNodes.forEach(function(node){
            if (node.nodeType===1) applyThemeOnce(node);
          });
        }
      });
    });
    mo.observe(document.body, {childList:true, subtree:true});
  }
  document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

    applyThemeOnce();
    applyThemeRepeated();
    observeMutations();
  });
  // also react to custom UI ready events if present
  document.addEventListener('ppk:ui:ready', function(){ applyThemeOnce(); });
  document.addEventListener('ppk:cart:updated', function(){ applyThemeOnce(); });
})();
</script>
<style id="ppk-back-green-theme">
.ppk-back-green {
  background: #0b6845 !important;
  border: 2px solid #095c3a !important;
  color: #fff !important;
  font-weight: 700 !important;
  border-radius: 12px !important;
  padding: 10px 18px !important;
  min-width: 180px !important;
  height: 44px !important;
  text-align: center !important;
  white-space: nowrap !important;
  box-shadow: 0 1px 0 rgba(0,0,0,.05), inset 0 -2px 0 rgba(0,0,0,.08) !important;
  transition: transform .05s ease, filter .12s ease !important;
}
.ppk-back-green:hover { transform: translateY(-1px); filter: brightness(1.05); }
.ppk-back-green:active { transform: translateY(0); filter: brightness(.96); }
</style>
<script>
(function(){
  function isBackEl(el){
    if (!el) return false;
    if (el.matches && el.matches('#btn-back-shop, .btn-back-shop, .zurueck-shop, .zurück-shop')) return true;
    var t = (el.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
    return t.indexOf('zurück zum shop') !== -1 || (t.indexOf('zurück')!==-1 && t.indexOf('shop')!==-1);
  }
  function applyThemeOnce(root){
    var nodes = Array.from((root||document).querySelectorAll('button, a, [role="button"], .buyer-banner *, #ppk-testlimit-notice *'));
    nodes.forEach(function(n){
      var el = n.closest ? n.closest('button, a, [role="button"]') : n;
      if (el && isBackEl(el)) el.classList.add('ppk-back-green');
    });
  }
  document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

    applyThemeOnce();
    // retry a few times in case banner mounts later
    var tries=0, iv=setInterval(function(){ applyThemeOnce(); if(++tries>15) clearInterval(iv); },200);
    // and observe DOM changes
    var mo=new MutationObserver(function(muts){ muts.forEach(function(m){ m.addedNodes&&m.addedNodes.forEach(function(nd){ if(nd.nodeType===1) applyThemeOnce(nd); }); }); });
    mo.observe(document.body,{childList:true,subtree:true});
  });
})();
</script>
<style id="ppk-buyer-hide-prices-v1">
/* Preise nur im Käufermodus ausblenden */
html.mode-buyer .col-price-eur,
html.mode-buyer 
</style>
<script id="ppk-mode-bootstrap">
(function(){
  try{
    var params = new URLSearchParams(location.search);
    var mode = (params.get('mode')||'').toLowerCase();
    if (mode === 'buyer') document.documentElement.classList.add('mode-buyer');
  }catch(e){}
})();
</script>
<!-- Block mit #ppk-gate-banner für Wix entfernt -->
<!-- Block mit #ppk-availability-slot für Wix entfernt -->
<!-- Block mit #ppk-limit-sticky-slot für Wix entfernt -->
<!-- Block mit #ppk-availability-slot für Wix entfernt -->
<!-- Block mit 
#ppk-limit-indicator für Wix entfernt -->
<!-- Block mit id="ppk-mu-safety-guard" für Wix entfernt -->
<!-- Block mit id="ppk-disable-old-ok-css" für Wix entfernt -->
<style id="ppk-hide-grey-ok">
  /* Grauen/disabled OK im Hinweis ausblenden, ohne andere Buttons zu berühren */
  #rb-confirm-overlay .rbc-actions [disabled],
  #rb-confirm-overlay .rbc-actions [aria-disabled="true"] {
    display: none !important;
  }
</style>
<style id="nohit-observer-css">
#nohit-toast{ position: relative; }
#nohit-actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
</style>
<style id="ps-icons-theme-unified">
:root{
  --ppk-ico-size: 22px;   /* Einheitliche Größe */
  --ppk-ico-br: 6px;      /* Gleicher Radius */
  --ppk-ico-bw: 2px;      /* Gleiche Rahmenstärke */
  --ppk-ico-shadow: 0 1px 0 rgba(0,0,0,.05);
  --ppk-green: #2e7d32;        /* Einheitliches Grün */
  --ppk-green-bg: #f6fff6;     /* Helles Grün für Hintergrund */
  --ppk-red: #a8071a;          /* Einheitliches Rot */
  --ppk-red-bg: #fff6f6;       /* Helles Rot für Hintergrund */
  --ppk-white: #fff;
  --ppk-fg-dark: #111;
}

/* Suchfeld: Platz für zwei Kapseln rechts */
.steuerleiste .ac-wrap{ position: relative; }
#pflanzensuche{ padding-right: 56px !important; }

/* Basiskapsel */
.ps-kapsel,
.ps-checkwrap, .ps-clearwrap,
#nohit-accept, #nohit-accept-inline{
  width: var(--ppk-ico-size);
  height: var(--ppk-ico-size);
  border-radius: var(--ppk-ico-br);
  border: var(--ppk-ico-bw) solid transparent; /* wird pro Variante gesetzt */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: 900;
  font-size: 14px;
  line-height: 1;
  box-shadow: var(--ppk-ico-shadow);
  padding: 0;
  margin: 0;
}

/* Position im Suchfeld */
.ps-checkwrap, .ps-clearwrap{
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  z-index: 5;
}
.ps-checkwrap{ right: 34px; }
.ps-clearwrap{ right: 8px;  cursor: pointer; }

.ps-check, .ps-clear{ pointer-events: none; }

/* Farbvarianten – EINHEITLICH */
.ps-checkwrap,
#nohit-accept, #nohit-accept-inline{
  border-color: var(--ppk-green);
  background: var(--ppk-green-bg);
  color: var(--ppk-green);
  text-shadow: 0 1px 0 var(--ppk-white);
}
.ps-clearwrap{
  border-color: var(--ppk-red);
  background: var(--ppk-red-bg);
  color: var(--ppk-red);
}

/* Nur Glyph im Hinweis-Button */
#nohit-accept::before, #nohit-accept-inline::before{ content: '✓'; }
</style>
<style id="ps2-hint-close-capsule">
:root{
  --ppk-ico-size: 22px;
  --ppk-ico-br: 6px;
  --ppk-ico-bw: 2px;
  --ppk-ico-shadow: 0 1px 0 rgba(0,0,0,.05);
  --ppk-red: #a8071a;
  --ppk-red-bg: #fff6f6;
}
/* Hint header close: show a red capsule with '✕', no stray text like '.' */
.ps2-hint header .ps2-x{
  width: var(--ppk-ico-size);
  height: var(--ppk-ico-size);
  border-radius: var(--ppk-ico-br);
  border: var(--ppk-ico-bw) solid var(--ppk-red);
  background: var(--ppk-red-bg);
  color: var(--ppk-red);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-shadow: var(--ppk-ico-shadow);
  padding: 0;
  margin: 0;
  font-size: 0;   /* verhindert sichtbares '.' oder sonstige Textknoten */
  line-height: 1;
}
.ps2-hint header .ps2-x::before{
  content: '✕';
  font-weight: 900;
  font-size: 14px;
  line-height: 1;
}
</style>
<style id="ps2-hint-close-capsule-strong">
:root{
  --ppk-ico-size: 22px;
  --ppk-ico-br: 6px;
  --ppk-ico-bw: 2px;
  --ppk-ico-shadow: 0 1px 0 rgba(0,0,0,.05);
  --ppk-red: #a8071a;
  --ppk-red-bg: #fff6f6;
}
/* Header-Schließen im Hinweis exakt wie rote Kapsel */
.ps2-hint header .ps2-x{
  box-sizing: border-box !important;
  width: var(--ppk-ico-size) !important;
  height: var(--ppk-ico-size) !important;
  border-radius: var(--ppk-ico-br) !important;
  border: var(--ppk-ico-bw) solid var(--ppk-red) !important;
  background: var(--ppk-red-bg) !important;
  color: var(--ppk-red) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 0 !important;
  margin: 0 !important;
  box-shadow: var(--ppk-ico-shadow) !important;
  font-size: 0 !important;  /* verhindert Punkte/Text */
  line-height: 1 !important;
}
.ps2-hint header .ps2-x::before{
  content: '✕';
  font-weight: 900;
  font-size: 14px;
  line-height: 1;
}
</style>
<style id="nohit-actions-capsule">
:root{
  --ppk-ico-size: 22px;
  --ppk-ico-br: 6px;
  --ppk-ico-bw: 2px;
  --ppk-ico-shadow: 0 1px 0 rgba(0,0,0,.05);
  --ppk-green: #2e7d32;
  --ppk-green-bg: #f6fff6;
}
/* Der Button im Hinweis unten (#nohit-actions) bekommt exakt die grüne Kapsel-Optik */
#nohit-actions button{
  box-sizing: border-box !important;
  width: var(--ppk-ico-size) !important;
  height: var(--ppk-ico-size) !important;
  border-radius: var(--ppk-ico-br) !important;
  border: var(--ppk-ico-bw) solid var(--ppk-green) !important;
  background: var(--ppk-green-bg) !important;
  color: var(--ppk-green) !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 0 !important;
  margin: 0 !important;
  box-shadow: var(--ppk-ico-shadow) !important;
  font-size: 0 !important;  /* nur Glyph per ::before */
  line-height: 1 !important;
}
#nohit-actions button::before{
  content: '✓';
  font-weight: 900;
  font-size: 14px;
  line-height: 1;
}
</style>
<style id="ps-clearwrap-red-outline">
:root{
  --ppk-red: #a8071a;
  --ppk-red-bg: #fff6f6;
}
/* Force red outline + red glyph for the ✕ capsule in the search field */
.ps-clearwrap{
  border: 2px solid var(--ppk-red) !important;
  background: var(--ppk-red-bg) !important;
  color: var(--ppk-red) !important;
}
</style>
<style id="nohit-actions-topright">
/* Haken im DB-Hinweis oben rechts platzieren – ohne Breitenänderung */
#nohit-toast{ position: relative; }
#nohit-actions{
  position: absolute;
  top: 8px;
  right: 8px;
  display: inline-flex;
  gap: 6px;
}
</style>
<style id="rb-confirm-match-visual">
:root{
  --ppk-red:#a8071a; --ppk-red-bg:#fff6f6; --ppk-text:#111;
  --ppk-radius:10px; --ppk-shadow:0 2px 6px rgba(0,0,0,.08);
  --ppk-font:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans","Liberation Sans",sans-serif;
}
/* Optik angleichen */
#rb-confirm .ps2-hint{
  background:#fff !important;
  border:2px solid var(--ppk-red) !important;
  border-radius:var(--ppk-radius) !important;
  color:var(--ppk-text) !important;
  box-shadow:var(--ppk-shadow) !important;
  font-family:var(--ppk-font) !important;
  font-size:14px !important; line-height:1.25 !important;
}
#rb-confirm .ps2-hint header{
  display:flex !important; align-items:center !important; justify-content:space-between !important;
  margin:0 0 6px 0 !important;
}
#rb-confirm .ps2-title{ font-weight:700 !important; color:var(--ppk-red) !important; font-size:14px !important; }
#rb-confirm header .ps2-x{
  box-sizing:border-box !important; width:22px !important; height:22px !important;
  border-radius:6px !important; border:2px solid var(--ppk-red) !important;
  background:var(--ppk-red-bg) !important; color:var(--ppk-red) !important;
  display:inline-flex !important; align-items:center !important; justify-content:center !important;
  box-shadow:0 1px 0 rgba(0,0,0,.05) !important; padding:0 !important; margin:0 !important;
  font-size:0 !important; line-height:1 !important;
}
#rb-confirm header .ps2-x::before{ content:"✕"; font-weight:900; font-size:14px; line-height:1; }
</style>
<!-- UNIFY-FACADE STEP B: Doppelte Steuerleisten-Hinweise vermeiden (Original hart verstecken, Twin spiegelt Sichtbarkeit) -->
<!-- STEP C: Pflanzenwechsel-Hinweis (.ps2-hint) als einheitliche Fassade wie die 3 Toolbar-Hinweise -->
<!-- FINAL: Originalen Kreuz-Button im Dialog vollständig verstecken und NEUEN einsetzen -->
<!-- FINAL-HARD: Entferne ALLE alten Close-Buttons im Dialog-Hinweis und setze EINEN neuen -->
<!-- OBSERVER-LOCK: Entfernt jeden alten .ps2-x sofort & setzt sauberen Button -->
<style id="rbk-backhint-fs12-r8-innerOFF">
/* ÄUSSERE Box – 12px Schrift, 1mm Rahmen, Radius 8px (wie Toolbar-Buttons) */
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  background:#fff !important;
  color:#1f1f1f !important;
  font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif !important;
  font-size:12px !important;
  line-height:1.35 !important;
  box-sizing:border-box !important;
  border:1mm solid #800020 !important;
  border-radius:8px !important;
  padding:12px 14px !important;
}

/* Close-Icon (Kreuz) */
#karte-rueckseite #hint-layer .slot-hint .slot-hint-close,
#karte-rueckseite #hint-layer .slot-hint [data-role="close"],
#karte-rueckseite #hint-layer .slot-hint .close,
#karte-rueckseite #hint-layer .slot-hint-alt .slot-hint-close,
#karte-rueckseite #hint-layer .slot-hint-alt [data-role="close"],
#karte-rueckseite #hint-layer .slot-hint-alt .close{
  color:#800020 !important;
  font-weight:700 !important;
  opacity:1 !important;
}

/* INNEREN Rahmen/Schmuck kompromisslos ausschalten – inkl. ::before/::after */
#karte-rueckseite #hint-layer .slot-hint *, 
#karte-rueckseite #hint-layer .slot-hint-alt *{
  border:none !important;
  outline:none !important;
  box-shadow:none !important;
}

#karte-rueckseite #hint-layer .slot-hint *::before,
#karte-rueckseite #hint-layer .slot-hint *::after,
#karte-rueckseite #hint-layer .slot-hint-alt *::before,
#karte-rueckseite #hint-layer .slot-hint-alt *::after{
  content:unset !important;
  border:none !important;
  outline:none !important;
  box-shadow:none !important;
  background:transparent !important;
}

/* Typische Wrapper ohne Innenabstände lassen */
#karte-rueckseite #hint-layer .slot-hint > .slot-hint-inner,
#karte-rueckseite #hint-layer .slot-hint > .slot-hint-body,
#karte-rueckseite #hint-layer .slot-hint > .slot-hint-content,
#karte-rueckseite #hint-layer .slot-hint-alt > .slot-hint-inner,
#karte-rueckseite #hint-layer .slot-hint-alt > .slot-hint-body,
#karte-rueckseite #hint-layer .slot-hint-alt > .slot-hint-content{
  padding:0 !important;
  background:transparent !important;
  border-radius:0 !important;
}
</style>
<style id="rbk-backhint-radius8-final">
/* Rückseiten-Hinweis – final (Radius 8px wie Steuerleisten-Buttons) */
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  background:#fff !important;
  color:#1f1f1f !important;
  font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif !important;
  font-size:12px !important;
  line-height:1.35 !important;
  box-sizing:border-box !important;

  border:1mm solid #800020 !important;
  border-radius:8px !important;         /* <= Vorgabe */
  padding:12px 14px !important;
}

/* Close-Icon (Kreuz) */
#karte-rueckseite #hint-layer .slot-hint .slot-hint-close,
#karte-rueckseite #hint-layer .slot-hint [data-role="close"],
#karte-rueckseite #hint-layer .slot-hint .close,
#karte-rueckseite #hint-layer .slot-hint-alt .slot-hint-close,
#karte-rueckseite #hint-layer .slot-hint-alt [data-role="close"],
#karte-rueckseite #hint-layer .slot-hint-alt .close{
  color:#800020 !important;
  font-weight:700 !important;
  opacity:1 !important;
}

/* Innere Rahmen/Outlines/Schlagschatten konsequent aus */
#karte-rueckseite #hint-layer .slot-hint *,
#karte-rueckseite #hint-layer .slot-hint-alt *{
  border:none !important;
  outline:none !important;
  box-shadow:none !important;
}
#karte-rueckseite #hint-layer .slot-hint *::before,
#karte-rueckseite #hint-layer .slot-hint *::after,
#karte-rueckseite #hint-layer .slot-hint-alt *::before,
#karte-rueckseite #hint-layer .slot-hint-alt *::after{
  content:unset !important;
  border:none !important;
  outline:none !important;
  box-shadow:none !important;
  background:transparent !important;
}
</style>
<style id="rbk-backhint-cover-plus1mm">
/* Ziel: 1mm mehr Abdeckung ohne die sichtbare Umrandung zu verschieben */
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  position: relative !important;
  isolation: isolate !important; /* eigener Stacking-Kontext für ::before */
}

/* Unsichtbare Überdeckung links/rechts je +0.5mm */
#karte-rueckseite #hint-layer .slot-hint::before,
#karte-rueckseite #hint-layer .slot-hint-alt::before{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  left: -0.5mm; right: -0.5mm;     /* => gesamt +1mm Breite */
  background: #fff;                /* deckt Felder ab */
  z-index: -1;                     /* liegt hinter dem Inhalt, aber vor dem Untergrund */
  border-radius: inherit;          /* gleiche Rundung wie die Box */
}
</style>
<style id="rbk-backhint-shift-right-0_5mm">
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  transform: translateX(0.5mm) !important; /* gesamte Box 0.5mm nach rechts */
}
</style>
<style id="rbk-backhint-shift-r1mm-up0_5mm">
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  transform: translate(1mm, -0.5mm) !important; /* gesamt: +1.0mm rechts, -0.5mm hoch */
}
</style>
<style id="rbk-backhint-shift-r0mm-up0_5mm">
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  transform: translate(0mm, -0.5mm) !important; /* zurück um 1mm rechts, -0.5mm oben bleibt */
}
</style>
<style id="rbk-backhint-cover-right0_5mm-and-close">
/* Nur rechts +0.5mm Überdeckung, links 0 */
#karte-rueckseite #hint-layer .slot-hint,
#karte-rueckseite #hint-layer .slot-hint-alt{
  position: relative !important;
  isolation: isolate !important;
}

/* Deckfläche: nur rechts erweitern */
#karte-rueckseite #hint-layer .slot-hint::before,
#karte-rueckseite #hint-layer .slot-hint-alt::before{
  content: "";
  position: absolute;
  top: 0; bottom: 0;
  left: 0; right: -0.5mm;   /* => +0.5mm nur nach rechts */
  background: #fff;
  z-index: -1;
  border-radius: inherit;
}

/* Close wie in Pflanzensuche: kleines, abgerundetes Icon mit dünnem Rand */
#karte-rueckseite #hint-layer .slot-hint .slot-hint-close,
#karte-rueckseite #hint-layer .slot-hint [data-role="close"],
#karte-rueckseite #hint-layer .slot-hint .close,
#karte-rueckseite #hint-layer .slot-hint-alt .slot-hint-close,
#karte-rueckseite #hint-layer .slot-hint-alt [data-role="close"],
#karte-rueckseite #hint-layer .slot-hint-alt .close{
  position: absolute;
  top: 6px; right: 6px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px; height: 18px;
  border: 1px solid #800020;
  border-radius: 8px;              /* wie Buttons */
  color: #800020;
  background: #fff;
  font-weight: 700;
  font-size: 12px;                 /* kompakt wie Suche */
  line-height: 1;
  text-decoration: none;
  cursor: pointer;
  padding: 0;
  box-shadow: none;
}
/* Hover-Feedback dezent */
#karte-rueckseite #hint-layer .slot-hint .slot-hint-close:hover,
#karte-rueckseite #hint-layer .slot-hint [data-role="close"]:hover,
#karte-rueckseite #hint-layer .slot-hint .close:hover,
#karte-rueckseite #hint-layer .slot-hint-alt .slot-hint-close:hover,
#karte-rueckseite #hint-layer .slot-hint-alt [data-role="close"]:hover,
#karte-rueckseite #hint-layer .slot-hint-alt .close:hover{
  background:#f8f8f8;
}
</style>
<style id="rbk-ac-portal-css">
/* Falls die Liste im Original-DOM bleibt, trotzdem passend breit */
.steuerleiste .ac-wrap{ position:relative; display:inline-block; }
.steuerleiste .ac-list{ width:100%; box-sizing:border-box; }
</style>
<script id="rbk-ac-portal-js">
(function(){
  if (window.__rbkACPortal) return; window.__rbkACPortal = true;

  const MAX_Z = 2147483647;
  let portal = null, srcWrap = null, inputEl = null, listEl = null, placeholder = null;
  let observers = [];

  function bySel(root, sel){ return (root||document).querySelector(sel); }
  function visible(el){
    if (!el) return false;
    const cs = getComputedStyle(el);
    if (cs.display === 'none' || cs.visibility === 'hidden' || cs.opacity === '0') return false;
    const r = el.getBoundingClientRect();
    return r.width > 0 && r.height > 0;
  }
  function ensurePortal(){
    if (portal) return portal;
    portal = document.createElement('div');
    portal.id = 'rbk-ac-portal';
    Object.assign(portal.style, {
      position:'absolute',
      left:'0px', top:'0px',
      width:'0px',
      zIndex: String(MAX_Z)
    });
    document.body.appendChild(portal);
    return portal;
  }
  function positionPortal(){
    if (!inputEl || !listEl || !portal) return;
    const r = inputEl.getBoundingClientRect();
    const top = r.bottom + 4 + window.scrollY;
    const left = r.left + window.scrollX;
    portal.style.left = left + 'px';
    portal.style.top = top + 'px';
    portal.style.width = r.width + 'px';
    listEl.style.width = '100%';
  }
  function mount(){
    srcWrap = bySel(document, '.steuerleiste .ac-wrap');
    if (!srcWrap) return;

    inputEl = bySel(srcWrap, 'input');
    listEl  = bySel(srcWrap, '.ac-list');
    if (!inputEl) return;

    // Wenn Liste noch nicht existiert: auf spätere Erstellung warten
    if (!listEl){
      const mo = new MutationObserver(()=>{
        const l = bySel(srcWrap, '.ac-list');
        if (l){ listEl = l; attach(); mo.disconnect(); }
      });
      mo.observe(srcWrap, { childList:true, subtree:true });
      observers.push(mo);
      return;
    }
    attach();
  }

  function attach(){
    if (!listEl) return;
    placeholder = document.createComment('ac-list-placeholder');
    const parent = listEl.parentNode;
    parent.insertBefore(placeholder, listEl);

    const host = ensurePortal();
    host.appendChild(listEl);
    Object.assign(listEl.style, {
      position:'absolute',
      left:'0', top:'0',
      width:'100%',
      maxWidth:'100%',
      minWidth:'0',
      zIndex:String(MAX_Z),
      boxSizing:'border-box'
    });
    positionPortal();

    window.addEventListener('scroll', positionPortal, { passive:true });
    window.addEventListener('resize', positionPortal);
    inputEl.addEventListener('input', positionPortal);
    inputEl.addEventListener('focus', positionPortal);

    // Beobachte Sichtbarkeit; wenn Liste geschlossen -> zurückstecken
    const mo = new MutationObserver(()=>{
      if (!visible(listEl)){
        // zurück in ursprüngliche Position
        if (placeholder && placeholder.parentNode){
          placeholder.parentNode.insertBefore(listEl, placeholder);
          placeholder.remove();
          placeholder = null;
        }
        // Clean-up
        window.removeEventListener('scroll', positionPortal);
        window.removeEventListener('resize', positionPortal);
        inputEl && inputEl.removeEventListener('input', positionPortal);
        inputEl && inputEl.removeEventListener('focus', positionPortal);
        mo.disconnect();
      } else {
        positionPortal();
      }
    });
    mo.observe(listEl, { attributes:true, attributeFilter:['style','class'], childList:true, subtree:true });
    observers.push(mo);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', mount);
  } else { mount(); }
})();
</script>
<style id="sl4-align">
/* ===== Steuerleiste 4: exakte Ausrichtung nach Vorgabe (TEMP) ============ */
.steuerleiste{
  position: relative;
  display: grid !important;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  grid-template-rows: auto auto auto;
  grid-template-areas:
    "bnr   koseIn clear  credit"
    "label koseSet all   back"
    "search nameSet match cart";
  column-gap: 18px;
  row-gap: 10px;
  align-items: center;
  padding: 10px 12px 16px;
  box-sizing: border-box;
  overflow: hidden;
}

/* WICHTIG: Wrapper-Ebenen flach machen, damit Kinder direkt ins Grid können */
.steuerleiste > .block,
.steuerleiste > .block.column,
.steuerleiste .ac-wrap{ display: contents !important; }

/* Raster sichtbar (kräftig) */
.steuerleiste::before{
  content:"";
  position:absolute; inset:0;
  background-image:
    repeating-linear-gradient(0deg, rgba(0,0,0,.18), rgba(0,0,0,.18) 2px, transparent 2px, transparent 24px),
    repeating-linear-gradient(90deg, rgba(0,0,0,.18), rgba(0,0,0,.18) 2px, transparent 2px, transparent 24px);
  pointer-events:none;
  z-index: 0;
}
.steuerleiste > *{ position: relative; z-index: 1; max-width: 100%; }
.steuerleiste button, .steuerleiste input[type="text"]{ width: 100%; max-width: 100%; }

/* Grid-Areas zuordnen – robust über IDs/Klassen und Fallbacks */
#order-inline{ grid-area: bnr; }

/* Kosename-Eingabe */
#kosenameInput{ grid-area: koseIn; min-width: 260px; }

/* Aktionen/Sticker */
#btn-leeren{ grid-area: clear; }
#btn-alle-sticker{ grid-area: all; }
#btn-passende-sticker{ grid-area: match; }

/* Shop-Bereich */
#sl4-credit{ grid-area: credit; font-weight: 700; text-align: right; }
#sl4-back-shop{ grid-area: back; }
#btn-open-cart-top{ grid-area: cart; }

/* Pflanzensuche: Label + Input */
.ps-toplabel{ grid-area: label; font-size: 1.6em; font-weight: 800; }
/* Sucheingabe – falls ID fehlt, nimm erstes Textfeld aus ac-wrap */
.steuerleiste input#pflanzensuche{ grid-area: search; }
.steuerleiste .ac-wrap input[type="text"]:first-of-type{ grid-area: search; }

/* Namen übernehmen */
#btn-uebernehmen-kosename{ grid-area: koseSet; }
#btn-uebernehmen-name{ grid-area: nameSet; }

/* Spalte 3 darf etwas mehr Breite haben, ohne Gesamtbreite zu sprengen */
@supports (grid-template-columns: subgrid){
  /* (Subgrid-Option bleibt hier ungenutzt, reserviert für später) */
}

.plant-change-note{
  font-size: 0.95rem;
  font-weight: 600;
  color: #ffffff;
  margin-top: 4px;
  text-align: center;
  display: block;
}

</style>
<style id="sl4-search-fix">
/* === FIX: Icons in Spalte 1, unterste Zeile, INS Suchfeld ================= */
/* 1) .ac-wrap wieder als eigener Kasten (zuvor display: contents überschrieben) */
.steuerleiste .ac-wrap{
  display: block !important;
  position: relative !important;
  grid-area: search !important;   /* gesamte Zelle gehört dem Wrapper */
}

/* 2) Suchfeld: Platz für ✓ und ✕ reservieren, kein Wortumbruch */
.steuerleiste .ac-wrap input[type="text"]#pflanzensuche{
  padding-right: 72px !important;
  box-sizing: border-box;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 3) Vorhandene eckige Kapseln absolut rechts im Feld positionieren */
.steuerleiste .ac-wrap .ps-checkwrap,
.steuerleiste .ac-wrap .ps-clearwrap{
  position: absolute !important;
  top: 50% !important;
  transform: translateY(-50%) !important;
  z-index: 5 !important;
}
/* Reihenfolge: ✓ dann ✕ */
.steuerleiste .ac-wrap .ps-checkwrap{ right: 42px !important; }
.steuerleiste .ac-wrap .ps-clearwrap{ right: 10px !important; }

/* Sicherheitsnetz gegen alte Regeln */
.steuerleiste .ps-checkwrap, .steuerleiste .ps-clearwrap{ max-width: 28px; }
</style>
<style id="sl4-stable-icons">
/* === STABIL: ✓ / ✕ fest im Suchfeld verankern ============================ */
/* 1) Eine kleine Box direkt um das INPUT: relative; steuert Icon-Position */
.steuerleiste .sl4-inputbox{
  position: relative !important;
  display: inline-block !important;
  width: 100% !important;
}

/* 2) INPUT bekommt rechts Platz, kein seltsamer Umbruch, Text bleibt sichtbar */
.steuerleiste .sl4-inputbox > input#pflanzensuche{
  width: 100% !important;
  padding-right: 64px !important;   /* etwas kompakter, Wort "eingeben" bleibt sichtbar */
  box-sizing: border-box;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 3) Vorhandene eckige Kapseln absolut in der Box verankern */
.steuerleiste .sl4-inputbox > .ps-checkwrap,
.steuerleiste .sl4-inputbox > .ps-clearwrap{
  position: absolute !important;
  top: 50% !important;
  transform: translateY(-50%) !important;
  z-index: 5 !important;
}

/* Reihenfolge rechts: ✓ dann ✕ – leicht enger gesetzt */
.steuerleiste .sl4-inputbox > .ps-checkwrap{ right: 36px !important; }
.steuerleiste .sl4-inputbox > .ps-clearwrap{ right: 8px !important; }

/* Schutzkappen */
.steuerleiste .sl4-inputbox > .ps-checkwrap,
.steuerleiste .sl4-inputbox > .ps-clearwrap{ max-width: 28px; }
</style>
<style id="ps-title-separation-minimal">
/* Nur die in-field Überschrift innerhalb der Suche ausblenden */
.ac-wrap .ps-toplabel{ display:none !important; }
</style>
<style id="ps-title-restore">
.ps-title{ color:#ffffff !important; 
  font-size: 29px !important;
  font-weight: 700;
  
  line-height: 1.1;
  margin: 0 0 2px 0 !important;
  text-shadow: none !important;
}
.ac-wrap .ps-toplabel{ display:none !important; }
</style>
<style id="ps-offset-3mm-style">
.ps-offset-3mm{
  margin-top: 0 !important;
  transform: translateY(21px); /* ca. 1mm höher als vorher, Suchfeld-Row */
  will-change: transform;
}
.ac-wrap .ps-toplabel{ display:none !important; }
.ps-title{ color:#ffffff !important; }
</style>
<style id="order-check-inline-css">
input[placeholder*="Bestellnummer eingeben"]{ vertical-align: middle; }
.order-check-btn{}
</style>
<style id="order-check-inside-css">
.order-input-wrap{ position: relative; display: inline-block; }
.order-input-wrap input{ padding-right: 44px !important; }
.order-check-inside{
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  height: 28px;
  min-width: 34px;
  padding: 0 8px;
  border-radius: 12px;
  border: 2px solid #2a7d2e;
  background: #e8f7ea;
  color: #145c18;
  font-weight: 800;
  line-height: 24px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
}
.order-check-inside:active{ transform: translateY(-50%) scale(0.98); }
</style><style id="green-check-patch">
.steuerleiste .order-check-inside{
  width: 28px; height: 28px;
  display:flex; align-items:center; justify-content:center;
  border: 2px solid #0a7a2a !important;
  border-radius: 8px;
  background:#fff;
  box-shadow: none !important;
}
/* If the check is an SVG, color it green */
.steuerleiste .order-check-inside svg,
.steuerleiste .order-check-inside svg *{
  stroke:#0a7a2a !important;
  fill:#0a7a2a !important;
}
/* If the check is a text glyph */
.steuerleiste .order-check-inside{ color:#0a7a2a !important; }
/* Hover/Focus */
.steuerleiste .order-check-inside:hover,
.steuerleiste .order-check-inside:focus{
  border-color:#0a7a2a !important;
  outline:none;
}
/* Neutralize generic .btn styles if applied */
.steuerleiste .order-check-inside.btn,
.steuerleiste .order-check-inside.button{
  background:#fff !important;
  color:#0a7a2a !important;
}
</style>
<style id="order-check-22px-patch">
  /* Platz rechts im Bestellnummer-Input schaffen */
  .order-input-wrap > input[type="text"],
  .order-input-wrap > input[type="search"],
  .order-input-wrap > input {
    padding-right: 40px !important;
  }

  /* Der Haken-Button im Feld "Bestellnummer eingeben…" */
  .order-input-wrap { position: relative; }

  .order-input-wrap .order-check-inside {
    position: absolute;
    right: 8px;                 /* Abstand vom rechten Innenrand */
    top: 50%;
    transform: translateY(-50%);

    width: 22px !important;
    height: 22px !important;
    min-width: 22px !important;
    min-height: 22px !important;

    padding: 0 !important;
    margin: 0 !important;

    display: inline-grid;
    place-items: center;

    border: 2px solid #1B5E20 !important;  /* Grün: Rahmen */
    background: #fff !important;
    color: #1B5E20 !important;              /* Grün: Haken */
    border-radius: 6px !important;          /* kleine Ecken – keine Pille */
    line-height: 1 !important;
    box-shadow: none !important;
    outline: none !important;
  }

  /* Haken-Zeichen selbst etwas justieren */
  .order-input-wrap .order-check-inside,
  .order-input-wrap .order-check-inside * {
    font-size: 14px !important;
  }

  /* dezentes Hover/Active */
  .order-input-wrap .order-check-inside:hover { filter: brightness(0.97); cursor: pointer; }
  .order-input-wrap .order-check-inside:active { filter: brightness(0.94); }
</style>
<style>
/* === Verfügbar-Pill (gelb) in Spalte 4 – ersetzt "Guthaben:" === */
.ps-available-pill{
  display:inline-flex; align-items:center; justify-content:center;
  font-weight:700; font-size:16px; line-height:1;
  padding:10px 22px; min-width:170px; height:44px;
  color:#2b2b2b; background:#f4cf58; border:2px solid #c8aa3a;
  border-radius:12px; box-shadow:0 2px 0 #9f8b2d inset;
}
.ps-available-pill.ps-zero{
  background:#f46b58; border-color:#c13c2f; color:#fff; box-shadow:0 2px 0 #992a20 inset;
}
/* Keep layout stable where "Guthaben:" sat */
.ps-guthaben-wrap{ display:flex; align-items:center; gap:10px; }
</style>
<style>
/* Steuerleiste 5: Gelber Button "Verfügbar" über dem grünen */
.btn-yellow{
  padding: 10px 16px;
  border: 1px solid #000;
  background: #FFD86B;    /* gelb wie Box-Grundfarbe */
  color: #000;
  border-radius: 8px;
  font: inherit;
  cursor: pointer;
  display: inline-block;
}
.btn-yellow:hover{ filter: brightness(0.97); }
.btn-yellow:active{ filter: brightness(0.94); }
</style><style>
/* Steuerleiste 5: Titel 'Pflanzensuche' mittig in Spalte 1 */
.ps-title{
  width: 100%;
  text-align: center;
  margin: 0;
}
</style><style>
/* Steuerleiste 5: Kompakter Block für 'Verfügbar' (Spalte 4 oben) */
#block-verfuegbar{ flex: 0 0 auto; display:flex; align-items:center; }
#block-verfuegbar .btn-yellow{ min-width: 180px; }
</style><style>
/* Raise z-index of Verfügbar button in toolbar */
#block-verfuegbar, #btn-verfuegbar { position: relative; z-index: 5; }
</style><style>
/* === Steuerleiste 5: stabile Reihenfolge der Blöcke (kein Platztausch) === */
.steuerleiste{ flex-wrap: wrap; }
#block-suche{ order: 1; }
[aria-label="Block: Namen"]{ order: 2; }
#block-aktionen{ order: 3; }
#block-verfuegbar{ order: 4; }
</style><style>
/* === Steuerleiste 5 (Flex) – kompakt & stabile Breiten === */
.steuerleiste{ display:flex; flex-wrap:wrap; align-items:center; gap:16px; }
#block-suche{ order:1; flex: 1 1 28%; min-width: 280px; }
[aria-label="Block: Namen"]{ order:2; flex: 1 1 28%; min-width: 280px; }
#block-aktionen{ order:3; flex: 1 1 28%; min-width: 280px; }
#block-verfuegbar{ order:4; flex: 0 0 16%; min-width: 180px; justify-content:flex-end; display:flex; }

/* Überschrift kleiner/kompakter */
.ps-title{ font-size: 28px; line-height:1.1; margin:0; }

/* Gelber Button kompakter */
.btn-yellow{ padding:8px 14px; min-width: 150px; border-radius:10px; }

/* Verhindert, dass die Überschrift umbrechungsbedingt nach unten schwappt */
#block-suche .ps-title{ white-space: nowrap; }
</style><style>
/* === Test: harte Größen === */
.btn-yellow{
  width: 5cm !important;
  min-width: 5cm !important;
  max-width: 5cm !important;
  padding-left: 0 !important;
  padding-right: 0 !important;
}
.ps-title{
  font-size: 20px !important;
  line-height: 1.15 !important;
}
</style><style>
/* === SL5: fester Gelb-Button & geschützte Überschrift === */
.steuerleiste{ position: relative; padding-right: 6.2cm; } /* Platz für 5cm Button + Rand */
#sl5-fixed-available{
  position:absolute; top:12px; right:16px; z-index:5;
  display:flex; align-items:center; justify-content:center;
}
#sl5-fixed-available #btn-verfuegbar{
  width:5cm; min-width:5cm; max-width:5cm;
}
/* Überschrift darf nicht "verschwinden" */
#block-suche .ps-title{
  display:block !important;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  font-size:20px; line-height:1.15;
}
</style><style>
/* --- SAFE TITLE + FIXED YELLOW BUTTON (no JS) --- */
.steuerleiste{ position: relative; padding-right: 240px; } /* reserve space for yellow button */
#sl5-fixed-available{ position:absolute; top:12px; right:16px; z-index:5; display:flex; align-items:center; justify-content:center; }
#sl5-fixed-available #btn-verfuegbar{ box-sizing:border-box; width:220px; height:44px; border-radius:12px; font-weight:700; }
#block-suche{ position: relative; flex: 1 1 30%; min-width: 300px; }
#block-suche .ps-title{
  display:block; width:100%; text-align:center;
  font-size:20px; line-height:1.2; margin:0 0 8px 0;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  position:relative; z-index:6;
}
</style><style>
/* --- SL5 SAFE v2: Titel kollidiert nie mit Gelb --- */
:root{ --sl5-avail-space: 260px; } /* Platz rechts (Gelbbreite + Rand) */
.steuerleiste{ position: relative; padding-right: var(--sl5-avail-space); }
#sl5-fixed-available{ position:absolute; top:12px; right:16px; z-index:5; display:flex; align-items:center; justify-content:center; }
#sl5-fixed-available #btn-verfuegbar{ box-sizing:border-box; width:220px; height:44px; border-radius:12px; font-weight:700; }

#block-suche{ position: relative; flex: 1 1 30%; min-width: 300px; }
#block-suche .ps-title{
  position: relative; z-index: 6;
  display:block;
  /* Titel bekommt effektiv einen rechten Rand = Gelbplatz.
     Wir lösen das, ohne das Centering zu zerstören: wir limitieren die Breite
     und zentrieren die Überschrift innerhalb dieser Breite. */
  max-width: calc(100% - var(--sl5-avail-space));
  margin: 0 auto 8px auto;   /* zentriert */
  text-align:center;
  font-size:20px; line-height:1.2;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
</style><style>
/* === SL5: Overlay-Grid für Titel (Spalte 1, Reihe 2) === */
:root{ --sl5-avail-space: 260px; } /* reservierter Bereich rechts (Gelb) */
.steuerleiste{ position: relative; padding-right: var(--sl5-avail-space); }

#sl5-title-overlay{
  position:absolute; left:0; top:6px; right:var(--sl5-avail-space); 
  height: 150px; /* 3 Zeilen à ~50px */
  display:grid; grid-template-columns: repeat(4, 1fr);
  grid-template-rows: 50px 50px 50px;
  pointer-events:none; /* Overlay blockiert keine Klicks darunter */
  z-index:4;
}
#ps-title-fixed.ps-title{
  grid-column: 1 / 2; grid-row: 2 / 3; /* Spalte 1, mittlere Zeile */
  justify-self: center; align-self: center;
  pointer-events:auto; /* falls nötig auswählbar */
  margin:0;
  font-size: 20px; line-height: 1.2;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
  background: transparent; outline: none; color:#1a1a1a;
  z-index: 6;
}

/* Gelber Button bleibt fix oben rechts */
#sl5-fixed-available{ position:absolute; top:12px; right:16px; z-index:5; display:flex; align-items:center; justify-content:center; }
#sl5-fixed-available #btn-verfuegbar{ box-sizing:border-box; width:220px; height:44px; border-radius:12px; font-weight:700; }
</style><style>
/* FORCE title size */
.steuerleiste #sl5-title-overlay #ps-title-fixed.ps-title{
  font-size: 28px !important;
  line-height: 1.15 !important;
}
</style>
<style>
/* Titel 7mm nach rechts */
.steuerleiste #sl5-title-overlay #ps-title-fixed.ps-title{
  margin-left: 7mm !important;
}
</style>
<style>
/* Zähler-Badges auf Buttons */
#btn-verfuegbar, #btn-open-cart-top{
  position: relative;
}
#btn-verfuegbar .btn-label, #btn-open-cart-top .btn-label{ display:inline-block; vertical-align:middle; }
#btn-verfuegbar .btn-badge, #btn-open-cart-top .btn-badge{
  display:inline-block;
  margin-left: .5ch;
  min-width: 1.6em;
  text-align: center;
  border-radius: 999px;
  padding: 0 .5em;
  font-weight: 700;
  line-height: 1.2;
}
/* Farben der Badges an Buttonfarbe angepasst */
#btn-verfuegbar .btn-badge{ background: rgba(0,0,0,.15); color:#000; }
#btn-open-cart-top .btn-badge{ background: rgba(255,255,255,.22); color:#fff; }

/* Quellen, die wir "abgeräumt" haben (alte Anzeige über der Leiste) ausblenden */
.sl5-hide-source{ display:none !important; }
</style>
<style>
/* Verfügbar-Banner außerhalb der Leiste sauber ausblenden */
.sl5-hide-source{ display:none !important; visibility:hidden !important; }
</style>
<style>
/* Emphasis for numeric parts */
#btn-verfuegbar .btn-badge strong,
#btn-open-cart-top .btn-badge strong{ font-weight: 800; }
#btn-open-cart-top .btn-badge{ margin-left: .35ch; padding: 0 .45ch; border-radius: .8em; }
#btn-open-cart-top .btn-badge::before{ content: "("; }
#btn-open-cart-top .btn-badge::after{ content: ")"; }
#btn-verfuegbar .btn-badge{ padding: 0 .5ch; border-radius: .6em; }
/* Hide stray "Verfügbar: N" banners */
.sl5-hide-source{ display:none !important; visibility:hidden !important; }
</style>
<style>
#btn-open-cart-top{ position: relative; }
#btn-open-cart-top .btn-label{ display:inline-block; vertical-align:middle; }
#btn-open-cart-top .btn-badge{
  display:inline-block; vertical-align:middle;
  margin-left: .35ch; padding: 0 .45ch;
  border-radius: .9em; font-weight: 800;
  background: rgba(0,0,0,.18); color:#000;
}
/* Wenn Zum-Warenkorb grün wäre, invertieren wir auf weiß */
#btn-open-cart-top.btn--green .btn-badge{ background: rgba(255,255,255,.25); color:#fff; }
</style>
<style>
#btn-verfuegbar, #btn-open-cart-top{ position: relative; }
#btn-verfuegbar .btn-label, #btn-open-cart-top .btn-label{ display:inline-block; vertical-align:middle; }
#btn-verfuegbar .btn-badge{ display:inline-block; margin-left:.5ch; padding:0 .5ch; border-radius:.6em; font-weight:800; background:rgba(0,0,0,.15); color:#000; }
#btn-open-cart-top .btn-badge{ display:inline-block; margin-left:.35ch; padding:0 .45ch; border-radius:.9em; font-weight:800; background:rgba(0,0,0,.18); color:#000; }
#btn-open-cart-top.btn--green .btn-badge{ background:rgba(255,255,255,.25); color:#fff; }
</style>
<style>
/* SL6 Schritt 1: Doppeltes Such-Label ausblenden – Overlay-Titel bleibt sichtbar */
.steuerleiste .ac-wrap .ps-toplabel { display: none !important; }
</style>
<style id="druck100-css">
  #druck100-anchor{ position: sticky; top: 0; z-index: 9999; background: #fff; border-bottom: 1px solid #ccc; padding: 8px; }
  #druck100-anchor .btn{ border:0.5mm solid #000; background:#fff; border-radius:6px; padding:6px 10px; font:inherit; cursor:pointer; }
  #druck100-panel{ max-width:980px; margin:12px auto 24px; padding:12px 8px; background:#fafafa; border:1px dashed #888; }
  #druck100-panel h2{ margin:0 0 8px 0; font-size: 18px; }
  #druck100-controls{ margin-bottom:10px; display:flex; gap:8px; flex-wrap:wrap; }
  #druck100-controls button{ border:0.5mm solid #000; background:#fff; border-radius:6px; padding:6px 10px; font:inherit; cursor:pointer; }
  #druck100-status{ font-size:12px; opacity:.85; margin-left:8px; }
  #druck100-stage{ display:flex; gap:30mm; align-items:flex-start; flex-wrap:nowrap; isolation:isolate; }
  #druck100-stage .druck-card{ position:relative; width:54mm; height:85mm; box-sizing:border-box; background:#fff; outline:0.2mm solid rgba(0,0,0,.25); }
  #druck100-stage .druck-card .wrap{ position:relative; width:100%; height:100%; overflow:hidden; transform:none !important; }
  #druck100-stage .rahmen-overlay,
  #druck100-stage .editor-rahmen,
  #druck100-stage .bearbeitungs-rahmen,
  #druck100-stage [data-editor-only],
  #druck100-stage [data-role="editor-only"]{ display:none!important; }
  #druck100-stage *{ pointer-events:none; user-select:none; }
</style>
<style id="druck-zoom-isolation">
  /* Druckbereich vom globalen Editor-Zoom entkoppeln */
  #druck100-stage {
    --zoom: 1 !important;      /* Karten-Innereien immer Basis-100% */
  }
</style>
<style>
  .spruchregal{margin-top:8px; background:#fff; border:1px solid #ccc; border-radius:10px; padding:8px; max-width:520px;}
  .spruchregal-head{font-weight:600; margin-bottom:6px; display:flex; align-items:center; justify-content:space-between; gap:6px;}
  .spruchchips{display:flex; flex-wrap:wrap; gap:6px; max-height:140px; overflow:auto; padding:4px 0;}
  .chip{border:1px solid #ddd; border-radius:999px; padding:6px 10px; font-size:14px; cursor:grab; user-select:none; background:#f9f9f9; white-space:nowrap;}
  .chip:active{cursor:grabbing;}
  .chip.free{background:#fffef5; border-color:#e6d88a;}
  .chip::-webkit-scrollbar{height:6px;}
</style>
<style>
  /* Feld 6 (Spruch) – altes Gelb dauerhaft ausblenden */
  #spruchSelect,
  #spruchDragCard,
  label[for="spruchSelect"] {
    display: none !important;
    visibility: hidden !important;
  }
</style>
<style>
  .spruch-acc { margin: 6px 0 10px 0; }
  .spruch-acc[open] > .spruch-acc-summary { border-bottom-left-radius: 0; border-bottom-right-radius: 0; }
  .spruch-acc-summary {
    list-style: none;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    background: #ffd86b;
    border: 1px solid #e0c25a;
    border-radius: 10px;
    padding: 6px 10px;
    cursor: pointer;
    user-select: none;
  }
  .spruch-acc-summary::-webkit-details-marker { display:none; }
  .spruchregal{margin-top:8px; background:#fff; border:1px solid #ccc; border-radius:10px; padding:8px; max-width:520px;}
  .spruchchips{display:flex; flex-wrap:wrap; gap:6px; max-height:140px; overflow:auto; padding:4px 0;}
  .chip{border:1px solid #ddd; border-radius:999px; padding:6px 10px; font-size:14px; cursor:grab; user-select:none; background:#f9f9f9; white-space:nowrap;}
  .chip:active{cursor:grabbing;}
  .chip.free{background:#fffef5; border-color:#e6d88a;}
  /* Freitext area inside the panel */
  #spruchFreeArea{ width:100%; box-sizing:border-box; border:2px solid #e6d88a; border-radius:10px; padding:8px 10px; resize:none; line-height:20px; }
  #spruchFreeCounters{ font-size:12px; margin-top:2px; opacity:.9;}
  .drag-handle{ display:inline-block; margin-top:6px; border:1px solid #ddd; border-radius:999px; padding:6px 10px; user-select:none; cursor:grab; background:#f9f9f9; }
</style>
<style>
  /* Ensure Feld 6 overlay accepts drag events */
  #feld6_slot { pointer-events: auto !important; }
  #spruchAnzeige { pointer-events: auto !important; }
</style>
<style>
  /* Ensure Feld 7 drop area is interactive */
  #symbolAnzeige { pointer-events: auto !important; }
</style>
<style>
  /* Container unter der Kartenvorderseite für Feld 6 & 7 */
  #underCardSelectors {
    display: grid;
    grid-template-columns: auto auto auto;
    gap: 12px;
    align-items: center;
    margin-top: 10px;
  }
  @media (max-width: 900px){
    #underCardSelectors { grid-template-columns: 1fr; }
  }
  .uc-panel {
    display:flex;
    justify-content:center;
    align-items:center;
    background:transparent;
    border:none;
    padding:0;
  }
  .uc-panel h3 { display:none !important; }
</style>
<style>
  /* Feld 7 fallback select styling */
  .uc-panel select#smileySelect {
    display: block !important;
    visibility: visible !important;
    min-width: 240px;
    height: 40px;
    padding: 6px 10px;
    border: 1px solid #c9c9c9;
    border-radius: 10px;
    background: #fff7cc;
  }
  .uc-panel .picker-row{ display:flex; align-items:center; gap:8px; }
  .uc-panel .picker-row label{ font-size:13px; opacity:.8; }
</style>
<style>
  /* Tighter spacing to the card */
  #underCardSelectors {
    margin-top: 6px !important;
    gap: 10px !important;
  }
  .uc-panel { position: relative; padding-top: 16px; }
  .uc-panel:empty { display:none !important; }

  /* Upward arrows that can point to slots */
  
  /* small ring to emphasise relationship */
  
</style>
<body class="zoom-100">
<!-- === DRUCK-ANCHOR (immer sichtbar) === -->
<div id="druck100-anchor">
<strong>Druckbereich:</strong>
<button class="btn" onclick="document.getElementById('druck100-panel')?.scrollIntoView({behavior:'smooth'});">Zum Druckbereich</button>
</div>
<!-- === DRUCKBEREICH (sichtbar direkt unter dem Anchor) === -->
<section aria-label="Druckbereich" id="druck100-panel">
<h2>Druckbereich (Front/Back 1:1 aus Abschluss)</h2>
<div id="druck100-controls">
<button id="btnPraesentation" type="button">Präsentationskarte erstellen</button>
<button id="ead-copy-print" type="button">Für Druck übernehmen</button>
<span id="druck100-status"></span>
</div>
<div id="druck100-stage">
<div class="druck-card"><div class="wrap"></div></div>
<div class="druck-card"><div class="wrap"></div></div>
</div>
</section>
<div class="order-modal-backdrop" id="order-modal">
<div aria-labelledby="order-modal-title" aria-modal="true" class="order-modal" role="dialog">
<h3 id="order-modal-title">Bestellnummer eingeben</h3>
<p>Du hast auf Etsy gekauft. Bitte gib deine <strong>Bestellnummer</strong> ein.</p>
<form id="order-modal-form">
<input aria-label="Bestellnummer" autocomplete="off" id="order-id-input" inputmode="text" placeholder="z. B. 20250919-ABC12" type="text"/>
<button class="primary" type="submit">Weiter</button>
<button class="secondary" id="order-cancel" type="button">Abbrechen</button>
</form>
<div class="error" id="order-error">Bitte eine gültige Bestellnummer (5–20 Zeichen: Ziffern/Buchstaben/Bindestriche) eingeben.</div>
</div>
</div>
<style id="two-page-sim-style">
  #simBar{position:sticky; top:0; z-index:9999; background:#fffbcc; border-bottom:2px solid #000; padding:8px 12px; display:flex; gap:8px; align-items:center;}
  #simBar .dot{width:10px; height:10px; border-radius:50%; background:#d33;}
  #simBar .dot.ok{background:#2a7;}
  #simBar button{padding:6px 10px; border:1px solid #000; background:#fff; border-radius:8px; cursor:pointer;}
  #simToast{position:fixed; right:16px; bottom:16px; background:#111; color:#fff; padding:10px 12px; border-radius:10px; display:none;}
</style>
<div id="simBar">
<div class="dot" id="simDot" title="Verbindung zum Shop"></div>
<strong>Konfigurator ↔ Shop (Simulation)</strong>
<button id="btnSendToShop" type="button">In den Shop legen</button>
<button id="btnPingShop" type="button">Verbindung prüfen</button>
<span id="simInfo" style="margin-left:auto; font-size:12px; opacity:.8">Kanal: pfk-link</span>
</div>
<div id="simToast"></div>
<script id="prebody-textnode-cleanup">
/* Entfernt nur führende Textknoten im <body>
<div id="order-modal" class="order-modal-backdrop">
  <div class="order-modal" role="dialog" aria-modal="true" aria-labelledby="order-modal-title">
    <h3 id="order-modal-title">Bestellnummer eingeben</h3>
    <p>Du hast auf Etsy gekauft. Bitte gib deine <strong>Bestellnummer</strong> ein.</p>
    <form id="order-modal-form">
      <input type="text" id="order-id-input" placeholder="z. B. 20250919-ABC12" inputmode="text" autocomplete="off" aria-label="Bestellnummer">
      <button type="submit" class="primary">Weiter</button>
      <button type="button" id="order-cancel" class="secondary">Abbrechen</button>
    </form>
    <div id="order-error" class="error">Bitte eine gültige Bestellnummer (5–20 Zeichen: Ziffern/Buchstaben/Bindestriche) eingeben.</div>
  </div>
</div>
 (z. B. "-->", "-", Whitespaces) – hat keine Wirkung auf DOM-Elemente */
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    var b = document.body;
    while (b && b.firstChild && b.firstChild.nodeType === 3){
      var t = b.firstChild.nodeValue || "";
      if (/^[\s\-–—>]*$/.test(t)) { b.removeChild(b.firstChild); } else { break; }
    }
  }catch(_){}
});</script>
<input accept=".csv,text/csv" id="fileBoxes" style="display:none" type="file"/>
<input accept=".csv,text/csv" id="fileMaster" style="display:none" type="file"/>
<div class="frame">
<!-- Asset Mode Toolbar (developer only) -->
<div id="asset-mode-toolbar" style="display:flex;gap:.5rem;align-items:center;margin:10px 0;">
<span style="font-weight:600;">Modus:</span>
<button id="btn-mode-png" style="padding:.35rem .7rem;border:1px solid #555;border-radius:6px;cursor:pointer;" type="button">PNG</button>
<button id="btn-mode-svg" style="padding:.35rem .7rem;border:1px solid #555;border-radius:6px;cursor:pointer;" type="button">SVG</button>
<span id="mode-status" style="margin-left:.75rem;opacity:.8;">—</span>
</div>
<style id="asset-mode-mini-style">
  #asset-mini{position:sticky;top:6px;z-index:9999;display:flex;gap:6px;margin:6px 0}
  #asset-mini button{padding:.25rem .5rem;border:1px solid #666;border-radius:6px;font-size:.85rem;cursor:pointer}
  #asset-mini-status{opacity:.7;margin-left:.5rem}
</style>
<style id="asset-mode-buttons-disabled">
  /* SVG/PNG-Schalter vorsichtig deaktivieren: keine Klick-Reaktion mehr */
  #asset-mode-toolbar button,
  #asset-mini button{
    pointer-events: none !important;
    cursor: default !important;
  }
</style>
<style id="asset-mode-svg-red-cross">
  /* Rotes Kreuz nur über den SVG-Schaltern (Toolbar + Mini-Leiste) */
  #btn-mode-svg,
  #asset-mini button:last-of-type{
    position: relative !important;
  }
  #btn-mode-svg::after,
  #asset-mini button:last-of-type::after{
    content: '✕';
    position: absolute;
    inset: 2px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #b00020;
    font-size: 1.2em;
    font-weight: 700;
    text-shadow: 0 0 2px #fff;
    pointer-events: none;
  }
</style>


<div id="asset-mini">
<button onclick="window.setAssetMode &amp;&amp; setAssetMode('PNG')" type="button">PNG</button>
<button onclick="window.setAssetMode &amp;&amp; setAssetMode('SVG')" type="button">SVG</button>
<span id="asset-mini-status">—</span>
</div>
<div aria-label="Steuerleiste" class="steuerleiste" role="toolbar">
<!-- SL5 Overlay-Grid: 4 Spalten × 3 Zeilen -->
<div aria-hidden="true" id="sl5-title-overlay">
<h2 class="ps-title" id="ps-title-fixed">Pflanzensuche:</h2>
</div>
<!-- SL5: fester, nicht-verschiebbarer Gelb-Button -->
<div aria-label="Verfügbar" id="sl5-fixed-available">
<button aria-label="Verfügbar" class="btn-yellow" id="btn-verfuegbar" type="button"><span class="btn-label">Verfügbar</span><span aria-live="polite" class="btn-badge"></span></button>
</div>
<div class="block" id="block-suche"><div class="ps-offset-3mm ac-wrap"><label class="ps-toplabel" for="pflanzensuche" style="font-size:29px !important">Pflanzensuche:</label><input id="pflanzensuche" placeholder="Pflanzenname eingeben…" type="text"/>
<div id="plant-change-note" class="plant-change-note">Pflanzenwechsel leert die Karte.</div>
<div class="ps-checkwrap"><span class="ps-check">✓</span></div>
<div id="rb-plant-hint-anchor"></div><div aria-label="Eingabe löschen und Hinweise leeren" class="ps-clearwrap" role="button" tabindex="0"><span class="ps-clear">✕</span></div><div class="ac-anchor" id="autocomplete-anchor"></div><div class="nohit-toast" id="nohit-toast" style="display:none">Leider ist deine Pflanze noch nicht in unserer Datenbank. Wenn du alle Pflegehinweise hast, kannst du deine Karte dennoch erstellen.</div></div>
</div>
<div aria-label="Block: Namen" class="block column">
<button id="btn-kosename" type="button">Kosename</button>
<button id="btn-uebernehmen-kosename" type="button">Kosename übernehmen</button>
<div id="rb-kose-hint-anchor"></div>
<button id="btn-uebernehmen-name" type="button">Pflanzennamen übernehmen</button>
</div>
<div aria-label="Block: Aktionen" class="block column" id="block-aktionen">
<button id="btn-leeren" type="button">Karte leeren</button>
<script id="rb-clear-failsafe">
// Failsafe: bind 'Karte leeren' nach DOM-Ladung, ohne bestehende Logik zu verändern.
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  var btn = document.getElementById('btn-leeren');
  if (!btn) return;
  if (!btn._rbClearBound) {
    btn.addEventListener('click', function(){
      try{
        // 1) Felder 1..25 leeren (Sticker/Text)
        for (var i=1;i<=25;i++){
          var el = document.getElementById('feld'+i);
          if (el) el.innerHTML = '';
        }
        // Feld 1 Anzeige leeren
        var f1 = document.getElementById('feld1NameAnzeige'); if (f1) f1.textContent = '';

        // 2) Textkapseln mit data-slot neutralisieren
        document.querySelectorAll('.karte-overlay [data-slot]').forEach(function(n){ n.textContent=''; });

        // 3) Spruch & Smiley zurücksetzen
        var spr = document.getElementById('spruchSelect');  if (spr)  spr.selectedIndex = 0;
        var smi = document.getElementById('smileySelect');  if (smi)  smi.selectedIndex = 0;
        var sprA = document.getElementById('spruchAnzeige'); if (sprA) sprA.textContent = '';
        var symA = document.getElementById('symbolAnzeige'); if (symA) symA.textContent = '';
        // 4) Rückseiten-Hinweis entfernen (Hinweis-Pille + Raised-Klasse)
        try{
          document.querySelectorAll('#karte-rueckseite .slot-hint').forEach(function(n){ n.remove(); });
          var fig = document.getElementById('karte-rueckseite'); if (fig) fig.classList.remove('hint-raise');
        }catch(_){}
      }catch(_){ /* still quiet */ }
    });
    btn._rbClearBound = true;
  }
});
</script>
<button id="btn-alle-sticker" type="button">Zeige alle Sticker</button>
<button id="btn-passende-sticker" type="button">Zeige nur passende Sticker</button>
</div>
<button id="btn-open-cart-top" type="button"><span class="btn-label">Zum Warenkorb</span><span aria-live="polite" class="btn-badge"></span></button>
</div>
<div class="content">
<div class="columns">
<!-- Asset Mode Toolbar --><section aria-labelledby="h-links" class="panel" id="spalte-links">
<h2 id="h-links">Pflegehinweise für <span id="rb-plantname">–</span></h2>
  <div class="help-button-row">
    <a class="help-link"
       href="https://www.gutezeitalleine.de/blank"
       target="_blank"
       rel="noopener">
      <div class="help-pill" aria-label="Anleitungen &amp; Hinweise öffnen">
        <div class="help-icon">i</div>
        <div class="help-text">
          <span>Anleitung</span>
          <span>Hinweise</span>
        </div>
      </div>
    </a>
  </div>
<div aria-label="Rote Boxen" class="rb-scope" id="rb-scope">
<div class="rb-status" id="rb-status">Lade Boxen …</div>
<input accept=".csv,text/csv" id="rb-file-boxes" style="display:none" type="file"/>
<input accept=".csv,text/csv" id="rb-file-master" style="display:none" type="file"/>
<div aria-live="polite" class="rb-boxes" id="rb-boxes"></div>
</div>
<div aria-label="Auswahl" class="rb-dd" id="rb-dropdown" role="dialog">
<div class="rb-dd-body" id="rb-dd-body">
<div class="rb-dd-foot" id="rb-dd-foot">
<div class="rb-dd-free" contenteditable="true" draggable="true" id="rb-dd-free" placeholder="Freitext …"></div>
<div class="rb-muted">Freitext tippen &amp; dann ins Feld ziehen.</div>
</div>
<div class="rb-dd-free" contenteditable="true" draggable="true" id="rb-dd-free-dup" placeholder="Freitext …"></div>
<div class="rb-muted">Freitext tippen &amp; dann ins Feld ziehen.</div>
</div>
</div>
</section>
<section aria-labelledby="h-rechts" class="panel" id="spalte-rechts">
<h2 id="h-rechts">Hier bearbeitest du deine Pflanzenpflegekarte</h2>
<div aria-label="Werkzeuge rechte Spalte" class="panel-tools">
<div class="icon" id="trash" role="button" title="Mülleimer">🗑️</div>
<button id="btn-zoom-100" type="button">Zoom 100%</button>
<button id="btn-zoom-150" type="button">Zoom 150%</button>
<button id="btn-toggle-frontback" type="button">Vorder-/Rückseite umschalten</button>
</div>
<div class="kartenbereich" id="kartenbereich">
<figure class="front-wrapper" id="karte-vorderseite">
<img alt="Kartenvorderseite" class="karte" src="Weihnachtsstern Vorderseite leer ohne Lineal_symbol.png"/>
<div id="feld1NameAnzeige" style="position:absolute;
              left: calc(9.449px * var(--zoom));
              top: calc(13.228px * var(--zoom));
              width: calc(185.197px * var(--zoom));
              height: calc(37.795px * var(--zoom));
              font-family: 'Playfair display', serif;
              font-size: calc(18px * var(--zoom));
              font-weight: 900;
              display:flex; align-items:center; justify-content:center;
              text-align:center; white-space:nowrap; overflow:hidden; pointer-events:none;">
</div>
<div aria-label="Spruch (Feld 6)" id="spruchAnzeige" style="position:absolute; left: calc(9.449px * var(--zoom)); top: calc(258.787px * var(--zoom));
              width: calc(128.5px * var(--zoom)); height: calc(37.795px * var(--zoom));
              display:flex; align-items:center; justify-content:center; text-align:center;
              font-family: 'Playfair Display', serif; font-size: calc(0.84rem * var(--zoom));
              line-height: 1.2; white-space: pre-wrap; overflow:hidden; padding: calc(2px * var(--zoom)) 0 0 calc(2px * var(--zoom));">
</div>
<div aria-label="Symbol (Feld 7)" id="feld7" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="z-index:10; cursor: pointer; position:absolute; left: calc(149.637px * var(--zoom)); top: calc(260.787px * var(--zoom));
              width: calc(45.354px * var(--zoom)); height: calc(37.795px * var(--zoom));
              display:flex; align-items:center; justify-content:center; font-size: calc(20px * var(--zoom));">
</div>
<div aria-label="Symbol (Feld 7)" id="symbolAnzeige" style="position:absolute; left: calc(149.637px * var(--zoom)); top: calc(260.787px * var(--zoom));
              width: calc(45.354px * var(--zoom)); height: calc(37.795px * var(--zoom));
              display:flex; align-items:center; justify-content:center; font-size: calc(20px * var(--zoom));">
</div>
<div aria-label="Sticker-Slots Vorderseite" class="karte-overlay" id="karte_vorderseite_overlay">
<div id="feld2" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(9.449px * var(--zoom)); top: calc(64.252px * var(--zoom)); width: calc(86.929px * var(--zoom)); height: calc(86.929px * var(--zoom)); z-index:10;"></div>
<div id="feld3" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(108.062px * var(--zoom)); top: calc(64.252px * var(--zoom)); width: calc(86.929px * var(--zoom)); height: calc(86.929px * var(--zoom)); z-index:10;"></div>
<div id="feld4" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(9.449px * var(--zoom)); top: calc(162.520px * var(--zoom)); width: calc(86.929px * var(--zoom)); height: calc(86.929px * var(--zoom)); z-index:10;"></div>
<div id="feld5" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(108.062px * var(--zoom)); top: calc(162.520px * var(--zoom)); width: calc(86.929px * var(--zoom)); height: calc(86.929px * var(--zoom)); z-index:10;"></div>
</div>
<div class="front-controls" id="front-controls">
<select id="spruchSelect">
<option>– kein Spruch –</option>
<option>Hier kommt Hilfe / für deinen Daumen.</option>
<option>Danke für deine/ liebevolle Pflege.</option>
<option>Habe Geduld,/ bin am wachsen.</option>
<option>Vergiß mich nicht, / ich brauch dich!</option>
<option value="__custom__">✎ Eigener Text …</option></select>
<!-- === Spruchregal: direkte Drag-Quellen für Feld 6 === -->
<details class="spruch-acc" id="spruchAccordion">
<summary class="spruch-acc-summary">Spruch ▾</summary>
<div class="spruchregal" id="spruchRegal">
<div class="spruchregal-head">
<span>Spruch direkt ziehen</span>
<div aria-label="Spruch-Auswahl schließen" class="ps-clearwrap spruchregal-clear" onclick="closeSpruchRegal(event)" role="button" tabindex="0">
<span class="ps-clear">X</span>
</div>
</div>
<div class="spruchchips" id="spruchChips"></div>
<div class="spruchregal-foot">
<textarea id="spruchFreeArea" placeholder="Freitext (max. 2 Zeilen × 18 Zeichen). Umbruch: Shift+Enter. Prüfe wie der Text ins Feld passt!" rows="3"></textarea>
<div id="spruchFreeCounters">Zeile 1: 0/18 · Zeile 2: 0/18</div>
<div class="drag-handle" draggable="true" id="spruchDragHandle" title="Freitext auf Feld 6 ziehen">Freitext ziehen</div>
</div>
</div>
<select id="smileySelect" title="Symbol">
</select><div id="feld7-dd"><button aria-expanded="false" aria-haspopup="listbox" id="feld7-trigger" type="button"><img alt="" id="feld7-icon"/><span class="label" id="feld7-label">Auswahl</span></button><ul id="feld7-menu" role="listbox" tabindex="-1"><li class="feld7-item" data-img="smiley.png" data-value="smiley" role="option" tabindex="-1"><img alt="Smiley" src="smiley.png"/><span>Smiley</span></li><li class="feld7-item" data-img="pfeil.png" data-value="pfeil" role="option" tabindex="-1"><img alt="Pfeil" src="pfeil.png"/><span>Pfeil</span></li><li class="feld7-item" data-altimg="logoschwarzfuerkarte.png" data-img="logo_schwarz_fuer_karte.png" data-value="logo" role="option" tabindex="-1"><img alt="Logo" src="logo_schwarz_fuer_karte.png"/><span>Logo</span></li></ul></div>
<div aria-hidden="true" class="spruch-popup" id="spruchPopup">
<div class="sp-head">Freitext</div>
<div class="sp-body">
<textarea id="spruchPopupInput" placeholder="Text hier eingeben…"></textarea>
<div class="sp-hint" id="spruch-popup-hint">Zweizeilig mit ca.18 Zeichen möglich (Zeilenumbruch: Shift + Enter). Prüfe wie der Text ins Feld passt!</div>
</div>
<div class="sp-actions">
<button id="spruchPopupApply" type="button">Übernehmen</button>
<button id="spruchPopupCancel" type="button">Abbrechen</button>
</div>
</div>
</details>
</div>
<div class="rahmen-overlay"></div></figure>
<figure id="karte-rueckseite">
<img alt="Kartenrückseite" class="karte" src="Weihnachtsstern Rueckseite leer ohne Lineal_symbol.png"/>
<div aria-label="Sticker-Slots Rückseite" class="karte-overlay" id="karte_rueckseite_overlay">
<div id="feld8" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(7.380px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld9" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(42.174px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld10" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(76.940px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld11" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(111.705px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld12" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(146.443px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld13" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(181.208px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld14" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(215.974px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld15" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(250.768px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld16" ondragover="event.preventDefault();" ondrop="empfangeSticker(event, this.id);" style="position:absolute; left: calc(8.976px * var(--zoom)); top: calc(285.533px * var(--zoom)); width: calc(28.346px * var(--zoom)); height: calc(28.346px * var(--zoom)); z-index:10;"></div>
<div id="feld17" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(12.404px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld18" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(47.138px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld19" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(81.942px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld20" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(116.938px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld21" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(151.738px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld22" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(186.338px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld23" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(220.938px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld24" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(255.338px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
<div id="feld25" style="position:absolute; left: calc(43.297px * var(--zoom)); top: calc(289.938px * var(--zoom));
                width: calc(152.771px * var(--zoom)); height: calc(18.917px * var(--zoom));
                z-index:10; display:flex; align-items:center; justify-content:center;
                padding-left: calc(1.2px * var(--zoom)); overflow:hidden;">
</div>
</div><div class="rahmen-overlay"></div><div id="hint-layer"></div></figure>
<figure class="lineal" id="lineal">
<img alt="Lineal" src="lineal_symbol.png"/>
</figure>
</div><div id="abschluss-trigger-row"><button id="btn-open-abschluss">Karte fertig</button></div>
</section>
</div><section id="abschluss-panel" style="display:none;"><div id="abschluss-controls"><button id="btn-abschluss-zoom-100" onclick="event.preventDefault(); window.setAbschlussZoom &amp;&amp; setAbschlussZoom('100');">100%</button><button id="btn-abschluss-zoom-150" onclick="event.preventDefault(); window.setAbschlussZoom &amp;&amp; setAbschlussZoom('150');">150%</button><button aria-label="Vorder- und Rückseite umschalten" id="btn-abschluss-flip" onclick="event.preventDefault(); window.flipAbschluss &amp;&amp; flipAbschluss();">Vorder-/Rückseite umschalten</button><button class="btn" id="btn-abschluss-back" type="button">Zurück zur Bearbeitung</button></div><div id="abschluss-grid"><div class="zoom-100" id="abschluss-stage"><div class="l2-card-frame" id="abschluss-card-frame"><div id="abschluss-card"><div class="wrap"></div></div></div><div aria-hidden="true" id="abschluss-ruler"></div></div><aside id="abschluss-sidebar"><div class="abschluss-paper"><fieldset id="abschluss-options"><legend>Ausführung (pro Karte)</legend><label class="opt"><input name="abschluss-ausfuehrung" type="radio" value="laminat_oben"/><span>Loch oben (Laminatüberstand)</span></label><label class="opt"><input name="abschluss-ausfuehrung" type="radio" value="laminat_unten"/><span>Überstand unten (für Klammern)</span></label><label class="opt"><input name="abschluss-ausfuehrung" type="radio" value="kein_laminat"/><span>Kein Laminatüberstand</span></label><label class="opt"><input name="abschluss-ausfuehrung" type="radio" value="steckspitze"/><span>Steckspitze</span></label></fieldset><div id="abschluss-qtywrap"><label for="abschluss-qty">Menge</label><input id="abschluss-qty" min="1" step="1" type="number" value="1"/></div></div><div id="abschluss-actions"><button id="btn-abschluss-addcart">In den Warenkorb</button><button id="btn-abschluss-next-clean" onclick="try{var bb=document.getElementById('btn-abschluss-back'); if(bb) bb.click();}catch(e){} setTimeout(function(){try{var b=document.getElementById('btn-leeren'); if(b) b.click();}catch(e){}},200); return false;">Nächste Karte</button><button id="btn-abschluss-checkout">Bestellung aufgeben</button></div><div id="abschluss-cart-msg"></div><div id="abschluss-cart-list" style="; margin-top: 12px;"></div><button disabled="" id="btn-cart-apply-update" type="button">Ausgewählte Karte aktualisieren</button><button id="btn-cart-copylink" type="button">Bestelllink kopieren</button><button data-clear-cart="" id="btn-cart-clear" type="button">Warenkorb leeren</button><button id="btn-cart-export" type="button">Exportieren</button><button id="btn-cart-import" type="button">Importieren</button><input accept="application/json" id="cart-import-file" style="display:none" type="file"/><span id="cartTotal">0 €</span></aside></div></section>
</div>
</div>
<script>
    (function(){
      const root = document.documentElement;
      const body = document.body;
      const kb   = document.getElementById('kartenbereich');
      const cFront = document.getElementById('karte-vorderseite');
      const cBack  = document.getElementById('karte-rueckseite');
      const lineal = document.getElementById('lineal');
      const b100 = document.getElementById('btn-zoom-100');
      const b150 = document.getElementById('btn-zoom-150');
      const bToggle = document.getElementById('btn-toggle-frontback');

      // 1) Zoom
      function setZoom(z){
        const v = (z === 1.5) ? 1.5 : 1;        // nur 100% oder 150%
        root.style.setProperty('--zoom', v);
        body.classList.toggle('zoom-150', v === 1.5);
        body.classList.toggle('zoom-100', v !== 1.5);
        // Abschluss-Bereich (falls bereits aufgebaut) auf gleiche Zoomstufe bringen
        try{
          var stage = document.getElementById('abschluss-stage');
          if(stage){
            stage.style.setProperty('--zoom', v);
            stage.classList.toggle('zoom-150', v === 1.5);
            stage.classList.toggle('zoom-100', v !== 1.5);
          }
        }catch(e){}
        requestAnimationFrame(updateOverlap);
      }
      // Global verfügbare Zoom-Funktion für Editor/Abschluss/Druck
      window.setGlobalZoom = setZoom;
      b100?.addEventListener('click', () => setZoom(1));
      b150?.addEventListener('click', () => setZoom(1.5));

      // 2) Umschalten, welche Karte oben liegt
      let frontOnTop = true;
      function toggleFrontBack(){
        frontOnTop = !frontOnTop;
        kb.classList.toggle('front-top', frontOnTop);
        kb.classList.toggle('back-top', !frontOnTop);

        // ensure no elevated z-index remains when switching faces
        document.getElementById('karte-vorderseite')?.classList.remove('hint-raise');
        document.getElementById('karte-rueckseite')?.classList.remove('hint-raise');
        // remove any visible hint bubble
        document.querySelectorAll('#karte-vorderseite .slot-hint').forEach(el => el.remove());

        // Feld 6 Schwebebutton: nur auf Vorderseite aktiv, sonst blockiert er Rückseitenfelder (z.B. Feld 15)
        try{
          var f6h = document.getElementById('f6-float-handle');
          if(f6h){
            if(frontOnTop){
              f6h.style.pointerEvents = 'auto';
            }else{
              f6h.style.pointerEvents = 'none';
            }
          }
        }catch(_){}
}
      bToggle?.addEventListener('click', toggleFrontBack);
      kb.classList.add('front-top'); // Startzustand: Vorderseite oben

      // 3) Überlappungsberechnung: zweite Karte nach links schieben, wenn eng
      function updateOverlap(){
        if (!kb || !cFront || !cBack || !lineal) return;
        // Rechtspuffer: 5mm + minimale Scrollbar-Reserve
        const rightPadding = 5; // px Sicherheitszuschlag zusätzlich zum CSS-Puffer
        const kbRect = kb.getBoundingClientRect();
        const w = kbRect.width - rightPadding;

        // reale Breiten
        const w1 = cFront.getBoundingClientRect().width;
        const w2 = cBack.getBoundingClientRect().width;
        const wL = lineal.offsetParent ? lineal.getBoundingClientRect().width : 0;
        const gap = parseFloat(getComputedStyle(kb).gap) || 0;

        const need = w1 + gap + w2 + gap + wL;
        if (need > w){
          kb.classList.add('tight');
          const overlap = Math.ceil(need - w);
          cBack.style.marginLeft = (-overlap) + 'px'; // schiebt Rückseite unter die Vorderseite
        } else {
          kb.classList.remove('tight');
          cBack.style.marginLeft = '';
        }
      }
      window.addEventListener('resize', updateOverlap);
      new ResizeObserver(updateOverlap).observe(kb);

      // Initial
      setZoom(1);
    })();
  </script>
<script>
(function(){
  const csvPath = (window.csvPath || 'https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/pflanzendaten.csv'); // served from same folder/server
  const input = document.getElementById('pflanzensuche');
  const anchor = document.getElementById('autocomplete-anchor');
  const toast = document.getElementById('nohit-toast');
  if(!input || !anchor) return;
  let entries = [];
  let menu = null;
  let activeIndex = -1;

  function normalize(s){
    return (s||'').toString().toLowerCase()
      .replace(/ä/g,'a').replace(/ö/g,'o').replace(/ü/g,'u').replace(/ß/g,'ss')
      .normalize('NFD').replace(/\p{Diacritic}+/gu,'');
  }
  function detectDelimiter(headerLine){
    const sc = (headerLine.match(/;/g)||[]).length;
    const cc = (headerLine.match(/,/g)||[]).length;
    return sc >= cc ? ';' : ',';
  }
  function parseCSV(text){
    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    if(lines.length === 0) return [];
    const delim = detectDelimiter(lines[0]);
    const headers = lines[0].split(delim).map(h => h.trim().replace(/^"|"$/g,''));
    const idx = headers.findIndex(h => normalize(h) === 'anzeigename');
    const out = [];
    for(let i=1;i<lines.length;i++){
      const row = lines[i].split(delim);
      const name = (row[idx]||'').trim().replace(/^"|"$/g,'');
      if(name) out.push(name);
    }
    return out;
  }

  function ensureMenu(){
    if(menu) return menu;
    menu = document.createElement('div');
    menu.className = 'ac-list';
    anchor.innerHTML = '';
    anchor.appendChild(menu);
    activeIndex = -1;
    return menu;
  }
  function hideMenu(){
    if(menu){ menu.remove(); menu = null; }
    activeIndex = -1;
  }
  function showToast(){
    if(toast){ toast.style.display = 'block'; }
  }
  function hideToast(){
    if(toast){ toast.style.display = 'none'; }
  }
  function render(items){
    if(items.length === 0){
      hideMenu();
      if(input.value.trim()!==''){ showToast(); }
      else { hideToast(); }
      return;
    }
    hideToast();
    const m = ensureMenu();
    m.innerHTML = '';
    items.forEach((t, i) => {
      const it = document.createElement('div');
      it.className='ac-item';
      it.textContent = t;
      it.addEventListener('mousedown', (e)=>{ e.preventDefault(); pick(i); });
      m.appendChild(it);
    });
    activeIndex = -1;
  }
  function pick(i){
    if(!menu) return;
    const item = menu.querySelectorAll('.ac-item')[i];
    if(!item) return;
    input.value = item.textContent;
    hideMenu(); hideToast();
    input.dispatchEvent(new Event('change'));
  }
  function highlight(){
    if(!menu) return;
    menu.querySelectorAll('.ac-item').forEach((el, idx)=>{
      el.classList.toggle('active', idx === activeIndex);
    });
  }
  function onKeydown(e){
    if(!menu) return;
    const items = menu.querySelectorAll('.ac-item');
    if(e.key === 'ArrowDown'){
      e.preventDefault();
      activeIndex = Math.min(items.length-1, activeIndex+1);
      highlight();
    }else if(e.key === 'ArrowUp'){
      e.preventDefault();
      activeIndex = Math.max(0, activeIndex-1);
      highlight();
    }else if(e.key === 'Enter'){
      if(activeIndex >= 0){
        e.preventDefault();
        pick(activeIndex);
      }
    }else if(e.key === 'Escape'){
      hideMenu(); hideToast();
    }
  }
  function onInput(){
    const q = normalize(input.value);
    if(!q){ hideMenu(); hideToast(); return; }
    const list = entries.filter(n => normalize(n).startsWith(q)).slice(0, 50);
    render(list);
  }

  // Load entries: prefer RB_DATA if ready, else CSV fallback
  function loadEntries(){
    try{
      if (window.RB_DATA && Array.isArray(window.RB_DATA.plants) && window.RB_DATA.plants.length){
        entries = window.RB_DATA.plants.map(function(p){ return (p && p.display) ? p.display : ''; }).filter(Boolean);
        return;
      }
    }catch(e){ /* ignore */ }
    fetch(csvPath, {cache:'no-cache'})
      .then(r => { if(!r.ok) throw new Error('CSV nicht gefunden: ' + csvPath); return r.text(); })
      .then(txt => { entries = parseCSV(txt); })
      .catch(err => console.warn('[Pflanzensuche] CSV-Fehler:', err));
  }
  loadEntries();
  // small retry to catch RB_DATA if it comes a bit later
  (function(){ var tries=0, t=setInterval(function(){
    if (window.RB_DATA && window.RB_DATA.plants && window.RB_DATA.plants.length){
      entries = window.RB_DATA.plants.map(function(p){ return (p && p.display) ? p.display : ''; }).filter(Boolean);
      clearInterval(t);
    } else if (++tries>40){ clearInterval(t); }
  }, 150); })();
// Events
  input.addEventListener('input', onInput);
  input.addEventListener('keydown', onKeydown);
  input.addEventListener('focus', onInput);
  input.addEventListener('blur', ()=> setTimeout(()=>{ hideMenu(); hideToast(); }, 120));
})();</script>
<script>
(function(){
  'use strict';
  // Scope elements
  const scope = document.getElementById('rb-scope');
  if(!scope) return; // if removed, bail
  const status = document.getElementById('rb-status');
  const boxesEl = document.getElementById('rb-boxes');
  const fileBoxes = document.getElementById('rb-file-boxes');
  const fileMaster= document.getElementById('rb-file-master');
  const dropdown = document.getElementById('rb-dropdown');
  const ddBody   = document.getElementById('rb-dd-body');
  const ddFoot   = document.getElementById('rb-dd-foot');
  const ddFree   = document.getElementById('rb-dd-free');
  // --- S06c: CSV-first hint adapter (fallback: STICKER_HINTS) ----------------
  // Access current CSV-derived hint text for a given column (if available).
  // `state.hintByCol` is assigned in renderBoxes() per colIndex.
  function setStatus(t){ if(status) status.innerHTML = t; }
  function norm(s){ return String(s||'').trim().toLowerCase(); }

  // ---------- CSV helpers ----------
  function normalizeNewlines(s){ return String(s||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n'); }
  function stripBOM(s){ return s && s.charCodeAt(0)===0xFEFF ? s.slice(1) : s; }
  function detectDelimGuess(line){
    const cand=[',',';','\t']; let best=',', bestN=-1;
    for(const d of cand){ const n=(line.match(new RegExp(d==='\\t'?'\\t':d,'g'))||[]).length; if(n>bestN){ bestN=n; best=d; } }
    return best;
  }
  function splitRow(row, delim){
    const out=[]; let cur='', inQ=false;
    for(let i=0;i<row.length;i++){
      const c=row[i];
      if(c === '"'){ if(inQ && row[i+1] === '"'){ cur+='"'; i++; continue; } inQ=!inQ; continue; }
      const isDelim = (delim === '\t' ? c === '\t' : c === delim);
      if(!inQ && isDelim){ out.push(cur); cur=''; continue; }
      cur += c;
    }
    out.push(cur);
    return out.map(s => s.trim());
  }

  // ---- Boxen-CSV: vollständiges Parsen (Header + Sortierung + Datenzeilen) ----
  function parseBoxesFull(text){
    const cleaned = stripBOM(normalizeNewlines(text));
    const raw = cleaned.split('\n');
    const lines = raw.filter(l => l.trim().length>0 && !/^sep\s*=\s*/i.test(l));
    const headerLine = lines[0] || '';
    const orderLine  = lines[1] || '';
    const delim = detectDelimGuess(headerLine || ',');
    const headers = headerLine ? splitRow(headerLine, delim) : [];
    const orders  = orderLine  ? splitRow(orderLine,  delim) : [];
    const rows = [];
    for(let i=2;i<lines.length;i++){
      rows.push(splitRow(lines[i], delim));
    }
    return { headers, orders, rows, delim };
  }

  // ---- Master-CSV: mit sep=-Filter, ab Zeile 12 (index 11) ----
  const master = { optionsByCol:new Map(), delim:',', headerNames:[], nameToCol:new Map() };
  function parseMaster(text){
    const cleaned = stripBOM(normalizeNewlines(text));
    const raw = cleaned.split('\n');
    const lines = raw.filter(l => l.trim().length>0 && !/^sep\s*=\s*/i.test(l));
    if(lines.length < 2){
      master.optionsByCol = new Map();
      master.headerNames = [];
      master.nameToCol = new Map();
      return;
    }
    const delim = detectDelimGuess(lines[0] || ',');
    const headerCells = splitRow(lines[0], delim);
    const headerNames = headerCells.slice(1).map(x => x);
    const nameToCol = new Map(headerNames.map((h,i)=>[norm(h), i+1]));
    const optionsByCol = new Map();
    for(let i=11; i<lines.length; i++){
      const row = splitRow(lines[i], delim);
      for(let c=1; c<row.length; c++){
        let v=(row[c]||'').trim();
        if(v==='-'||v==='–'||v==='—') v='';
        if(v){
          if(!optionsByCol.has(c)) optionsByCol.set(c,[]);
          optionsByCol.get(c).push(v);
        }
      }
    }
    master.optionsByCol = optionsByCol;
    master.delim = delim;
    master.headerNames = headerNames;
    master.nameToCol = nameToCol;
  }

  // ---- Drag & Drop helpers ----
  
function makeItemDraggable(el, txt){
  el.setAttribute('draggable','true');
  el.addEventListener('dragstart', (ev)=>{
    ev.dataTransfer.setData('text/plain', txt);
    ev.dataTransfer.effectAllowed = 'copy';
    if (window.__rbMakeDragGhost){
      var ghost = window.__rbMakeDragGhost(txt);
      if (ghost){
        ev.dataTransfer.setDragImage(ghost, Math.round(ghost.offsetWidth*0.5), Math.round(ghost.offsetHeight*0.5));
        setTimeout(function(){ try{ ghost.remove(); }catch(_){} }, 0);
      }
    }
  });
}

  
ddFree.addEventListener('dragstart', (ev)=>{
  const txt = ddFree.innerText.trim();
  ev.dataTransfer.setData('text/plain', txt);
  ev.dataTransfer.effectAllowed = 'copy';
  // Drag-Ghost exakt Feldbreite/Höhe
  if (window.__rbMakeDragGhost){
    var ghost = window.__rbMakeDragGhost(txt);
    if (ghost){
      ev.dataTransfer.setDragImage(ghost, Math.round(ghost.offsetWidth*0.5), Math.round(ghost.offsetHeight*0.5));
      setTimeout(function(){ try{ ghost.remove(); }catch(_){} }, 0);
    }
  }
});

  function enableDropTarget(rectEl){
    rectEl.addEventListener('dragover', (ev)=>{ ev.preventDefault(); ev.dataTransfer.dropEffect='copy'; rectEl.classList.add('droptarget--over'); });
    rectEl.addEventListener('dragleave', ()=> rectEl.classList.remove('droptarget--over'));
    rectEl.addEventListener('drop', (ev)=>{
      ev.preventDefault();
      rectEl.classList.remove('droptarget--over');
      const txt = ev.dataTransfer.getData('text/plain');
      if(txt){ rectEl.textContent = txt; }
      closeDropdown();
    });
  }

  // ---- UI: Dropdown (an das Auswahlfeld angeheftet) ----
  let currentTarget = null; // { el, colIndex, labelNorm }
  function getOptionsFor(colIndex, labelNorm){
    let list = master.optionsByCol.get(colIndex) || [];
    if(list.length===0 && labelNorm){
      const altCol = master.nameToCol.get(labelNorm);
      if(Number.isInteger(altCol)){
        list = master.optionsByCol.get(altCol) || [];
      }
    }
    return list;
  }

  function renderDropdownFor(colIndex, labelNorm){
    ddBody.innerHTML = '';
    ddFoot.style.display = 'none'; // Freitext-Feld nach Klick sichtbar

    const freitextItem = document.createElement('div');
    freitextItem.className = 'rb-dd-item';
    freitextItem.textContent = 'Freitext';
    freitextItem.style.cursor = 'pointer';
    freitextItem.addEventListener('click', ()=>{
      // Zeige Fuß und setze ihn direkt UNTER den 'Freitext'-Eintrag
      ddFoot.style.display='block';
      // Optik: keine Trennlinie oben
      try{ ddFoot.style.borderTop = '0'; }catch(e){}
      try{ ddFoot.style.margin = '0'; }catch(e){}
      try{ ddBody.insertBefore(ddFoot, freitextItem.nextSibling); }catch(e){}
      // Breite/Höhe sofort anpassen
      try{ if (typeof applyWidths === 'function') applyWidths(); }catch(e){}
      ddFree.focus();
    });
    ddBody.appendChild(freitextItem);

    const list = getOptionsFor(colIndex, labelNorm);
    if(!list.length){
      const emptyDiv = document.createElement('div');
      emptyDiv.className='rb-dd-item'; emptyDiv.style.cursor='default';
      emptyDiv.textContent = 'Keine Einträge für diesen Sticker.';
      ddBody.appendChild(emptyDiv);
      return;
    }
    const frag = document.createDocumentFragment();
    list.forEach(txt => {
      const div = document.createElement('div');
      div.className = 'rb-dd-item';
      div.textContent = txt;
      makeItemDraggable(div, txt);
      frag.appendChild(div);
    });
    ddBody.appendChild(frag);
  }

  function openDropdownFor(targetEl, colIndex, labelNorm){
    currentTarget = { el: targetEl, colIndex, labelNorm };
    renderDropdownFor(colIndex, labelNorm);
    ddFree.innerText='';

    function reposition(){
      if(!currentTarget){ return; }
      const r = currentTarget.el.getBoundingClientRect();
      if (r.bottom < 0 || r.top > window.innerHeight) { closeDropdown(); return; }
      const dw = dropdown.offsetWidth || 260;
      dropdown.style.left = Math.max(8, Math.min(window.innerWidth - dw - 8, r.left)) + 'px';
      dropdown.style.top  = (r.bottom + 6) + 'px';
    }
    window.__rb_reposition = reposition;
    window.addEventListener('scroll', window.__rb_reposition, { passive: true, capture: true });
    window.addEventListener('resize', window.__rb_reposition, { passive: true });
    reposition();

    dropdown.classList.add('open');
  }
  function closeDropdown(){
    dropdown.classList.remove('open');
    if (window.__rb_reposition){
      window.removeEventListener('scroll', window.__rb_reposition, { capture: true });
      window.removeEventListener('resize', window.__rb_reposition);
      window.__rb_reposition = null;
    }
    currentTarget = null;
  }
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeDropdown(); });
  document.addEventListener('click', (e)=>{
    if(!dropdown.contains(e.target) && !(e.target.classList && e.target.classList.contains('rb-box-rect'))){
      closeDropdown();
    }
  });

  // ---- State ----
  const state = { hintByLabel: new Map(), 
    boxes: [],           // [{lab, colIndex, ord, idx}]
    headers: [],
    rows: [],            // full csv rows starting at data (index 0 == original line 3)
    hintByCol: new Map(),
    rowByCol: new Map(),
    selectedPlant: null, // Anzeigename
  };

// === Sticker-Assets: Mapping von Box-Label -> SVG-Dateiname (aus ./… ) ===
const STICKER_BASE = '';
const STICKER_FILES = [];
const STICKER_SET = new Set(STICKER_FILES);

// Global verfügbar machen, damit andere Skripte denselben Basis-Pfad nutzen können.
if (typeof window !== 'undefined') {
  window.STICKER_BASE = STICKER_BASE;
}

function stickerNorm(s){
  s = String(s||'').trim().toLowerCase();
  s = s.replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/ß/g,'ss');
  s = s.replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
  return s;
}

// Basis-Heuristik: konkrete Zuordnungen kommen aus CSV/Overrides, nicht mehr aus hart codierten Synonymen.
function stickerFileFor(label){
  const key = stickerNorm(label);
  // PNG-only Symbol-Sticker: immer *_symbol.png
  const base = key.replace(/\.(svg|png)(\?.*)?$/i, '');
  const cands = [
    base + '_symbol.png',
    base.replace(/-/g,'_') + '_symbol.png',
    base.replace(/_/g,'-') + '_symbol.png'
  ];
  for (const c of cands){
    if (STICKER_SET.has(c)) return c;
  }
  return null;
}

// ---- Render Boxen + Hinweisboxen ----
  function renderBoxes(labelObjs){
    boxesEl.innerHTML='';
    state.hintByCol.clear();
    state.rowByCol.clear();

    labelObjs.forEach(obj => {
      const row = document.createElement('div');
      row.className = 'rb-row';

      const hint = document.createElement('div');
      hint.className = 'rb-hint';
      hint.textContent = ''; // wird beim Filtern gesetzt
      row.appendChild(hint);

      const box = document.createElement('div');
      box.className = 'rb-box';
      box.innerHTML = [
        '<div class="rb-icon" aria-hidden="true"></div>',
        '<div class="rb-box-inhalt">',
        '  <div class="rb-box-titel"></div>',
        '  <div class="rb-box-rect selectable" title="Klicken, dann Eintrag oder Freitext ziehen">Auswahl</div>',
        '</div>'
      ].join('');
      box.querySelector('.rb-box-titel').textContent = obj.lab;
      (function(){ const iconEl = box.querySelector('.rb-icon'); const f = stickerFileFor(obj.lab); if(iconEl){ iconEl.innerHTML = f ? ('<img alt="" src="'+STICKER_BASE+f+'">') : ''; } })();const sel = box.querySelector('.rb-box-rect');
      const labelNorm = norm(obj.lab);
      sel.addEventListener('click', ()=> openDropdownFor(sel, obj.colIndex, labelNorm));
      enableDropTarget(sel);

      row.appendChild(box);
      boxesEl.appendChild(row);

      state.hintByCol.set(obj.colIndex, hint);
      state.rowByCol.set(obj.colIndex, row);
    });
  }

  // ---- Orchestrierung ----
  function hydrateBoxes(text, origin){
    const parsed = parseBoxesFull(text);
    if(!parsed.headers.length){ setStatus('Boxen-CSV: keine Header.'); return; }
    state.headers = parsed.headers;
    state.rows = parsed.rows;

    const labels = parsed.headers.slice(1);
    const orderNums = parsed.orders.slice(1).map(v => { const m=String(v||'').match(/\d+/); return m?parseInt(m[0],10):NaN; });
    const objs = labels.map((lab,i)=>({ lab, colIndex: i+1, ord:Number.isFinite(orderNums[i])?orderNums[i]:(i+1), idx:i }));
    objs.sort((a,b)=> (a.ord-b.ord) || (a.idx-b.idx));
    state.boxes = objs;

    renderBoxes(objs);
    setStatus('Boxen geladen: '+objs.length + (state.selectedPlant? (' | aktiv: '+state.selectedPlant):''));
  }
  function hydrateMaster(text, origin){
    parseMaster(text);
    try{
      // Rebuild Boxen aus Master-Header + Ordnungszeile
      const cleanedM = stripBOM(normalizeNewlines(text));
      const rawM = cleanedM.split('\n');
      const linesM = rawM.filter(l => l.trim().length>0 && !/^sep\s*=\s*/i.test(l));
      if(linesM.length >= 2 && Array.isArray(state.headers) && state.headers.length){
        const delimM = detectDelimGuess(linesM[0] || ',');
        const headerCells = splitRow(linesM[0], delimM);
        const orderCells  = splitRow(linesM[1], delimM);
        const labels = headerCells.slice(1);
        const orderNums = orderCells.slice(1).map(v => { const m=String(v||'').match(/\d+/); return m?parseInt(m[0],10):NaN; });
        const nameToIdx = new Map(state.headers.map((h,i)=>[norm(h), i]));
        const objs = labels.map((lab,i)=>{
          const idx = nameToIdx.has(norm(lab)) ? nameToIdx.get(norm(lab)) : -1;
          return { lab, colIndex: idx, ord: Number.isFinite(orderNums[i])? orderNums[i] : (i+1), idx:i };
        });
        objs.sort((a,b)=> (a.ord-b.ord) || (a.idx-b.idx));
        state.boxes = objs;
        renderBoxes(objs);
      }
    }catch(_){}

    setStatus((status.textContent||'') + ' | Master: '+(master.optionsByCol.size)+' Spalten');
  }

  // ---- Filtern nach Pflanzenname (Anzeigename in Spalte A) ----
  function selectPlant(nameRaw){
    const name = String(nameRaw||'').trim();
    state.selectedPlant = name || null;

    if(!name){
      // nichts ausgewählt -> alle Boxen sichtbar, leere Hinweise
      state.boxes.forEach(obj => {
        const rowEl = state.rowByCol.get(obj.colIndex);
        const hintEl= state.hintByCol.get(obj.colIndex);
        if(rowEl){ rowEl.classList.remove('hidden'); }
        if(hintEl){ hintEl.textContent=''; }
      });
      setStatus('Alle Sticker sichtbar (keine Pflanze gewählt).');
      return;
    }

    // Zeile mit Anzeigename finden
    const header0 = state.headers[0] || '';
    const idxAnzeigename = 0; // Spalte A
    const targetRow = state.rows.find(r => norm(r[idxAnzeigename]) === norm(name));

    if(!targetRow){
      // keine Zeile gefunden -> alle ausblenden? Vorgabe: dann keine passende; ich lasse alle Boxen ausblenden um Verwirrung zu vermeiden
      state.boxes.forEach(obj => {
        const rowEl = state.rowByCol.get(obj.colIndex);
        const hintEl= state.hintByCol.get(obj.colIndex);
        if(rowEl){ rowEl.classList.add('hidden'); }
        if(hintEl){ hintEl.textContent=''; }
      });
      setStatus('Pflanze „'+name+'“ nicht in CSV gefunden.');
      return;
    }

    // Für jede Box: Spalte prüfen
    let visibleCount = 0;
    state.boxes.forEach(obj => {
      const val = (targetRow[obj.colIndex]||'').trim();
      const show = !!val;
      const rowEl = state.rowByCol.get(obj.colIndex);
      const hintEl= state.hintByCol.get(obj.colIndex);
      if(rowEl){
        rowEl.classList.toggle('hidden', !show);
      }
      if(hintEl){
        let out = show ? (val || '') : '';
        out = out.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        out = out.replace(/\[p\]/gi, '\n\n')
                 .replace(/\[br\]/gi, '\n')
                 .replace(/\\n/g, '\n');
        hintEl.textContent = out;
      }
      if(show) visibleCount++;
    });
    setStatus('Gefiltert auf „'+name+'“ · sichtbar: '+visibleCount+' Boxen.');
  }

  // Exponieren für die Suche
  window.rbSelectPlant = selectPlant;

  // ---- Fetch helpers ----
  function baseDir(){
    const url = new URL(window.location.href);
    const path = url.pathname;
    return path.slice(0, path.lastIndexOf('/') + 1);
  }
  async function fetchFirst(paths){
    let lastErr = null;
    for(const pth of paths){
      const url = /^https?:\/\//i.test(pth) ? pth : (pth.startsWith('/') ? pth : (baseDir() + pth));
      try{
        const res = await fetch(url, { cache: 'no-store' });
        if(res.ok){
          const text = await res.text();
          return { url, text };
        }else{
          lastErr = new Error(res.status + ' ' + res.statusText + ' @ ' + url);
        }
      }catch(e){
        lastErr = e;
      }
    }
    throw lastErr || new Error('Nicht gefunden: ' + paths.join(', '));
  }

  async function autoload(){
    // 1) Boxen-CSV
    try{
      setStatus('Lade Boxen …');
      const cand = [window.csvPath || 'https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/pflanzendaten.csv'];
      const { url, text } = await fetchFirst(cand);
      hydrateBoxes(text, 'auto: '+url);
    }catch(e){
      setStatus('Boxen-CSV fehlt. <span class="rb-link" id="rb-choose-boxes">Datei wählen</span>');
      document.getElementById('rb-choose-boxes')?.addEventListener('click', ()=> fileBoxes.click());
    }
    // 2) Master-CSV
    try{
      const candM = [window.masterPath || 'https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv'];
      const { url, text } = await fetchFirst(candM);
      hydrateMaster(text, 'auto: '+url);
    }catch(e){
      setStatus((status.textContent||'') + ' | Master fehlt. <span class="rb-link" id="rb-choose-master">Datei wählen</span>');
      document.getElementById('rb-choose-master')?.addEventListener('click', ()=> fileMaster.click());
    }
  }

  // File inputs as fallback
  fileBoxes.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; const r=new FileReader(); r.onload=ev=>{ hydrateBoxes(ev.target.result,'upload'); }; r.readAsText(f,'utf-8'); });
  fileMaster.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; const r=new FileReader(); r.onload=ev=>{ hydrateMaster(ev.target.result,'upload'); }; r.readAsText(f,'utf-8'); });

  // init
  autoload();
})();
</script>
<script>
(function(){
  'use strict';
  const col = document.getElementById('spalte-links');
  if(!col) return;
  function fitLeftColumn(){
    const r = col.getBoundingClientRect();
    // keep a small bottom margin to avoid scrollbar overlay on borders
    const h = Math.max(240, Math.floor(window.innerHeight - r.top - 16));
    col.style.maxHeight = h + 'px';
  }
  // initial + responsive
  window.addEventListener('load', fitLeftColumn, { once: false });
  window.addEventListener('resize', fitLeftColumn, { passive: true });
  // in case fonts/images shift layout after load
  setTimeout(fitLeftColumn, 0);
  setTimeout(fitLeftColumn, 100);
  setTimeout(fitLeftColumn, 500);
})();
</script>
<script>
(function(){
  'use strict';
  const left  = document.getElementById('spalte-links');
  const right = document.getElementById('spalte-rechts');
  if(!left || !right) return;

  function measureRightAt150(){
    // Clone right panel offscreen and force --zoom:1.5 to measure full height incl. buttons
    const clone = right.cloneNode(true);
    clone.style.position = 'fixed';
    clone.style.left = '-10000px';
    clone.style.top = '0';
    clone.style.visibility = 'hidden';
    clone.style.setProperty('--zoom', 1.5); // force 150% for measurement

    // Add spacer equivalent to the ::after(72px) if present in original CSS
    const spacer = document.createElement('div');
    spacer.style.height = '180px';
    clone.appendChild(spacer);

    document.body.appendChild(clone);
    // getBoundingClientRect includes borders
    const h = Math.ceil(clone.getBoundingClientRect().height);
    document.body.removeChild(clone);
    return h;
  }

  function applyEqualHeights(){
    const target = Math.max(measureRightAt150(), 1070); // Mindesthöhe 1070px, alles darunter wird angehoben
    if(!target || !isFinite(target)) return;

    // Left: make the panel itself fixed height & scroll its content
    left.style.maxHeight = 'none';     // override previous max-height limit
    left.style.height = target + 'px'; // equal frame height
    left.style.overflowY = 'auto';     // internal scroll remains

    // Right: equal visual frame height (content fits at 150%)
    right.style.minHeight = target + 'px';
    right.style.height = target + 'px';
  }

  window.addEventListener('load', applyEqualHeights, { once: false });
  window.addEventListener('resize', applyEqualHeights, { passive: true });

  // run additionally after a short delay to catch late layout shifts
  setTimeout(applyEqualHeights, 0);
  setTimeout(applyEqualHeights, 200);
  setTimeout(applyEqualHeights, 800);
})();
</script>
<script>
(function(){
  'use strict';
  const input = document.getElementById('pflanzensuche');
  const nameSpan = document.getElementById('rb-plantname');
  const toast = document.getElementById('nohit-toast');

  function visibleRowsExist(){
    const rows = document.querySelectorAll('.rb-row');
    for(const r of rows){ if (r.offsetParent !== null) return true; }
    return false;
  }

  
function choosePlant(nameRaw){
    const name = String(nameRaw||'').trim();

    // Karte vor jedem Pflanzenwechsel komplett leeren,
    // damit keine alten Inhalte zur neuen Pflanze passen.
    try{
      var btnClear = document.getElementById('btn-leeren');
      if(btnClear) btnClear.click();
    }catch(e){}

    if(nameSpan){ nameSpan.textContent = name || '–'; }
    if(typeof window.rbSelectPlant === 'function'){
      window.rbSelectPlant(name);
    }
    // show/hide "not found" toast under search
    if(toast){
      // defer a tick so filtering has applied
      setTimeout(()=>{
        toast.style.display = name && !visibleRowsExist() ? 'block' : 'none';
      }, 0);
    }
  }


  // Delegate clicks on autocomplete items
  document.addEventListener('click', (e)=>{
    const it = e.target.closest('.ac-item');
    if(it){ choosePlant(it.textContent); }
  });

  // Enter key on the search input
  if(input){
    input.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){ choosePlant(input.value); }
    });
  }

  // Expose for other UI buttons if needed
  window.choosePlantFromSearch = choosePlant;
})();
</script>
<script>
// Nach Auswahl: Wert ins Suchfeld schreiben, Menü schließen, Eingabefeld verlassen
(function(){
  'use strict';
  function closeAC(){
    try{
      document.querySelectorAll('.ac-list').forEach(el=>el.remove());
      const anc = document.getElementById('autocomplete-anchor');
      if(anc) anc.innerHTML = '';
    }catch{}
    const inp = document.getElementById('pflanzensuche');
    if(inp) setTimeout(()=> inp.blur(), 0);
  }
  function selectAndClose(text){
    const t = (text||'').trim();
    const inp = document.getElementById('pflanzensuche');
    if(inp) inp.value = t;
    if (window.choosePlantFromSearch) {
      window.choosePlantFromSearch(t);
    } else if (window.rbSelectPlant) {
      window.rbSelectPlant(t);
      try{
        const span = document.getElementById('rb-plantname');
        if(span) span.textContent = t || '–';
      }catch{}
    }
    closeAC();
  }

  // Enter im Eingabefeld: filtern + Menü schließen
  const input = document.getElementById('pflanzensuche');
  if(input){
    input.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter'){
        selectAndClose(input.value);
      }
    });
  }

  // Vorschlagsklick (pointerdown im Capture) wie gehabt, plus Menü schließen
  function onPick(ev){
    const it = ev.target.closest && ev.target.closest('.ac-item');
    if(!it) return;
    ev.preventDefault();
    selectAndClose(it.textContent);
  }
  document.addEventListener('pointerdown', onPick, true);
})();
</script>
<script>
// DnD Empfang für Sticker-Felder (Front & Back)
function empfangeSticker(event, feldId){
  event.preventDefault();
  const raw = event.dataTransfer.getData("text/plain");
  if (!raw) return;

  let payload = null, stickerUrl = null;
  try { payload = JSON.parse(raw); } catch {}

  if (payload && payload.type === "sticker" && payload.url) {
    stickerUrl = payload.url;
  } else {
    stickerUrl = raw;
  }

  // Pfad auf bereinigte Symbole (nur wenn noch nicht dort)
  if (typeof stickerUrl === 'string') {
    if (stickerUrl.indexOf('bereinigte_symbole_3_in_1/') === -1) {
      stickerUrl = stickerUrl.replace('', '');
    }
  }

  const zielFeld = document.getElementById(feldId);
  if (!zielFeld) return;

  // zuvor gesetzten Sticker entfernen
  zielFeld.innerHTML = '';

  // Bild einsetzen (object-fit:contain hält Innenkontur ein) + definierter Abstand
  const img = document.createElement('img');
  img.src = stickerUrl;
  img.alt = '';
  img.style.position = 'absolute';
  // Standard: bündig
  let leftOff = '0', topOff = '0', wCalc = '100%', hCalc = '100%';
  // Slotnummer aus feldId ableiten
  const slotNumForInset = parseInt(String(feldId).replace(/\D+/g,''), 10);
  // Frontfelder 2–5: 0,5 mm | Rückseite 8–16: 0,4 mm
  let gapMmLocal = 0;
  if (slotNumForInset >= 2 && slotNumForInset <= 5) gapMmLocal = 0.5;
  if (slotNumForInset >= 8 && slotNumForInset <= 16) gapMmLocal = 0.35;
  if (gapMmLocal > 0){
    const gapPx = gapMmLocal/25.4*96; // 96dpi in px
    leftOff = 'calc(' + gapPx + 'px * var(--zoom))';
    topOff  = leftOff;
    const shrink = 'calc(100% - ' + (gapPx*2) + 'px * var(--zoom))';
    wCalc = shrink; hCalc = shrink;
  }
  img.style.left = leftOff;
  img.style.top  = topOff;
  img.style.width  = wCalc;
  img.style.height = hCalc;
  img.style.objectFit = 'contain';
  zielFeld.appendChild(img);
  // --- Rückseiten-Hinweis (nur F8–F16), manuell wegklickbar ---
  try {
    const slotNum = parseInt(String(feldId).replace(/\D+/g,''), 10);
    const isBackSide = slotNum >= 8 && slotNum <= 16;
    if (isBackSide) {
      function normKey(s){
        s = String(s||'').trim().toLowerCase();
        s = s.replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/ß/g,'ss');
        // _symbol vor der Dateiendung entfernen, falls vorhanden
        s = s.replace(/_symbol(?=\.[a-z0-9]+$)/, '');
        s = s.replace(/\.[a-z0-9]+$/, '');
        s = s.replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
        return s;
      }
      let stickerKey = '';
      if (payload && payload.label) {
        stickerKey = normKey(payload.label);
      } else if (stickerUrl) {
        const bn = String(stickerUrl).split('?')[0].split(/[\/\\]/).pop();
        stickerKey = normKey(bn);
      }

      const H = (window.STICKER_HINTS && typeof window.STICKER_HINTS === 'object') ? window.STICKER_HINTS : {};
      const entry = H[stickerKey];
      if (entry && String(entry.warn) === '1') {
        // vorhandene Hinweise auf der Rückseite komplett entfernen (Guard gegen doppelte Erstellung)
        try{
          document.querySelectorAll('#karte-rueckseite .slot-hint').forEach(function(el){ el.remove(); });
        }catch(_){}

        const hint = document.createElement('div');
        hint.className = 'slot-hint';

        const __kFig = document.getElementById('karte-rueckseite'); if(__kFig){ __kFig.classList.add('hint-raise'); }
const close = document.createElement('span');
        close.className = 'slot-hint-close';
        close.textContent = '×';
        close.title = 'Hinweis ausblenden';
        close.addEventListener('click', ()=> { hint.remove(); const __k=document.getElementById('karte-rueckseite'); if(__k){ __k.classList.remove('hint-raise'); } });

        const title = document.createElement('span');
        title.className = 'slot-hint-title';
        title.textContent = 'Dieser Sticker ist für die Rückseite eher ungeeignet.';

        const alt = document.createElement('div');
        alt.className = 'slot-hint-alt';
        if (entry.alt) alt.textContent = entry.alt;

        hint.appendChild(close);
        hint.appendChild(title);
        if (entry.alt) hint.appendChild(alt);

        zielFeld.appendChild(hint);
      }
    }
  } catch(e){ console.warn('Hint-Check failed:', e); }
}
</script>
<script>// === "Karte leeren": alle Karten-Felder 1–25 leeren (Sticker, Text, Icons) ===
// Suche + aktueller Filter bleiben unverändert.
(function(){
  const btn = document.getElementById('btn-leeren');
  if (!btn) return;

  function clearAllCardFields(){
    // Feld 1 leeren
    (function(){ var _f1 = document.getElementById('feld1NameAnzeige'); if (_f1) _f1.textContent = ''; })();

    // 1) Alle Slots feld1..feld25 (wenn vorhanden) komplett leeren
    for (let i = 1; i <= 25; i++) {
      const el = document.getElementById('feld' + i);
      if (el) el.innerHTML = '';
    }

    // 2) Hinweis-Pillen an Slots (Rückseite) entfernen
    document.querySelectorAll('#karte-rueckseite .slot-hint').forEach(n => n.remove());
    var fig = document.getElementById('karte-rueckseite'); if (fig) fig.classList.remove('hint-raise');
    // 3) Falls Textkapseln mit data-slot existieren
    document.querySelectorAll('.karte-overlay [data-slot]').forEach(n => { n.textContent = ''; });

    // 4) Spruch & Smiley zurücksetzen
    const spruch = document.getElementById('spruchSelect');  if (spruch)  spruch.selectedIndex = 0;
    const smiley = document.getElementById('smileySelect');  if (smiley)  smiley.selectedIndex = 0;

    // 5) Feld 6 & 7 Anzeigen leeren
    var _spr = document.getElementById('spruchAnzeige'); if (_spr) _spr.textContent = '';
    var _sym = document.getElementById('symbolAnzeige'); if (_sym) _sym.textContent = '';
  }

  btn.addEventListener('click', clearAllCardFields);
})();</script>
<script>
// === Feld 6 & 7 aktivieren: nutzt bestehende #spruchSelect und #smileySelect ===
(function(){
  function normalizeSpruch(text){
    // '/' als Zeilenumbruch behandeln (wie Vergleichsdatei)
    return String(text || '').replace(/\s*\/\s*/g, '\n');
  }
  function updateSpruch(){
    var sel = document.getElementById('spruchSelect');
    var out = document.getElementById('spruchAnzeige');
    if (!sel || !out) return;
    var t = sel.value || sel.options[sel.selectedIndex]?.text || '';
    if (/kein Spruch/i.test(t) || t.trim() === '–' || t.trim() === '') {
      out.textContent = '';
    } else {
      out.textContent = normalizeSpruch(t.trim());
    }
  }
  function updateSmiley(){
    var sel = document.getElementById('smileySelect');
    var out = document.getElementById('symbolAnzeige');
    if (!sel || !out) return;
    var t = sel.value || sel.options[sel.selectedIndex]?.text || '';
    if (t.trim() === '–' || t.trim() === '') {
      out.textContent = '';
    } else {
      // Im Vergleich sind teils SVGs – hier bewusst Zeichen/Emoji wie in deiner Datei
      out.textContent = t.trim();
    }
  }
  // Events binden
  function bind(){
    var s1 = document.getElementById('spruchSelect');
    var s2 = document.getElementById('smileySelect');
    if (s1 && !s1.__f67Bound){
      s1.addEventListener('change', updateSpruch);
      s1.__f67Bound = true;
    }
    if (s2 && !s2.__f67Bound){
      s2.addEventListener('change', updateSmiley);
      s2.__f67Bound = true;
    }
    // Initial anzeigen
    updateSpruch();
    updateSmiley();
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }
})();
</script>
<script>
// === Filter-Buttons aktivieren ===
// "Zeige alle Sticker": Filter aus -> alle roten Boxen sichtbar
// "Zeige nur passende Sticker": nach aktueller Pflanze filtern; wenn keine gesetzt -> alle Boxen
(function(){
  var btnAll = document.getElementById('btn-alle-sticker');
  var btnFit = document.getElementById('btn-passende-sticker');
  var nameSpan = document.getElementById('rb-plantname');

  function showAll(){
    try{
      if (typeof window.rbFilterRedBoxes === 'function') window.rbFilterRedBoxes('all');
    }catch(e){}
    var toast = document.getElementById('nohit-toast'); if (toast) toast.style.display = 'none';
  }

  function filterForCurrentPlant(){
    var name = (nameSpan && nameSpan.textContent ? nameSpan.textContent : '').trim();
    if (!name || name === '–'){
      showAll();
      return;
    }
    try{
      if (typeof window.rbFilterRedBoxes === 'function') window.rbFilterRedBoxes(name);
      if (typeof window.updateCareHints === 'function') window.updateCareHints(name);
    }catch(e){}
    var toast = document.getElementById('nohit-toast'); if (toast) toast.style.display = 'none';
  }

  if (btnAll && !btnAll.__filterBound){
    btnAll.addEventListener('click', showAll);
    btnAll.__filterBound = true;
  }
  if (btnFit && !btnFit.__filterBound){
    btnFit.addEventListener('click', filterForCurrentPlant);
    btnFit.__filterBound = true;
  }
})();
</script>
<script>

(function(){
  function setFeld1Text(t){
    var el = document.getElementById('feld1NameAnzeige');
    if (!el) return;
    el.textContent = String(t||'').trim();
  }

  // a) Auto-Übernahme bei Auswahl aus der Pflanzensuche
  try {
    var __oldChoose = window.choosePlantFromSearch;
    window.choosePlantFromSearch = function(name){
      try { if (typeof __oldChoose === 'function') __oldChoose(name); } catch(_){}
      setFeld1Text(name);
    };
  } catch(_){}

  // b) Buttons
  var btnName = document.getElementById('btn-uebernehmen-name');
  var btnKose = document.getElementById('btn-kosename');
  var btnKoseSet = document.getElementById('btn-uebernehmen-kosename');
  var input = document.getElementById('pflanzensuche');
  var _kosename = '';

  if (btnName && !btnName.__f1){
    btnName.addEventListener('click', function(){
      var n = (input && input.value || '').trim();
      if (n) setFeld1Text(n);
    });
    btnName.__f1 = true;
  }

  if (btnKose && !btnKose.__f1){
    btnKose.addEventListener('click', function(){
      var v = prompt('Kosename eingeben:', _kosename || '');
      if (v != null) _kosename = String(v).trim();
    });
    btnKose.__f1 = true;
  }

  if (btnKoseSet && !btnKoseSet.__f1){
    btnKoseSet.addEventListener('click', function(){
      if (!_kosename){
        var v = prompt('Kosename eingeben:', '');
        if (v == null) return;
        _kosename = String(v).trim();
      }
      setFeld1Text(_kosename);
    });
    btnKoseSet.__f1 = true;
  }
})();
</script>
<script>

(function(){
  var btnKosename = document.getElementById('btn-kosename');
  if (btnKosename && !btnKosename.__replaced) {
    // Eingabefeld erstellen
    var inp = document.createElement('input');
    inp.type = 'text';
    inp.id = 'kosenameInput';
    inp.placeholder = 'Kosename eingeben…';
    inp.setAttribute('aria-label', 'Kosename');
    // gleiche Optik wie andere Inputs in der Steuerleiste
    inp.style.padding = '8px 10px';
    inp.style.border = '1px solid #bbb';
    inp.style.borderRadius = '6px';
    inp.style.minWidth = '240px';

    // Button ausblenden und Input davor einfügen
    var parent = btnKosename.parentNode;
    parent.insertBefore(inp, btnKosename);
    btnKosename.style.display = 'none';
    btnKosename.__replaced = true;

    
    inp.addEventListener('keydown', function(e){
      if (e.key === 'Enter') {
        var v = (inp.value || '').trim();
        if (v) {
          var el = document.getElementById('feld1NameAnzeige');
          if (el) el.textContent = v;
        }
      }
    });

    
    var btnSet = document.getElementById('btn-uebernehmen-kosename');
    if (btnSet && !btnSet.__boundKosenameSet){
      btnSet.addEventListener('click', function(){
        var v = (inp.value || '').trim();
        if (!v) return;
        var el = document.getElementById('feld1NameAnzeige');
        if (el) el.textContent = v;
      });
      btnSet.__boundKosenameSet = true;
    }
  }
})();
</script>
<script>

(function(){
  // 1) Sicherstellen, dass es ein Eingabefeld gibt (falls nicht, eins anlegen und den alten Button verstecken)
  var inp = document.getElementById('kosenameInput');
  var btnKosename = document.getElementById('btn-kosename');
  if (!inp && btnKosename) {
    inp = document.createElement('input');
    inp.type = 'text';
    inp.id = 'kosenameInput';
    inp.placeholder = 'Kosename eingeben…';
    inp.setAttribute('aria-label', 'Kosename');
    inp.style.padding = '8px 10px';
    inp.style.border = '1px solid #bbb';
    inp.style.borderRadius = '6px';
    inp.style.minWidth = '240px';
    btnKosename.parentNode.insertBefore(inp, btnKosename);
    btnKosename.style.display = 'none';
  }

  
  var btnSet = document.getElementById('btn-uebernehmen-kosename');
  if (btnSet && !btnSet.__clonedNoPrompt){
    var clone = btnSet.cloneNode(true);
    btnSet.parentNode.replaceChild(clone, btnSet);
    btnSet = clone;
    btnSet.__clonedNoPrompt = true;
  }

  // 3) Neues, sauberes Verhalten ohne prompt()
  if (btnSet && !btnSet.__boundNoPrompt){
    btnSet.addEventListener('click', function(){
      var v = (inp && inp.value || '').trim();
      var f1 = document.getElementById('feld1NameAnzeige');
      if (f1) f1.textContent = v;
    });
    btnSet.__boundNoPrompt = true;
  }

  // 4) Enter im Eingabefeld setzt ebenfalls Feld 1 (kein Prompt)
  if (inp && !inp.__enterBoundNoPrompt){
    inp.addEventListener('keydown', function(e){
      if (e.key === 'Enter') {
        var v = (inp.value || '').trim();
        var f1 = document.getElementById('feld1NameAnzeige');
        if (f1) f1.textContent = v;
      }
    });
    inp.__enterBoundNoPrompt = true;
  }
})();
</script>
<script>
// === Filter-Korrektur: folgt IMMER dem Text im Suchfeld ===
// - "Alle Sticker": zeigt alle Boxen, ABER behält Hinweise zur Pflanze im Suchfeld (wenn bekannt).
// - "Nur passende": filtert; wenn leer/unknown -> alle Boxen (ohne Hinweise).
(function(){
  var btnAll = document.getElementById('btn-alle-sticker');
  var btnFit = document.getElementById('btn-passende-sticker');
  var input  = document.getElementById('pflanzensuche');
  var nameSpan = document.getElementById('rb-plantname');

  function visibleRowsExist(){
    var rows = document.querySelectorAll('.rb-row');
    for (var i=0; i<rows.length; i++){
      if (!rows[i].classList.contains('hidden')) return true;
    }
    return false;
  }
  function unhideAll(){
    document.querySelectorAll('.rb-row').forEach(function(r){ r.classList.remove('hidden'); });
  }
  function clearHints(){
    document.querySelectorAll('#rb-boxes .rb-hint').forEach(function(h){ h.textContent=''; });
  }

  function showAllWithHintsIfAny(){
    var name = (input && input.value || '').trim();
    if (name){
      // erst filtern -> dadurch werden Hinweise gesetzt
      try { if (typeof window.rbSelectPlant === 'function') window.rbSelectPlant(name); } catch(_){}
      var hadVisible = visibleRowsExist();
      // danach ALLE Boxen anzeigen, Hinweise bleiben stehen
      unhideAll();
      if (nameSpan) nameSpan.textContent = name;
      // wenn unbekannt -> keine Hinweise
      if (!hadVisible){ clearHints(); }
    }else{
      // kein Name -> alle Boxen, keine Hinweise
      unhideAll(); clearHints();
      if (nameSpan) nameSpan.textContent = '–';
    }
    var toast = document.getElementById('nohit-toast'); if (toast) toast.style.display='none';
  }

  function showOnlyMatchingOrAll(){
    var name = (input && input.value || '').trim();
    if (!name){
      unhideAll(); clearHints();
      if (nameSpan) nameSpan.textContent = '–';
      return;
    }
    try { if (typeof window.rbSelectPlant === 'function') window.rbSelectPlant(name); } catch(_){}
    if (nameSpan) nameSpan.textContent = name;
    // unbekannt? -> sofort wieder alle (ohne Hinweise)
    setTimeout(function(){
      if (!visibleRowsExist()){ unhideAll(); clearHints(); }
    }, 0);
  }

  function replaceButton(btn, handler){
    if (!btn) return;
    var clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('click', handler);
  }

  replaceButton(btnAll, showAllWithHintsIfAny);
  replaceButton(btnFit, showOnlyMatchingOrAll);
})();
</script>
<script>
// === Ergänzung: "Karte leeren" löscht jetzt auch Feld 1 (Name-Anzeige) ===
(function(){
  var btn = document.getElementById('btn-leeren');
  if (!btn) return;
  function clearField1(){
    var f1 = document.getElementById('feld1NameAnzeige');
    if (f1) f1.textContent = '';
  }
  // eigener Listener zusätzlich zum bestehenden Clear-Handler
  if (!btn.__clearF1Bound){
    btn.addEventListener('click', clearField1);
    btn.__clearF1Bound = true;
  }
})();
</script>
<script>

(function(){
  var btn = document.getElementById('btn-leeren');
  if (!btn) return;

  

  if (!btn.__clearInputsBound){
    if (typeof clearSearchAndKosename === 'function') { btn.addEventListener('click', clearSearchAndKosename); }
    btn.__clearInputsBound = true;
  }
})();
</script>
<script>
// === "Karte leeren" = kompletter Ausgangspunkt ============================
(function(){
  var btn = document.getElementById('btn-leeren');
  if (!btn) return;

  


  // Alte Handler neutralisieren, damit nur noch resetToStart läuft
  var clone = btn.cloneNode(true);
  btn.parentNode.replaceChild(clone, btn);
  if (typeof resetToStart === 'function') { clone.addEventListener('click', resetToStart); }
})();
</script>
<script>
// === Freitext-Drag: rb-dd-free sicher als Dragquelle aktivieren ===
(function(){
  function ensureFreitextDraggable(){
    var free = document.getElementById('rb-dd-free');
    if (!free) return;
    if (!free.getAttribute('draggable')) free.setAttribute('draggable','true');
    if (!free.__dragBound){
      free.addEventListener('dragstart', function(ev){
        try {
          var t = (free.innerText || free.textContent || '').trim();
          // Falls leer: nichts übertragen
          if (!t) return;
          ev.dataTransfer.setData('text/plain', t);
          ev.dataTransfer.effectAllowed = 'copy';
        } catch(_){}
      });
      free.__dragBound = true;
    }
  }
  // bei erstmaligem Öffnen des Dropdowns wird rb-dd-free sichtbar; daher immer wieder prüfen
  document.addEventListener('click', function(e){
    // wenn ein Dropdown-Item "Freitext" geklickt wurde oder Dropdown geöffnet wurde
    ensureFreitextDraggable();
  }, true);
  // auch beim Laden einmal versuchen
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureFreitextDraggable);
  } else {
    ensureFreitextDraggable();
  }
})();

// === Drop-Handler robust: akzeptiert Freitext aus rb-dd-free und list items ===
(function(){
  // Ersetze vorhandene empfangeText-Definition durch eine robustere Variante/* STEP17E_MARK: window.empfangeText = function(...) – Kandidat, noch nicht geändert */

  window.empfangeText = function(event, feldId){
    event.preventDefault();
    var data = '';
    try { data = event.dataTransfer.getData('text/plain'); } catch(_){}
    if (!data){
      try {
        var html = event.dataTransfer.getData('text/html') || '';
        if (html){
          // grob HTML-Tags entfernen
          data = html.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
        }
      } catch(_){}
    }
    var txt = (data || '').trim();
    if (!txt) return;

    var el = document.getElementById(feldId);
    if (!el) return;

    el.innerHTML = '';
    };
})();
</script>
<script>
// === Freitext-Drag (robust): eigener Zieh-Griff + sicheres dragstart am Contenteditable ===
(function(){
  function currentFreeText(){
    var free = document.getElementById('rb-dd-free');
    return (free && (free.innerText || free.textContent) || '').trim();
  }

  function ensureDragOnFree(){
    var free = document.getElementById('rb-dd-free');
    if (!free) return;
    if (!free.getAttribute('draggable')) free.setAttribute('draggable','true');
    if (!free.__dragBoundFix){
      free.addEventListener('dragstart', function(ev){
        var t = currentFreeText();
        if (!t){ ev.preventDefault(); return; }
        try{
          ev.dataTransfer.setData('text/plain', t);
          ev.dataTransfer.effectAllowed = 'copy';
        }catch(_){}
      });
      // Verhindere, dass der Browser versuch macht, nur die Auswahl zu ziehen
      free.addEventListener('mousedown', function(){
        // keine Auswahl erzwingen
        try{ getSelection().removeAllRanges(); }catch(_){}
      });
      free.__dragBoundFix = true;
    }
  }

  function ensureHandle(){
    var foot = document.getElementById('rb-dd-foot');
    if (!foot) return;
    if (!foot.__handleBuilt){
      var pill = document.createElement('div');
      pill.id = 'rb-dd-free-handle';
      pill.className = 'rb-dd-item';
      pill.setAttribute('draggable','true');
      pill.style.cursor = 'grab';
      pill.style.userSelect = 'none';
      pill.style.display = 'none'; // erst anzeigen, wenn Text vorhanden ist
      foot.appendChild(pill);

      // dragstart vom Griff
      pill.addEventListener('dragstart', function(ev){
        var t = currentFreeText();
        if (!t){ ev.preventDefault(); return; }
        try{
          ev.dataTransfer.setData('text/plain', t);
          ev.dataTransfer.effectAllowed = 'copy';
        }catch(_){}
      });

      // Textspiegelung: sobald im Freitext was steht, zeige Griff an
      var free = document.getElementById('rb-dd-free');
      function mirror(){
        var t = currentFreeText();
        pill.textContent = t || ' ';
        pill.style.display = t ? 'block' : 'none';
      }
      if (free){
        ['input','keyup','keydown','paste','blur','focus'].forEach(function(ev){
          free.addEventListener(ev, mirror);
        });
        mirror();
      }
      foot.__handleBuilt = true;
    }
  }

  // Beobachte, wenn das Dropdown-Fußteil eingeblendet wird, dann einrichten
  function setup(){
    ensureDragOnFree();
    ensureHandle();
  }

  // Einmal direkt, falls schon offen
  setup();

  // Bei jedem Klick (Öffnen/Klicken im Dropdown) versuchen wir erneut
  document.addEventListener('click', function(e){
    setup();
  }, true);

  // Mutationsbeobachter: falls dd-foot ein/ausgeblendet wird
  var foot = document.getElementById('rb-dd-foot');
  if (foot && !foot.__moBound){
    var mo = new MutationObserver(setup);
    mo.observe(foot, { attributes:true, childList:true, subtree:true });
    foot.__moBound = true;
  }

  // Auch nach DOM ready nochmal
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
</script>
<script>
// Zeige einen Hinweis, wenn der Freitext aus seiner Zeile läuft
(function(){
  function ensureHint(){
    var foot = document.getElementById('rb-dd-foot');
    if (!foot) return null;
    var hint = document.getElementById('rb-dd-free-hint');
    if (!hint){
      hint = document.createElement('div');
      hint.id = 'rb-dd-free-hint';
      hint.textContent = 'Überprüfe ob dein Text wirklich noch ins Feld passt, so das es für dich okay ist.';
      foot.appendChild(hint);
    }
    return hint;
  }
  function isOverflow(el){
  try{
    if (!el) return false;
    var inner = el.querySelector('[contenteditable="true"]') || el;
    var t = (inner.textContent || '').replace(/\u00A0/g,' ').trim();
    return t.length >= 18; // Hinweis ab dem 15. Zeichen
  }catch(_){ return false; }
}
function bind(){
    var free = document.getElementById('rb-dd-free');
    var hint = ensureHint();
    if (!free || !hint) return;
    function update(){
      hint.style.display = isOverflow(free) ? 'block' : 'none';
    }
    if (!free.__hintBound){
      ['input','keyup','keydown','paste','change','blur','focus'].forEach(function(ev){
        free.addEventListener(ev, update);
      });
      free.__hintBound = true;
    }
    update();
  }
  // beim Öffnen des Dropdowns (Klick auf Auswahl) erneut binden
  document.addEventListener('click', function(){ setTimeout(bind, 0); }, true);
  // initial
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }
})();
</script>
<script>
// Match dropdown width AND the white Auswahl-Kapseln to the actual width of fields 17–25
(function(){
  function measureBackTextWidth(){
    var ids = ['feld17','feld18','feld19','feld20','feld21','feld22','feld23','feld24','feld25'];
    for (var i=0;i<ids.length;i++){
      var el = document.getElementById(ids[i]);
      if (el){
        var r = el.getBoundingClientRect();
        if (r && r.width > 40) return Math.round(r.width);
      }
    }
    return null;
  }
  function applyWidths(){
    var w = measureBackTextWidth();
    if (!w) return;
    // Dropdown
    var dd = document.getElementById('rb-dropdown');
    if (dd){
      dd.style.width = w + 'px';
      dd.style.maxWidth = w + 'px';
    }
    // "Auswahl"-Kapseln in den roten Boxen angleichen
    try {
      document.querySelectorAll('.rb-row .rb-box-rect').forEach(function(el){
        el.style.width = w + 'px';
      });
    } catch(_){}
  }
  // When dropdown opens/closes, when window resizes, and after load
  var dd = document.getElementById('rb-dropdown');
  if (dd){
    new MutationObserver(applyWidths).observe(dd, { attributes:true, attributeFilter:['class'] });
  }
  window.addEventListener('resize', applyWidths);
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyWidths);
  } else {
    applyWidths();
  }
  // Also re-apply shortly after any click (covers zoom toggle etc.)
  document.addEventListener('click', function(){ setTimeout(applyWidths, 0); }, true);
})();
</script>
<script id="rb-drag-ghost-helper">
(function(){
  function makeDragGhost(text){
    try{
      var dims = (window.__rbFieldDims || {w:160, h:28});
      var g = document.createElement('div');
      g.className = 'rb-drag-ghost';
      g.style.position = 'fixed';
      g.style.left = '-10000px';
      g.style.top  = '-10000px';
      g.style.width  = dims.w + 'px';      /* exakt Kartenfeldbreite */
      g.style.height = dims.h + 'px';      /* exakt Kartenfeldhöhe  */
      g.style.background = '#e9eef6';
      g.style.border = '1px solid #000';
      g.style.borderRadius = '6px';
      g.style.boxSizing = 'border-box';
      g.style.display = 'flex';
      g.style.alignItems = 'center';
      g.style.justifyContent = 'center';
      g.style.padding = '0 8px';
      g.style.fontFamily = '"Playfair Display", serif';
      g.style.fontWeight = '700';
      g.style.fontSize = Math.max(11, Math.round(dims.h*0.45)) + 'px';
      g.style.lineHeight = '1';
      g.style.color = '#000';
      g.textContent = (text||'').trim();
      document.body.appendChild(g);
      return g;
    }catch(_){ return null; }
  }
  window.__rbMakeDragGhost = makeDragGhost;
})();
</script>
<style data-group="other" id="rb-usage-style">
/* Box-Status: wenn Elemente aus einer Box auf der Karte liegen */
#rb-boxes .rb-box.rb-used{
  background-color: #e05a50; /* leicht abgesetztes Rot, gut sichtbar */
}
</style>
<script>
(function(){
  // initial aktiv setzen
  try{
    var f = document.getElementById('karte-vorderseite');
    var b = document.getElementById('karte-rueckseite');
    if (f && b){
      f.classList.add('aktiv');
      b.classList.remove('aktiv');
    }
  }catch(_){}
  // toggle patch: wenn toggleFrontBack existiert, wrappe es
  if (typeof window.toggleFrontBack === 'function' && !window.__rbWrapToggleActive){
    var _orig = window.toggleFrontBack;
    window.toggleFrontBack = function(){
      var res = _orig.apply(this, arguments);
      try{
        var f = document.getElementById('karte-vorderseite');
        var b = document.getElementById('karte-rueckseite');
        var kb = document.getElementById('kartenbereich');
        var frontOnTop = kb && kb.classList && kb.classList.contains('front-top');
        if (f && b){
          // nach dem Toggle ist front-top gesetzt, interpretieren wir als vorne aktiv
          f.classList.toggle('aktiv', !!frontOnTop);
          b.classList.toggle('aktiv', !frontOnTop);
        }
      }catch(_){}
      return res;
    };
    window.__rbWrapToggleActive = true;
  }
})();
</script>
<style data-group="base" id="active-frame-style">
:root {
  --active-frame-extra: 2px;      /* zusätzlicher Außen-Saum */
  --active-frame-color: #1B5E20; /* dunkles Grün */
  --active-frame-width: 4px;     /* Linienstärke */
}
/* Basis: Overlay-Setup */
#karte-vorderseite, #karte-rueckseite { position: relative; }
#karte-vorderseite .rahmen-overlay,
#karte-rueckseite .rahmen-overlay {
  /* zusätzlicher Außen-Saum, geht NICHT in die Karte */
  box-shadow: 0 0 0 var(--active-frame-extra) var(--active-frame-color);
  position: absolute;
  inset: 0;
  pointer-events: none;
  box-sizing: border-box;
  border: var(--active-frame-width) solid var(--active-frame-color);
  border-radius: 11px;
  z-index: 1; /* über Slots */
  display: none;
}
/* Sichtbarkeit steuern wir über .aktiv auf der Figure */
#karte-vorderseite.aktiv .rahmen-overlay,
#karte-rueckseite.aktiv .rahmen-overlay {
  display: block !important;
}
</style>
<style data-group="base" id="rb-dd-tint">
:root {
  /* Transparenzstufen für Dropdown-Tönung (nur im Dropdown, nicht auf der Karte) */
  --dd-tint: rgba(198, 40, 40, 0.10);
  --dd-tint-hover: rgba(198, 40, 40, 0.18);
  --dd-tint-active: rgba(198, 40, 40, 0.24);
  --dd-tint-free: rgba(198, 40, 40, 0.08);
  --dd-tint-free-focus: rgba(198, 40, 40, 0.14);
}

/* Optionen (Pills) */
#rb-dropdown .rb-dd-item {
  background: var(--dd-tint) !important;
  transition: background-color 120ms linear, background 120ms linear;
}
#rb-dropdown .rb-dd-item:hover {
  background: var(--dd-tint-hover) !important;
}
#rb-dropdown .rb-dd-item.active,
#rb-dropdown .rb-dd-item[aria-selected="true"] {
  background: var(--dd-tint-active) !important;
}

/* Freitext-Zeile (Wrapper + Inputs), nur im Dropdown */
#rb-dropdown #rb-dd-free,
#rb-dropdown .rb-dd-free,
#rb-dropdown #rb-dd-free input,
#rb-dropdown .rb-dd-free input,
#rb-dropdown #rb-dd-free textarea,
#rb-dropdown .rb-dd-free textarea {
  background: var(--dd-tint-free) !important;
  transition: background-color 120ms linear, background 120ms linear;
}
#rb-dropdown #rb-dd-free:focus-within,
#rb-dropdown .rb-dd-free:focus-within {
  background: var(--dd-tint-free-focus) !important;
}
</style>
<style data-group="base" id="rb-dd-style-consolidated">/* Consolidated dropdown styles (preserve cascade order) */
/* from #rb-dd-fit-17-25 */

/* Dropdown-Breite = Breite der Felder 17–25 (152.771 px), zoom-skalierend */
.rb-dd{
  width: calc(152.771px * var(--zoom)) !important;
  max-width: calc(152.771px * var(--zoom)) !important;
}
/* Inhalte mittig, optisch wie Ziel-Felder */
.rb-dd-item{ text-align:center; }
#rb-dd-free{ text-align:center; }
#rb-dd-free-handle{ width:100%; box-sizing:border-box; }

/* from #rb-dd-match-typography */

/* Freitext-Eingabe & Griff optisch exakt wie die Rückseiten-Felder 17–25 */
#rb-dd-free, #rb-dd-free-handle{
  font-family: 'Playfair Display', serif !important;
  font-weight: 400 !important;
  font-size: calc(10.3px * var(--zoom)) !important;
  line-height: calc(18.917px * var(--zoom)) !important;
  height: calc(18.917px * var(--zoom)) !important;
  min-height: calc(18.917px * var(--zoom)) !important;
  padding: 0 !important;
  margin: 0 !important;
  text-align: center !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  box-sizing: border-box !important;
}

/* Griff über volle Breite – wirkt wie eine Zeile */
#rb-dd-free-handle{
  width: 100% !important;
  cursor: grab;
  user-select: none;
}

/* Option: Freitext-Feld-Rand unaufdringlich lassen */
#rb-dd-free{
  border: 1px solid #bbb;
  border-radius: 4px;
}

/* from #rb-dd-like-card */

/* Dropdown kompakter & optisch an die Karten-Felder 17–25 angelehnt */
.rb-dd{
  width: calc(152.771px * var(--zoom)) !important;
  max-width: calc(152.771px * var(--zoom)) !important;
  padding: calc(4px * var(--zoom)) !important;         /* kompakter */
  border: 1px solid #000 !important;
  border-radius: 6px !important;
  box-shadow: 0 4px 16px rgba(0,0,0,.08) !important;
}
.rb-dd-body{ padding: 0 !important; }

/* Einzelne Auswahlelemente = weiße Kapseln wie auf der Karte */
.rb-dd-item{
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  height: calc(18.917px * var(--zoom)) !important;     /* exakt wie Ziel-Felder */
  line-height: calc(18.917px * var(--zoom)) !important;
  margin: calc(4px * var(--zoom)) 0 !important;
  background: #fff !important;
  border: 1.42px solid #000 !important;
  border-radius: 6px !important;
  text-align: center !important;
  font-family: 'Playfair Display', serif !important;
  font-weight: 400 !important;
  font-size: calc(11.3px * var(--zoom)) !important;    /* leicht größer */
  color: #202020 !important;
  cursor: grab !important;
  user-select: none !important;
}
.rb-dd-item:active{ cursor: grabbing !important; }
.rb-dd-item:hover{ background: #f2f2f2 !important; }

/* Freitext-Eingabe & -Griff wirken wie eine Zeile */
#rb-dd-free,
#rb-dd-free-handle{
  font-family: 'Playfair Display', serif !important;
  font-weight: 400 !important;
  font-size: calc(11.3px * var(--zoom)) !important;    /* gleich wie Items */
  line-height: calc(18.917px * var(--zoom)) !important;
  height: calc(18.917px * var(--zoom)) !important;
  min-height: calc(18.917px * var(--zoom)) !important;
  padding: 0 !important;
  margin: 0 !important;
  text-align: center !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  box-sizing: border-box !important;
}
#rb-dd-free{ border: 1px solid #bbb !important; border-radius: 4px !important; }
#rb-dd-body { padding: calc(4px * var(--zoom)) !important; } /* weniger Luft */

/* from #rb-dd-free-hint-style */

/* Hinweis unter der Freitext-Zeile, wenn der Text sichtbar zu lang ist */
#rb-dd-free-hint{
  display:none;
  margin-top: calc(6px * var(--zoom));
  background: #fff;
  border: 3px solid #b00020;  /* Rot wie im Screenshot */
  color: #000;
  border-radius: 6px;
  padding: calc(8px * var(--zoom)) calc(10px * var(--zoom));
  font-size: calc(12px * var(--zoom));
  line-height: 1.25;
  box-shadow: 0 1px 2px rgba(0,0,0,0.08);
}

/* from #rb-box-width-increase */

/* mehr platz in der roten box, damit die breitere Auswahl-Kapsel hineinpasst */
.rb-row .rb-box{ width: 260px !important; }

/* from #rb-dd-items-fullwidth */

.rb-dd { box-sizing: border-box !important; }
.rb-dd-item, #rb-dd-free, #rb-dd-free-handle { width: 100% !important; box-sizing: border-box !important; }

/* from #rb-box-width-reset */

.rb-row .rb-box{ width: 219px !important; }

/* from #rb-dd-exact-match */

.rb-dd{ box-sizing:border-box !important; }
.rb-dd-item, #rb-dd-free{ width:100% !important; box-sizing:border-box !important; }

/* from #rb-dd-plus4mm */

  .rb-dd, .rb-dd-item, #rb-dd-free { box-sizing: border-box !important; }

/* from #rb-dd-width-tight */

  #rb-dropdown { padding:0 !important; }
  #rb-dd-body, #rb-dd-body { padding:0 !important; }
  .rb-dd-item, #rb-dd-free { margin:0 !important; }

/* from #rb-dd-inline-free */

  #rb-dd-body { padding:0 !important; border-top:0 !important; }
  #rb-dd-free{ display:block; width:100% !important; }

/* from #rb-pill-fontsize-fix */

/* Schrift in den zwei weißen Kapseln minimal kleiner als Standard (12px) */
#rb-boxes .rb-box-titel,
#rb-boxes .rb-box-rect{
  font-size: 12px !important;
  line-height: 14px !important; /* beibehalten wie im Basisstil */
}

</style><script id="rb-patches-consolidated">// Consolidated patch scripts (order preserved). No functional changes.
// Blocks merged: #rb-text-usage-tracker, #rb-sticker-usage, #active-frame-init, #active-frame-observer

// --- BEGIN rb-text-usage-tracker ---

(function(){
  // einfache Normalisierung
  function norm(s){ return String(s||'').trim().toLowerCase(); }

  // zentrale Nutzungstabelle: labelNorm -> count
  var usage = window.__rbUsage || (window.__rbUsage = {});

  function findBoxElByLabel(labelNorm){
    var rows = document.querySelectorAll('#rb-boxes .rb-row');
    for (var i=0;i<rows.length;i++){
      var t = rows[i].querySelector('.rb-box-titel');
      if (t && norm(t.textContent) === labelNorm){
        return rows[i].querySelector('.rb-box');
      }
    }
    return null;
  }

  function updateColor(labelNorm){
    var box = findBoxElByLabel(labelNorm);
    if (!box) return;
    var count = usage[labelNorm] || 0;
    if (count > 0) box.classList.add('rb-used');
    else box.classList.remove('rb-used');
  }
  function inc(labelNorm){
    if (!labelNorm) return;
    usage[labelNorm] = (usage[labelNorm] || 0) + 1;
    updateColor(labelNorm);
  }
  function dec(labelNorm){
    if (!labelNorm) return;
    usage[labelNorm] = Math.max(0, (usage[labelNorm] || 0) - 1);
    updateColor(labelNorm);
  }

  // Merke, aus welcher roten Box der aktuelle Drag stammt
  var currentLabel = null;
  document.addEventListener('click', function(e){
    var rect = e.target && e.target.closest && e.target.closest('.rb-box-rect');
    if (rect){
      var row = rect.closest('.rb-row');
      var tit = row && row.querySelector('.rb-box-titel');
      currentLabel = tit ? norm(tit.textContent) : null;
    }
  }, true);

  // Wenn aus dem Dropdown (Listeneintrag / Freitext) gezogen wird, behalten wir currentLabel bei
  document.addEventListener('dragstart', function(e){
    var fromDD = e.target && (e.target.closest('.rb-dd-item') || e.target.closest('#rb-dd-free') || e.target.closest('#rb-dd-free-handle'));
    if (fromDD){
      // nichts weiter nötig – currentLabel wurde beim Klick gesetzt
    }
  }, true);

  // Drop-Capture für Textfelder 17–25: Zähler pflegen und Herkunft merken
  for (var i=17;i<=25;i++){
    (function(i){
      var feld = document.getElementById('feld'+i);
      if (!feld) return;

      // Feld selbst draggable machen (für Müll)
      if (!feld.getAttribute('draggable')) feld.setAttribute('draggable','true');
      if (!feld.__dragBound){
        feld.addEventListener('dragstart', function(ev){
          try { ev.dataTransfer.setData('text/plain', 'feld'+i); }catch(_){}
        });
        feld.__dragBound = true;
      }

      feld.addEventListener('drop', function(e){
        try{
          var txt = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
          if (!txt) return; // kein Text, ggf. Sticker
          // Wenn es ein Sticker wäre, enthält payload i.d.R. "..." – dann ignorieren (lassen wir den Sticker-Handler laufen)
          if (/sticker\//i.test(txt)) return;

          // Wir wollen die Standard-Handler nicht doppelt feuern lassen
          e.preventDefault();
          e.stopPropagation();
          try{ e.stopImmediatePropagation(); }catch(_){}

          // Alten Ursprung abmelden (falls Überschreiben)
          if (feld.dataset && feld.dataset.rbOrigin){
            dec(feld.dataset.rbOrigin);
            delete feld.dataset.rbOrigin;
          }
          // Neuen Ursprung registrieren
          if (currentLabel){
            inc(currentLabel);
            if (feld.dataset) feld.dataset.rbOrigin = currentLabel;
          }

          // Den eigentlichen Text im Feld setzen (wirklich einfügen)
try{
  if (typeof setFieldText === 'function'){
    setFieldText(feld.id, txt);
  } else {
    while (feld.firstChild) feld.removeChild(feld.firstChild);
    var box = document.createElement('div');
    box.className = 'droptext';
    box.textContent = String(txt||'').trim();
    feld.appendChild(box);
  }
}catch(_){/* schlucken */}
}catch(_){}
      }, true);
    })(i);
  }

  // Mülleimer: Text-Felder löschen + Zähler zurück
  function bindTrash(){
    var bin = document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
    if (!bin || bin.__rbBound) return;
    bin.addEventListener('dragover', function(ev){ ev.preventDefault(); });
    bin.addEventListener('drop', function(ev){
      ev.preventDefault();
      var payload = '';
      try{ payload = ev.dataTransfer.getData('text/plain') || ''; }catch(_){}
      var m = payload.match(/^feld(\d{1,2})$/);
      if (m){
        var id = payload;
        var num = parseInt(m[1],10);
        if (num>=17 && num<=25){
          var f = document.getElementById(id);
          if (f){
            if (f.dataset && f.dataset.rbOrigin){ dec(f.dataset.rbOrigin); delete f.dataset.rbOrigin; }
            f.innerHTML = '';
          }
        }
      }
      // Sticker-Löschlogik (falls vorhanden) bleibt unberührt, da wir nur Feld-IDs behandeln
    });
    bin.__rbBound = true;
  }
  bindTrash();
  // Falls die Toolbar neu gerendert würde
  document.addEventListener('DOMContentLoaded', bindTrash);

  // "Karte leeren" setzt alles zurück
  (function(){
    var btn = document.getElementById('btn-leeren');
    if (!btn || btn.__rbUsageClearBound) return;
    btn.addEventListener('click', function(){
      // Zähler nullen + Farben zurück
      Object.keys(usage).forEach(function(k){ usage[k]=0; updateColor(k); });
      // Herkunftsmarker von Feldern entfernen
      for (var i=17;i<=25;i++){
        var f = document.getElementById('feld'+i);
        if (f && f.dataset) delete f.dataset.rbOrigin;
      }
    });
    btn.__rbUsageClearBound = true;
  })();
})();

// --- END {sc.get('id')} ---

// --- BEGIN rb-sticker-usage ---

(function(){
  'use strict';
  // --- Helpers --------------------------------------------------------------
  function rbNorm(s){
    try{ if (typeof window.norm === 'function') return window.norm(s); }catch(_){}
    return String(s||'').trim().toLowerCase();
  }
  // gemeinsamer Zähler (Teilen mit Text-Tracker)
  var usage = window.__rbUsage || (window.__rbUsage = {});

  function findBoxElByLabel(labelNorm){
    var rows = document.querySelectorAll('#rb-boxes .rb-row');
    for (var i=0;i<rows.length;i++){
      var t = rows[i].querySelector('.rb-box-titel');
      if (t && rbNorm(t.textContent) === labelNorm){
        return rows[i].querySelector('.rb-box');
      }
    }
    return null;
  }
  function updateColor(labelNorm){
    var box = findBoxElByLabel(labelNorm);
    if (!box) return;
    var count = usage[labelNorm] || 0;
    if (count > 0) box.classList.add('rb-used');
    else box.classList.remove('rb-used');
  }
  function inc(labelNorm){
    if (!labelNorm) return;
    usage[labelNorm] = (usage[labelNorm] || 0) + 1;
    updateColor(labelNorm);
  }
  function dec(labelNorm){
    if (!labelNorm) return;
    usage[labelNorm] = Math.max(0, (usage[labelNorm] || 0) - 1);
    updateColor(labelNorm);
  }

  // --- Quelle bei Sticker-Drag ermitteln -----------------------------------
  var currentLabelSticker = null;
  (function bindStickerDragSource(){
    var scope = document.getElementById('rb-scope');
    if (!scope || scope.__rbStickerDragBound) return;
    scope.addEventListener('dragstart', function(ev){
      try{
        var img = ev.target;
        if (!(img && img.closest && img.closest('.rb-icon'))) return; // nur Icon-Drag aus weißem Quadrat
        var row = img.closest('.rb-row');
        var t = row && row.querySelector('.rb-box-titel');
        currentLabelSticker = rbNorm(t ? (t.textContent || '') : '');
      }catch(_){ currentLabelSticker = null; }
    }, true);
    scope.__rbStickerDragBound = true;
  })();

  // --- Sticker platzieren -> Zähler pflegen --------------------------------
  (function wrapEmpfangeSticker(){
    if (typeof window.empfangeSticker !== 'function' || window.__rbWrapStickerUsage) return;
    var _orig = window.empfangeSticker;
    window.empfangeSticker = function(event, feldId){
      var slot = document.getElementById(feldId);
      var old = (slot && slot.dataset) ? (slot.dataset.rbOriginSticker || '') : '';

      var res = _orig.apply(this, arguments);

      try{
        var label = currentLabelSticker ? rbNorm(currentLabelSticker) : '';
        if (slot){
          if (old && old !== label){ dec(old); }
          // Wenn alter und neuer Ursprung gleich sind, nichts ändern
          if (label){
            inc(label);
            slot.dataset.rbOriginSticker = label;
          }else{
            // Falls kein Label erkannt, alter Ursprung löschen, aber nicht zählen
            if (slot && slot.dataset) delete slot.dataset.rbOriginSticker;
          }
        }
      }catch(_){}
      currentLabelSticker = null;
      return res;
    };
    window.__rbWrapStickerUsage = true;
  })();

  // --- Sticker-Slots draggable für Mülleimer --------------------------------
  function makeSlotDraggable(slot){
    if (!slot) return;
    var img = slot.querySelector('img');
    if(!img || img.__rbDragBound) return;
    img.setAttribute('draggable','true');
    img.addEventListener('dragstart', function(ev){
      try{
        ev.dataTransfer.setData('text/plain', slot.id);
        ev.dataTransfer.effectAllowed = 'move';
      }catch(_){}
    });
    img.__rbDragBound = true;
  }
  (function bindStickerSlots(){
    var ids = [2,3,4,5,7,8,9,10,11,12,13,14,15,16].map(function(n){ return 'feld'+n; });
    ids.forEach(function(id){
      var slot = document.getElementById(id);
      if (!slot) return;
      makeSlotDraggable(slot);
      var obs = new MutationObserver(function(){ makeSlotDraggable(slot); });
      obs.observe(slot, {childList:true});
    });
  })();

  // --- Mülleimer löscht Sticker + dekrementiert korrekt ---------------------
  (function bindTrashForStickers(){
    var bin = document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
    if (!bin || bin.__rbTrashStickerBound) return;
    bin.addEventListener('drop', function(ev){
      try{
        var id = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
        if (!/^feld(2|3|4|5|8|9|10|11|12|13|14|15|16)$/.test(id)) return;
        ev.preventDefault();
        var slot = document.getElementById(id);
        if (!slot) return;
        var label = (slot.dataset && slot.dataset.rbOriginSticker) ? slot.dataset.rbOriginSticker : '';
        if (label){ dec(label); }
        if (slot.dataset) delete slot.dataset.rbOriginSticker;
        slot.innerHTML = '';
      }catch(_){}
    }, true);
    bin.__rbTrashStickerBound = true;
  })();

  // --- "Karte leeren" bereinigt Sticker-Origins -----------------------------
  (function hookResetForSticker(){
    var btn = document.getElementById('btn-leeren');
    if (!btn || btn.__rbResetStickerBound) return;
    btn.addEventListener('click', function(){
      try{
        var ids = [2,3,4,5,7,8,9,10,11,12,13,14,15,16].map(function(n){ return 'feld'+n; });
        ids.forEach(function(id){
          var el = document.getElementById(id);
          if (el && el.dataset) delete el.dataset.rbOriginSticker;
        });
        // usage wird bereits im Text-Tracker-Reset auf 0 gesetzt
      }catch(_){}
    });
    btn.__rbResetStickerBound = true;
  })();

})();

// --- END {sc.get('id')} ---

// --- BEGIN active-frame-init ---

(function(){
  try{
    var f = document.getElementById('karte-vorderseite');
    var b = document.getElementById('karte-rueckseite');
    if (f && b){
      f.classList.add('aktiv');
      b.classList.remove('aktiv');
    }
  }catch(_){}

  // falls Toggle existiert, nach jedem Umschalten .aktiv korrekt setzen
  if (typeof window.toggleFrontBack === 'function' && !window.__activeFramePatched){
    var _orig = window.toggleFrontBack;
    window.toggleFrontBack = function(){
      var res = _orig.apply(this, arguments);
      try{
        var kb = document.getElementById('kartenbereich');
        var frontOnTop = kb && kb.classList && kb.classList.contains('front-top');
        var f = document.getElementById('karte-vorderseite');
        var b = document.getElementById('karte-rueckseite');
        if (f && b){
          f.classList.toggle('aktiv', !!frontOnTop);
          b.classList.toggle('aktiv', !frontOnTop);
        }
      }catch(_){}
      return res;
    };
    window.__activeFramePatched = true;
  }
})();

// --- END {sc.get('id')} ---

// --- BEGIN active-frame-observer ---

(function(){
  try{
    var kb = document.getElementById('kartenbereich');
    var front = document.getElementById('karte-vorderseite');
    var back  = document.getElementById('karte-rueckseite');
    if (!kb || !front || !back) return;

    function syncActive(){
      var isFrontTop = kb.classList.contains('front-top');
      front.classList.toggle('aktiv', isFrontTop);
      back.classList.toggle('aktiv', !isFrontTop);
    }

    // initial sync
    syncActive();

    // observe class changes on kartenbereich
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        if (muts[i].type === 'attributes' && muts[i].attributeName === 'class'){
          syncActive();
          break;
        }
      }
    });
    obs.observe(kb, { attributes: true });

    // also resync after clicks on the toggle button (extra safety)
    var btn = document.getElementById('btn-toggle-frontback');
    if (btn && !btn.__activeSync){
      btn.addEventListener('click', function(){ requestAnimationFrame(syncActive); });
      btn.__activeSync = true;
    }
  }catch(_){}
})();

// --- END {sc.get('id')} ---

</script>
<style data-group="other" id="rb-cursor-grab">
/* Einheitliche Greifhand-Optik (nur Optik, keine Logik) */
#rb-scope [draggable="true"], .is-draggable { cursor: grab; }
.is-dragging, .is-draggable:active { cursor: grabbing; }
/* Icons in den roten Boxen (weißes Quadrat) brauchen Cursor unabhängig vom draggable-Attribut */
#rb-scope .rb-icon img { cursor: grab; }
#rb-scope .rb-icon img:active { cursor: grabbing; }
/* === MOBILE TAP: gewählter Sticker sichtbar markieren (nur Touch) === */
#rb-scope .rb-box.rb-mobile-sticker-selected {
  outline: 2px solid #333;
  box-shadow: 0 0 0 2px rgba(0,0,0,0.25) inset;
}

</style>
<script id="rb-attr-shim">
(function(){
  'use strict';
  function norm(s){ return String(s||'').trim().toLowerCase(); }
  function setUnified(slot, type, label){
    if (!slot || !slot.dataset) return;
    if (type)  slot.dataset.rbType  = type;       // 'sticker' | 'text'
    if (label) slot.dataset.rbLabel = norm(label);
    // Spiegeln auf bisherige Felder (Kompatibilität)
    if (type === 'sticker' && label){ slot.dataset.rbOriginSticker = norm(label); }
    if (type === 'text'    && label){ slot.dataset.rbOrigin       = norm(label); }
  }
  function syncExisting(){
    var ids = [];
    for (var i=1;i<=25;i++) ids.push('feld'+i);
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if (!el || !el.dataset) return;
      if (el.dataset.rbOriginSticker && !el.dataset.rbLabel){
        setUnified(el, 'sticker', el.dataset.rbOriginSticker);
      }else if (el.dataset.rbOrigin && !el.dataset.rbLabel){
        setUnified(el, 'text', el.dataset.rbOrigin);
      }
    });
  }
  // Wrap empfangeSticker/Text nachgelagert, um nur unified Marker zu setzen
  if (typeof window.empfangeSticker === 'function' && !window.__rbAttrShimSticker){
    var _s = window.empfangeSticker;
    window.empfangeSticker = function(event, feldId){
      var res = _s.apply(this, arguments);
      try{
        var slot = document.getElementById(feldId);
        if (slot && slot.dataset){
          var lab = slot.dataset.rbOriginSticker || slot.dataset.rbLabel || '';
          if (lab) setUnified(slot, 'sticker', lab);
        }
      }catch(_){}
      return res;
    };
    window.__rbAttrShimSticker = true;
  }
  if (typeof window.empfangeText === 'function' && !window.__rbAttrShimText){
    var _t = window.empfangeText;/* STEP17E_MARK: window.empfangeText = function(...) – Kandidat, noch nicht geändert */

    window.empfangeText = function(event, feldId){
      var res = _t.apply(this, arguments);
      try{
        var slot = document.getElementById(feldId);
        if (slot && slot.dataset){
          var lab = (slot.dataset.rbOrigin || slot.dataset.rbLabel || '');
          if (!lab && event && event.dataTransfer){
            try{ lab = event.dataTransfer.getData('text/rb-label') || ''; }catch(_){}
          }
          if (lab) setUnified(slot, 'text', lab);
        }
      }catch(_){}
      return res;
    };
    window.__rbAttrShimText = true;
  }
  // Trash & Reset: unified Marker zusätzlich löschen (keine Logikänderung)
  var trash = document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
  if (trash && !trash.__rbAttrShim){
    trash.addEventListener('drop', function(ev){
      try{
        var id = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
        var m = id.match(/^feld(\d{1,2})$/);
        if (!m) return;
        var slot = document.getElementById(id);
        if (slot && slot.dataset){ delete slot.dataset.rbType; delete slot.dataset.rbLabel; }
      }catch(_){}
    }, true);
    trash.__rbAttrShim = true;
  }
  var btn = document.getElementById('btn-leeren');
  if (btn && !btn.__rbAttrShimReset){
    btn.addEventListener('click', function(){
      for (var i=1;i<=25;i++){
        var el = document.getElementById('feld'+i);
        if (el && el.dataset){ delete el.dataset.rbType; delete el.dataset.rbLabel; }
      }
    });
    btn.__rbAttrShimReset = true;
  }
  // initial synchronisieren
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', syncExisting);
  }else{
    syncExisting();
  }
})();
</script>
<script id="rb-constants">
// Globale Konstanten (Nur Referenz – werden von bestehender Logik NICHT benötigt/überschrieben)
(function(){
  'use strict';
  // Slots (IDs) – zentrale Referenz
  window.STICKER_SLOTS = Object.freeze([2,3,4,5,7,8,9,10,11,12,13,14,15,16].map(n => 'feld'+n));
  window.TEXT_SLOTS    = Object.freeze([17,18,19,20,21,22,23,24,25].map(n => 'feld'+n));

  // Aktiver Rahmen – aus CSS-Variablen lesen (Fallbacks für lokale Tests)
  try {
    const cs = getComputedStyle(document.documentElement);
    window.ACTIVE_FRAME = Object.freeze({
      color: (cs.getPropertyValue('--active-frame-color') || '#1B5E20').trim(),
      width: parseFloat(cs.getPropertyValue('--active-frame-width')) || 4
    });
  } catch(_){
    window.ACTIVE_FRAME = Object.freeze({ color: '#1B5E20', width: 4 });
  }

  // Dropdown-Tints – referenziert die im CSS genutzten Werte (nur Doku)
  window.DD_TINTS = Object.freeze({
    item:       'rgba(198, 40, 40, 0.10)',
    hover:      'rgba(198, 40, 40, 0.18)',
    active:     'rgba(198, 40, 40, 0.24)',
    free:       'rgba(198, 40, 40, 0.08)',
    freeFocus:  'rgba(198, 40, 40, 0.14)'
  });

  // Placeholder für späteren Wix-Adapter (heute ungenutzt; NUR Doku)
  window.DATA_ENDPOINT = '/_functions/pflanzen?view=builder';
})();
</script>

<style data-group="base" id="rb-confirm-style">
/* Hinweis-Overlay (statt Browser-Confirm) */
#rb-confirm-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:100000;}
#rb-confirm{background:#fff;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.3);max-width:520px;width:min(92vw,520px);font-family:inherit;}
#rb-confirm .rbc-body{padding:20px 20px 0 20px;font-size:16px;line-height:1.35;}
#rb-confirm .rbc-actions{display:flex;gap:10px;justify-content:flex-end;padding:16px 20px 20px 20px;}
#rb-confirm .rbc-btn{padding:8px 14px;border-radius:8px;border:1px solid #cfcfcf;background:#fff;font-size:15px;cursor:pointer}
#rb-confirm .rbc-btn.primary{background:#2E7D32;color:#fff;border-color:#2E7D32;}
#rb-confirm .rbc-btn.primary:focus{outline:2px solid #1B5E20;outline-offset:2px;}
#rb-confirm .rbc-btn:focus{outline:2px solid #1976D2;outline-offset:2px;}
@media (prefers-reduced-motion:no-preference){
  #rb-confirm{transition:transform .12s ease-out,opacity .12s ease-out}
  #rb-confirm-overlay[data-show="1"] #rb-confirm{transform:translateY(0);opacity:1}
  #rb-confirm{transform:translateY(-4px);opacity:.98}
}
</style><div data-show="0" id="rb-confirm-overlay"><div id="rb-confirm"><div class="rbc-body"><div id="rb-confirm-msg"></div></div><div class="rbc-actions"><button class="rbc-btn" id="rb-confirm-cancel" type="button">Abbrechen</button><button class="rbc-btn primary" id="rb-confirm-ok" type="button">OK</button></div></div></div><script id="rb-confirm-helper">
(function(){
  'use strict';
  window.rbConfirm = function(message){
    var ov = document.getElementById('rb-confirm-overlay');
    var box = document.getElementById('rb-confirm');
    var msg = document.getElementById('rb-confirm-msg');
    var ok = document.getElementById('rb-confirm-ok');
    var cancel = document.getElementById('rb-confirm-cancel');
    if (!ov || !box || !msg || !ok || !cancel){
      // Fallback: native confirm
      return Promise.resolve(window.confirm(message));
    }
    msg.textContent = String(message||'');
    ov.style.display = 'flex'; ov.setAttribute('data-show','1');
    // focus management
    setTimeout(function(){ try{ ok.focus(); }catch(_){} }, 0);

    return new Promise(function(resolve){
      function cleanup(){
        try{
          ov.setAttribute('data-show','0'); ov.style.display = 'none';
          document.removeEventListener('keydown', onKey, true);
          ov.removeEventListener('click', onOverlay, true);
          ok.removeEventListener('click', onOk, true);
          cancel.removeEventListener('click', onCancel, true);
        }catch(_){}
      }
      function onOk(){ cleanup(); resolve(true); }
      function onCancel(){ cleanup(); resolve(false); }
      function onOverlay(e){ if (e.target === ov) { cleanup(); resolve(false); } }
      function onKey(e){
        if (e.key === 'Escape'){ e.preventDefault(); cleanup(); resolve(false); }
        if (e.key === 'Enter'){ e.preventDefault(); cleanup(); resolve(true); }
      }
      ok.addEventListener('click', onOk, true);
      cancel.addEventListener('click', onCancel, true);
      ov.addEventListener('click', onOverlay, true);
      document.addEventListener('keydown', onKey, true);
    });
  };
})();
</script><style data-group="other" id="ps-toplabel-style">
/* Label über der Pflanzensuche im Karten-Grün */
.steuerleiste .ac-wrap .ps-toplabel{
  display:block;
  margin-bottom:8px;
  font-weight:700;
  font-size:22px; /* groß, aber dezent */
  color:#1B5E20; /* Kartenrahmen-Grün */
}
@media (max-width: 600px){
  .steuerleiste .ac-wrap .ps-toplabel{ font-size:16px; margin-bottom:4px; }
}
</style><style data-group="other" id="steuerleiste-leafbg-style">
/* Steuerleiste mit Blaetterhintergrund (dezente Überlagerung für Lesbarkeit) */
.steuerleiste{
  background-image:
    linear-gradient(rgba(255,255,255,0.88), rgba(255,255,255,0.88)),
    url('Kartenhintergrund980pxbreit.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
/* Optional: die inneren Controls leicht abheben */
.steuerleiste .ac-wrap,
.steuerleiste .btns,
.steuerleiste input[type="text"],
.steuerleiste input[type="search"]{
  backdrop-filter: blur(0.5px);
}
</style><style data-group="other" id="toolbar-leafbg-svg-override">
/* Steuerleiste: kräftiger Blaetterhintergrund (svg, keine Transparenz) */
.steuerleiste{
  background-image: url('Blaetterhintergrund.png') !important;
  background-repeat: no-repeat !important;
  background-position: center !important;
  background-size: cover !important;
  background-color: #e6efe6 !important; /* Fallback */
}
</style><style data-group="other" id="cols-darkgreen-bg">

.columns{
  background-color: #1B5E20;
}
</style><style data-group="other" id="toolbar-and-panels-fix">
/* Toolbar: Leaf background should reach left edge */
.steuerleiste{
  background-image: url('Blaetterhintergrund.png') !important;
  background-repeat: no-repeat !important;
  background-position: left center !important; /* links bündig */
  background-size: cover !important;
  background-color: #e6efe6 !important;
}

/* Panels (Spalte 1 & 2) – Rahmenfarbe wie 'Pflanzensuche'-Grün */
.panel{ border-color: #1B5E20 !important; }
</style><style data-group="other" id="panel-lightgreen-bg">
/* Spalten-Hintergrund in hellem Grün (wie Toolbar-Palette) */
#spalte-links, #spalte-rechts{
  background-color: #e6efe6 !important;
}
</style><style data-group="other" id="panel-lightyellowgreen-bg">
/* Spalten-Hintergrund: helles Gelbgrün */
#spalte-links, #spalte-rechts{
  background-color: #F0F8CE !important; /* sehr helles Gelbgrün */
}
</style><style data-group="other" id="panel-bright-yg-override">
/* Spalten-Hintergrund: kräftiges Gelbgrün (#7FFF2A), ohne Transparenz */
#spalte-links, #spalte-rechts{
  background-color: #7FFF2A !important;
}
</style><style data-group="other" id="panel-yg-8DD35F-override">
/* Spalten-Hintergrund: #8DD35F (ohne Transparenz) */
#spalte-links, #spalte-rechts{
  background-color: #8DD35F !important;
}
</style><style data-group="other" id="toolbar-bg-shorthand-override">
/* Toolbar: volles Bild bis an den Rand (Hintergrund via shorthand überschreiben) */
.steuerleiste{
  background: url('Blaetterhintergrund.png') left center / cover no-repeat #e6efe6 !important;
}
</style><style data-group="other" id="toolbar-fullbleed-and-panel-alpha">
/* Toolbar: Bild wirklich bis zum Rahmen (negativer Außenabstand gleicht Content-Padding aus) */
.content .steuerleiste{
  margin-left: -16px;
  margin-right: -16px;
  padding-left: calc(16px + 16px);
  padding-right: calc(16px + 16px);
  background: url('Blaetterhintergrund.png') left center / cover no-repeat #e6efe6 !important;
}

/* Spalte 1 & 2: Hintergrund 50% transparentes #8DD35F */
#spalte-links, #spalte-rechts{
  background-color: rgba(141, 211, 95, 0.5) !important;
}
</style><style data-group="other" id="columns-alpha-panels-solid">

#spalte-links, #spalte-rechts{
  background-color: #8DD35F !important; /* voll, ohne Alpha */
}
.columns{
  background-color: rgba(27, 94, 32, 0.5) !important; /* dunkles Grün (wie Überschrift), 50% */
}
</style><style data-group="other" id="panel-border-green-override">
/* Spaltenrahmen (Panels) im Dunkelgrün wie 'Pflanzensuche' */
.panel{
  border-color: #1B5E20 !important;
}
</style><style data-group="other" id="content-surround-green">

.content{ background-color: #1B5E20 !important; }
</style><style data-group="other" id="ps-toplabel-white">
/* Überschrift 'Pflanzensuche:' in Weiß für besseren Kontrast */
.steuerleiste .ac-wrap .ps-toplabel{ color:#ffffff !important; }
</style><style data-group="other" id="content-green-alpha-50">
/* .content Hintergrund: dunkles Grün mit 50% Transparenz */
.content{
  background-color: rgba(27, 94, 32, 0.5) !important; /* #1B5E20 mit 0.5 Alpha */
}
</style><style data-group="other" id="columns-gap-solid-green">
/* Streifen zwischen Spalte 1 & 2 wie der Rahmen: sattes Dunkelgrün */
.columns{
  background-color: #1B5E20 !important;
}
</style><style data-group="other" id="columns-bg-match-content">
/* Streifen zwischen den Spalten wie außen: 50% transparentes Dunkelgrün */
.columns{
  background-color: rgba(27, 94, 32, 0.5) !important; /* wie .content */
}
</style><style data-group="other" id="panel-inner-border-match">
/* Innere Panelränder (zum Zwischenstreifen hin) an den Hintergrund angleichen */
#spalte-links{  border-right-color: rgba(27, 94, 32, 0.5) !important; }
#spalte-rechts{ border-left-color:  rgba(27, 94, 32, 0.5) !important; }
</style><style data-group="other" id="panel-gap-true-bleed">
/* Mittlerer Streifen exakt gleich: keine Mischfarbe durch halbtransparente Innenränder */
#spalte-links, #spalte-rechts{ background-clip: padding-box !important; }
#spalte-links{  border-right-color: transparent !important; }
#spalte-rechts{ border-left-color:  transparent !important; }
</style>
<script id="feinarbeit-step17-catmap-by-title-robust">
/* NEUTRALIZED: legacy RAW_MAP removed – CSV only */
(function(){})();
</script>
<script id="einzelschritt-suche-caseinsensitive">
(function(){
  // Robust Normalizer (de + diakritika), unabhängig von vorhandenen Funktionen
  function norm(s){
    return String(s||'')
      .toLowerCase()
      .replace(/ä/g,'a').replace(/ö/g,'o').replace(/ü/g,'u').replace(/ß/g,'ss')
      .normalize ? String(s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}+/gu,'') : String(s||'').toLowerCase();
  }

  // Sucheingabe
  var input = document.getElementById('pflanzensuche');

  // 1) Case-insensitive Autocomplete-Filter (falls ein eigener Filter existiert, ergänzen wir ihn)
  if (input){
    input.addEventListener('input', function(){
      // Falls eine eigene Render-Logik existiert, lassen wir sie laufen;
      // unsere Änderung betrifft v. a. die spätere Auswahl (rbSelectPlant).
      // Nichts überschreiben, nur sicherstellen, dass ac-list mit lower-case arbeitet.
      try{
        var q = norm(input.value);
        // Wenn die vorhandene Autocomplete-Liste da ist, sortieren/priorisieren wir per norm() neu
        var list = document.querySelector('.ac-list');
        if (list){
          // (Optional: Könnte man Ranking anpassen – hier lassen wir es neutral, um nichts zu brechen)
        }
      }catch(e){}
    }, {passive:true});
  }

  // 2) Auswahl robust machen: rbSelectPlant case-insensitive auflösen
  if (typeof window.rbSelectPlant === 'function' && !window.__rbSelectPlantCaseInsensitive){
    var _orig = window.rbSelectPlant;
    window.rbSelectPlant = function(name){
      var raw = String(name||'').trim();
      var q = norm(raw);
      var candidate = raw;

      // a) Wenn Autocomplete sichtbar, passende Items durchsuchen
      try{
        var items = document.querySelectorAll('.ac-list [data-value], .ac-list .ac-item, .ac-list li');
        var exact = null, starts = null;
        items.forEach(function(el){
          var t = (el.getAttribute('data-value') || el.textContent || '').trim();
          var nt = norm(t);
          if (!exact && nt === q) exact = t;
          if (!starts && nt.indexOf(q) === 0) starts = t;
        });
        if (exact) candidate = exact;
        else if (starts) candidate = starts;
      }catch(e){}

      // b) Fallback: Titel-Kapitalisierung (falls DB-Namen „Alocasia …“ verlangen)
      if (!candidate && raw){
        candidate = raw.charAt(0).toUpperCase() + raw.slice(1).toLowerCase();
      }

      return _orig.call(this, candidate);
    };
    window.__rbSelectPlantCaseInsensitive = true;
  }
})();
</script>
<script id="ok-button-restore-init">
(function(){
  'use strict';
  var ok = document.getElementById('btn-karte-fertig-ok');
  if (!ok || ok.__rbOkBound) return;
  ok.addEventListener('click', function(){
    try{
      // 1) Bestehende "Karte leeren"-Logik wiederverwenden (löst alle Reset-Handler aus)
      var clearBtn = document.getElementById('btn-leeren');
      if (clearBtn) clearBtn.click();

      // 2) Vorderseite oben (Klassen setzen, keine SVG/Koordinatenänderung)
      var kb = document.getElementById('kartenbereich');
      if (kb){
        kb.classList.add('front-top');
        kb.classList.remove('back-top');
        // safety: evtl. "tight"-Layout aufheben
        kb.classList.remove('tight');
      }

      // 3) Zoom sicher auf 100 % stellen (ohne setZoom zu benötigen)
      var root = document.documentElement;
      var body = document.body;
      if (root && root.style) root.style.setProperty('--zoom', 1);
      if (body && body.classList){
        body.classList.add('zoom-100');
        body.classList.remove('zoom-150');
      }

      // 4) Rückseiten-Margin (von Overlap-Korrektur) zurücksetzen
      var back = document.getElementById('karte-rueckseite');
      if (back && back.style) back.style.marginLeft = '';

      // 5) Fokus aus evtl. geöffneten Eingaben nehmen
      try{ if (document.activeElement) document.activeElement.blur(); }catch(_){}
    }catch(_){ /* bewusst still: keine Nebenwirkungen auf bestehende Logik */ }
  });
  ok.__rbOkBound = true;
})();
</script>
<script id="ok-button-restore-delegated">
(function(){
  'use strict';

  function hardResetToStart(){
    try {
      // 1) Vollreset über bestehenden Button (nutzt vorhandene Logik)
      var clearBtn = document.getElementById('btn-leeren');
      if (clearBtn) clearBtn.click();
    } catch(_){}

    // 2) Nachlaufende Korrekturen nach einem Tick (damit frühere Handler fertig sind)
    setTimeout(function(){
      try{
        // Zoom 100% & Vorderseite oben
        var root = document.documentElement, body = document.body;
        var kb = document.getElementById('kartenbereich');
        if (root && root.style) root.style.setProperty('--zoom', 1);
        if (body && body.classList){ body.classList.add('zoom-100'); body.classList.remove('zoom-150'); }
        if (kb){ kb.classList.add('front-top'); kb.classList.remove('back-top'); kb.classList.remove('tight'); }
        var back = document.getElementById('karte-rueckseite'); if (back && back.style) back.style.marginLeft = '';

        // Filter-Buttons: "alle" aktivieren, wenn vorhanden
        var btnAll = document.getElementById('btn-alle-sticker'); if (btnAll) btnAll.click();

        // Suche & Autocomplete visuell säubern (falls anderer Code es offen ließ)
        var ps = document.getElementById('pflanzensuche'); if (ps) ps.value = '';
        try{ document.querySelectorAll('.ac-list').forEach(el=>el.remove()); }catch(_){}
        var anc = document.getElementById('autocomplete-anchor'); if (anc) anc.innerHTML = '';
        var toast = document.getElementById('nohit-toast'); if (toast) toast.style.display = 'none';

        // Plantname auf "–"
        var nameSpan = document.getElementById('rb-plantname'); if (nameSpan) nameSpan.textContent = '–';

        // Dropdown schließen
        var dd = document.getElementById('rb-dropdown'); if (dd) dd.classList.remove('open');

        // Reflow/Overlap neu berechnen
        try{ window.dispatchEvent(new Event('resize')); }catch(_){}

        // Fokus weg
        try{ if (document.activeElement) document.activeElement.blur(); }catch(_){}
      }catch(_){}
    }, 0);
  }

  // Delegierter Click-Handler: fängt auch später ersetzte Buttons ab
  function onDocClick(e){
    var t = e.target;
    if (!t) return;
    var id = t.id || '';
    if (id === 'btn-karte-fertig-ok' || id === 'rb-confirm-ok'){
      hardResetToStart();
    }
  }
  if (!document.__rbOkDelegated){
    document.addEventListener('click', onDocClick, true);
    document.__rbOkDelegated = true;
  }
})();
</script>
<script id="ok-button-clear-hints-js">
(function(){
  'use strict';
  function clearHints(){
    try{
      // Entferne dynamisch erzeugte Hinweis-Elemente
      document.querySelectorAll('.rb-hint').forEach(function(el){
        el.remove();
      });
      // Leere bekannte Hinweis-Container, ohne Boxen/Struktur anzutasten
      var candidates = Array.prototype.slice.call(document.querySelectorAll('[id*="hinweis"], [class*="hinweis"]'));
      candidates.forEach(function(el){
        var tag = (el.tagName || '').toLowerCase();
        if (tag === 'style' || tag === 'script') return;
        if (el.classList.contains('rb-box') || el.classList.contains('rb-boxes')) return;
        // Nur Container leeren, keine roten Boxen
        try{ el.innerHTML = ''; }catch(_){}
      });
    }catch(_){}
  }
  function onClick(e){
    var t = e.target || {};
    var id = t.id || '';
    if (id === 'btn-karte-fertig-ok' || id === 'rb-confirm-ok'){
      // nach dem Haupt-Reset einen Tick warten, dann Hinweise bereinigen
      setTimeout(clearHints, 0);
    }
  }
  if (!document.__rbClearHintsBound){
    document.addEventListener('click', onClick, true);
    document.__rbClearHintsBound = true;
  }
})();
</script>
<script id="ok-button-hard-reload">
(function(){
  'use strict';
  // Harte, eindeutige Definition von "Ausgangszustand": Seite neu laden.
  // Keine Änderungen an SVG/ViewBox/Koordinaten – kompletter Startzustand wie beim ersten Laden.
  function isOkTarget(t){
    if (!t) return false;
    if (t.id === 'btn-karte-fertig-ok' || t.id === 'rb-confirm-ok') return true;
    // Falls ein Icon/Text im Button geklickt wird:
    try{
      var btn = t.closest && t.closest('#btn-karte-fertig-ok, #rb-confirm-ok');
      return !!btn;
    }catch(_){}
    return false;
  }
  function onDocClickCapture(e){
    var t = e.target;
    if (!isOkTarget(t)) return;
    // Browser-Neuladung erzwingt den echten Ausgangszustand.
    try{
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
    }catch(_){}
    // Sofort neu laden
    window.location.reload();
  }
  if (!document.__rbOkHardReload){
    document.addEventListener('click', onDocClickCapture, true); // capture = früh dran
    document.__rbOkHardReload = true;
  }
})();
</script>
<script id="rb-master-icons-from-csv">
(function(){
  'use strict';
  if (window.__rbMasterIconsPatched) return;

  var _hydrateMaster = window.hydrateMaster;
  var _stickerFileFor = window.stickerFileFor;

  function norm(s){ return String(s||'').trim().toLowerCase(); }

  var RB_ICON_RAW_BASE = 'https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/main/';
  function toRawIconPath(p){
    p = String(p||'').trim();
    if (!p) return '';
    // http/https: direkt nutzen, GitHub-blob -> raw umbiegen
    if (/^https?:\/\//i.test(p)){
      p = p.replace(/^https:\/\/github\.com\//i, 'https://raw.githubusercontent.com/')
           .replace(/\/blob\//i, '/');
      return p;
    }
    // relative Pfade: an Repo-Basis anhängen
    p = p.replace(/\\/g,'/').replace(/^\/+/, '');
    return RB_ICON_RAW_BASE + p;
  }

  function buildIconMapsFromMaster(text){
    try{
      var cleaned = stripBOM(normalizeNewlines(text));
      var lines = cleaned.split('\n').filter(function(l){ return l.trim().length>0 && !/^sep\s*=\s*/i.test(l); });
      if (lines.length < 4) return null;

      var delim   = detectDelimGuess(lines[0] || ',');
      var headers = splitRow(lines[0], delim);
      var rowSvg  = splitRow(lines[2], delim); // Zeile 3: SVG
      var rowPng  = splitRow(lines[3], delim); // Zeile 4: PNG (mit _symbol.png)
      var rowUrl  = (lines.length > 8) ? splitRow(lines[8], delim) : []; // Zeile 9: URL/Pfad (optional)

      var PLAIN = new Map();   // ohne _symbol -> für gelbe Boxen
      var SYMBOL = new Map();  // mit _symbol  -> für Karten/Symbol-Overlay

      for (var c=1; c<headers.length; c++){
        var lab  = String(headers[c]||'').trim();
        var png  = String(rowPng[c]||'').trim();
        var url  = (rowUrl[c] !== undefined ? String(rowUrl[c]||'').trim() : '');
        if (!lab) continue;
        // Priorität: Zeile 9 (URL/Pfad) > Zeile 4 (PNG) > Zeile 3 (SVG)
        if (url) {
          png = url;
        }
        if (!png) {
          // Fallback: aus SVG ableiten
          var svg = String(rowSvg[c]||'').trim();
          if (svg) png = svg.replace(/\.svg(\?.*)?$/i, '.png');
        }
        if (!png) continue;

        // SYMBOL: unverändert (soll bereits *_symbol.png oder komplette URL sein)
        var symName = png.replace(/\.svg(\?.*)?$/i, '.png');
        var sym = toRawIconPath(symName);
        // PLAIN: ohne _symbol
        var plainName = symName.replace(/_symbol(?=\.png(\?.*)?$)/i, '');
        var plain = toRawIconPath(plainName);

        try{ SYMBOL.set(norm(lab), sym); }catch(_){}
        try{ PLAIN.set(norm(lab), plain); }catch(_){}
        try{
          if (window.STICKER_SET && typeof STICKER_SET.add==='function'){
            STICKER_SET.add(plain);
            STICKER_SET.add(sym);
          }
        }catch(_){}
      }
      return {PLAIN:PLAIN, SYMBOL:SYMBOL};
    }catch(e){ return null; }
  }

  // Hydrate Master and build maps
  window.hydrateMaster = async function(text, origin){
    try{
      var maps = buildIconMapsFromMaster(text);
      if (maps){
        window.__masterIconMapPlain  = maps.PLAIN;
        window.__masterIconMapSymbol = maps.SYMBOL;
      }
    }catch(_){}
    if (typeof _hydrateMaster === 'function') return _hydrateMaster(text, origin);
  };

  // Prefer Master-CSV icons; fallback to original heuristic.
  // WICHTIG: Für gelbe Boxen und UI verwenden wir die PLAIN-Dateien (ohne _symbol).
  (function(){
  try{
    var d = Object.getOwnPropertyDescriptor(window,'stickerFileFor');
    if (d && d.writable === false) return;
  }catch(_){}
  window.stickerFileFor = function(label){
    var key = norm(label);
    var map = window.__masterIconMapPlain;
    if (map && map.has(key)) return map.get(key);
    return null;
  };

})();
// Helfer: erzwinge _symbol.png für Karten-Placement
  window.toSymbolPng = function(url){
    if (!url) return url;
    try{
      return String(url).replace(/(?:_symbol)?\.(svg|png)(\?.*)?$/i, '_symbol.png');
    }catch(_){ return url; }
  };

  window.__rbMasterIconsPatched = true;
})();</script>
<script id="rb-master-autoload-name">
(function(){
  'use strict';
  if (window.__rbMasterAutoload) return;

  // Mark when master is hydrated (so we don't double-load)
  (function(){
    var _hm = window.hydrateMaster;
    window.hydrateMaster = function(text, origin){
      try{ window.__masterLoaded = true; }catch(_){}
      if (typeof _hm === 'function') return _hm(text, origin);
    };
  })();

  function fetchText(url){
    return fetch(url, {cache:'no-store'}).then(function(r){
      if(!r.ok) throw new Error('HTTP '+r.status);
      return r.text();
    });
  }

  function loadMasterSequential(urls){
    var i = 0;
    function next(){
      if (window.__masterLoaded) return; // already loaded by something else
      if (i >= urls.length) { console.warn('[Master] No CSV found among:', urls); return; }
      var url = urls[i++];
      fetchText(url).then(function(txt){
        if (typeof window.hydrateMaster === 'function'){
          window.hydrateMaster(txt, url);
        }
      }).catch(function(err){
        next();
      });
    }
    next();
  }

  window.addEventListener('load', function(){
    if (window.__masterLoaded) return;
    var boxes = document.getElementById('rb-boxes');
    var hinted = boxes ? (boxes.getAttribute('data-master-csv')||'').trim() : '';
    var urls = [];
    urls.push(window.masterPath || 'https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv');
    loadMasterSequential(urls);
  }, { once:true });

  window.__rbMasterAutoload = true;
})();
</script>
<script id="rb-master-iconmap-A1">
(function(){
  'use strict';
  if (window.__rbMasterIconMapA1) return;

  function normKey(s){
    s = String(s||'').trim().toLowerCase();
    s = s.replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/ß/g,'ss');
    s = s.replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-+|-+$/g,'');
    return s;
  }

  function buildIconMap(text){
    try{
      var cleaned = stripBOM(normalizeNewlines(text));
      var raw = cleaned.split('\n');
      var lines = raw.filter(function(l){ return l.trim().length>0 && !/^sep\s*=\s*/i.test(l); });
      if (!lines.length) return null;
      var delim = (typeof detectDelimGuess==='function') ? detectDelimGuess(lines[0]||',') : ',';
      var headers = (typeof splitRow==='function') ? splitRow(lines[0], delim) : (lines[0]||'').split(delim);
      if (!headers || headers.length < 2) return null;

      // Zeile "Dateiname" suchen, sonst Index 2 (dritte Zeile) als Fallback
      var rowIdx = -1;
      for (var r=1; r<Math.min(lines.length, 12); r++){
        var first = (typeof splitRow==='function') ? splitRow(lines[r], delim)[0] : (lines[r]||'').split(delim)[0];
        if (String(first||'').trim().toLowerCase() === 'dateiname'){ rowIdx = r; break; }
      }
      if (rowIdx === -1){
        if (lines.length >= 3) rowIdx = 2; else return null;
      }
      var svgRow = (typeof splitRow==='function') ? splitRow(lines[rowIdx], delim) : (lines[rowIdx]||'').split(delim);

      var map = new Map();
      for (var c=1; c<headers.length; c++){
        var lab = String(headers[c]||'').trim();
        var val = String(svgRow[c]||'').trim();
        if (!lab || !val) continue;
        try{
          var key = (typeof norm==='function') ? norm(lab) : normKey(lab);
          map.set(key, val);
        }catch(_){}
      }
      return map;
    }catch(e){ return null; }
  }

  (function(){
    var _hm = window.hydrateMaster;
    window.hydrateMaster = function(text, origin){
      try{
        var m = buildIconMap(text);
        if (m) window.__masterIconMap = m;
      }catch(_){}
      if (typeof _hm === 'function') return _hm(text, origin);
    };
  })();

  window.__rbMasterIconMapA1 = true;
})();
</script>
<script id="rb-sticker-base-override">
(function(){
  try{
    var base = '';
    // Basis: gleiche Ebene wie Konfigurator.html (kein Unterordner, kein führender Slash)
    window.STICKER_BASE = base;
  }catch(_){}
})();
</script>
<script id="rb-c1-single-icon-loader">
(function(){
  'use strict';
  if (window.__rbC1Patched) return;

  // ---- 1) Neutralize alternative icon loaders (label-derived etc.) ----
  function noop(){}
  try{
    if (typeof window.ensureIcon === 'function') window.ensureIcon = noop;
    if (typeof window.applyAll === 'function') window.applyAll = noop;
    if (typeof window.applyMasterIcons === 'function') window.applyMasterIcons = noop;
    if (typeof window.ensureHybridIcon === 'function') window.ensureHybridIcon = noop;
  }catch(_){}

  // ---- 2) Single source: apply icons strictly from Master map + STICKER_BASE ----
  function normKey(s){
    s = String(s||'').trim().toLowerCase();
    s = s.replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/ß/g,'ss');
    s = s.replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-+|-+$/g,'');
    return s;
  }
  function trySetIcon(iconEl, names, bases){
    var i = 0, j = 0;
    function next(){
      if (!iconEl) return;
      if (i >= bases.length){ iconEl.innerHTML=''; return; }
      var base = bases[i];
      var name = names[j];
      var url = base + name;
      var img = new Image();
      img.alt = '';
      img.onload = function(){ iconEl.innerHTML=''; iconEl.appendChild(img); };
      img.onerror = function(){
        j++;
        if (j >= names.length){ j = 0; i++; }
        next();
      };
      img.src = url;
    }
    next();
  }
  function bases(){
    var base = window.STICKER_BASE || '';
    if (base && !/\/$/.test(base)) base += '/';
    var arr = [base];
    try{
      if (base.indexOf('bereinigte_symbole_3_in_1') >= 0 && base.indexOf('berichtigt_3_in_1') === -1){
        arr.push(base.replace('bereinigte_symbole_3_in_1','berichtigt_3_in_1'));
      } else if (base.indexOf('berichtigt_3_in_1') >= 0 && base.indexOf('bereinigte_symbole_3_in_1') === -1){
        arr.push(base.replace('berichtigt_3_in_1','bereinigte_symbole_3_in_1'));
      }
    }catch(_){}
    return arr;
  }
  function iconNamesFor(label){
  var map = window.__masterIconMapPlain || window.__masterIconMap;
  if (!map || !map.get) return [];
  var key = (typeof window.norm=== 'function') ? window.norm(label) : normKey(label);
  var f = map.get(key);
  if (!f) return [];
  var names = [];
  var x = String(f).trim();
  if (!x) return names;

  // Immer auf Basisnamen ohne Endung gehen
  var base = x.replace(/\.(svg|png)(\?.*)?$/i, '');

  // Standard: *_symbol.png, plus Unterstrich/Bindestrich-Varianten
  ['_symbol.png'].forEach(function(ext){
    var p = base + ext;
    names.push(p);
    var hy = p.replace(/_/g,'-');
    if (hy !== p) names.push(hy);
  });

  return names;
}
  function applyIconsFromMaster(){
    try{
      var map = window.__masterIconMapPlain || window.__masterIconMap;
      if (!map || !map.get) return; // Master not loaded yet; do nothing
      var root = document.getElementById('rb-boxes');
      if (!root) return;
      root.querySelectorAll('.rb-box').forEach(function(box){
        try{
          var titleEl = box.querySelector('.rb-box-titel');
          var iconEl  = box.querySelector('.rb-icon');
          if (!titleEl || !iconEl) return;
          if (iconEl.querySelector('img')) return; // don't duplicate
          var label = titleEl.textContent || '';
          var names = iconNamesFor(label);
          if (!names.length) return;
          trySetIcon(iconEl, names, bases());
        }catch(_){}
      });
    }catch(_){}
  }

  // ---- 3) Hook hydrateMaster & renderBoxes to apply once master is ready ----
  (function(){
    var _hm = window.hydrateMaster;
    window.hydrateMaster = function(text, origin){
      var res = (typeof _hm === 'function') ? _hm(text, origin) : undefined;
      setTimeout(applyIconsFromMaster, 0);
      return res;
    };
  })();

  (function(){
    var _rb = window.renderBoxes;
    if (typeof _rb === 'function' && !_rb.__rbC1Wrapped){
      window.renderBoxes = function(){
        var out = _rb.apply(this, arguments);
        setTimeout(applyIconsFromMaster, 0);
        return out;
      };
      window.renderBoxes.__rbC1Wrapped = true;
    }
  })();

  // ---- 4) Initial attempt after load (in case Master was preloaded) ----
  window.addEventListener('load', function(){ setTimeout(applyIconsFromMaster, 0); }, { once:true });

  window.__rbC1Patched = true;
})();
</script>
<script id="rb-c2-master-parser">
(function(){
  'use strict';
  if (window.__rbC2MasterParser) return;

  function localNorm(s){
    s = String(s||'').trim().toLowerCase();
    s = s.replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/ß/g,'ss');
    s = s.replace(/[^a-z0-9]+/g,'-').replace(/-+/g,'-').replace(/^-+|-+$/g,'');
    return s;
  }
  function normKey(s){
    return (typeof window.norm==='function') ? window.norm(s) : localNorm(s);
  }
  function stripBOMLocal(t){
    if (!t) return t;
    if (t.charCodeAt(0) === 0xFEFF) return t.slice(1);
    return t;
  }
  function normalizeNL(t){
    return String(t||'').replace(/\r\n?/g,'\n');
  }
  function guessDelim(headerLine){
    var h = headerLine || '';
    var cands = [{d:';', n:(h.match(/;/g)||[]).length},
                 {d:',', n:(h.match(/,/g)||[]).length},
                 {d:'\t', n:(h.match(/\t/g)||[]).length},
                 {d:'|', n:(h.match(/\|/g)||[]).length}];
    cands.sort(function(a,b){ return b.n - a.n; });
    return cands[0].n ? (cands[0].d === '\\t' ? '\t' : cands[0].d) : ';';
  }
  function splitRowBasic(line, delim){
    var d = delim || ';';
    if (typeof window.splitRow === 'function'){
      try{ return window.splitRow(line, d); }catch(_){}
    }
    // Simple split (keine komplexe CSV-Quote-Behandlung; genügt für unsere Master)
    return String(line||'').split(d);
  }

  function buildIconMapRobust(text){
    try{
      var cleaned = stripBOMLocal(normalizeNL(text));
      var rawLines = cleaned.split('\n');
      // 1) Entferne leere und 'sep='-Zeilen
      var lines = [];
      for (var i=0;i<rawLines.length;i++){
        var L = String(rawLines[i]||'').trim();
        if (!L) continue;
        if (/^sep\s*=\s*/i.test(L)) continue;
        lines.push(rawLines[i]);
      }
      if (lines.length < 2) return null;

      // 2) Header finden (erste verfügbare Zeile)
      var header = lines[0];
      var delim = (typeof window.detectDelimGuess==='function')
        ? window.detectDelimGuess(header)
        : guessDelim(header);
      var headers = splitRowBasic(header, delim);
      if (!headers || headers.length < 2) return null;

      // 3) "Dateiname"-Zeile suchen (erste Zelle exakt 'Dateiname' case-insensitiv)
      var dateinameIdx = -1;
      for (var r=1; r<Math.min(lines.length, 12); r++){
        var firstCell = splitRowBasic(lines[r], delim)[0] || '';
        if (String(firstCell).trim().toLowerCase() === 'dateiname'){ dateinameIdx = r; break; }
      }
      if (dateinameIdx === -1){
        // Fallback: dritte Zeile (Index 2), wenn vorhanden
        if (lines.length >= 3) dateinameIdx = 2; else return null;
      }

      var svgRow = splitRowBasic(lines[dateinameIdx], delim);
      var map = new Map();
      for (var c=1; c<headers.length; c++){
        var lab = String(headers[c]||'').trim();
        var val = String(svgRow[c]||'').trim();
        if (!lab || !val) continue;
        try{
          map.set(normKey(lab), val);
        }catch(_){}
      }
      return map;
    }catch(e){
      return null;
    }
  }

  // Wrap hydrateMaster: erst Map bauen, dann Original aufrufen (C1-Hook feuert danach)
  (function(){
    var _hm = window.hydrateMaster;
    window.hydrateMaster = function(text, origin){
      try{
        var m = buildIconMapRobust(text);
        if (m) window.__masterIconMap = m;
      }catch(_){}
      return (typeof _hm === 'function') ? _hm(text, origin) : undefined;
    };
  })();

  window.__rbC2MasterParser = true;
})();
</script>
<script id="rb-c3-clean-logs">
(function(){
  'use strict';
  if (window.__rbC3Logs) return;
  var w = console.warn, i = console.info, l = console.log;
  console.warn = function(){
    try{
      var msg = (arguments[0]||'')+'';
      if (msg.indexOf('[Sticker') !== -1) return; // suppress sticker noise
    }catch(_){}
    return w && w.apply(this, arguments);
  };
  console.info = function(){
    try{
      var msg = (arguments[0]||'')+'';
      // allow [Master] Loaded, suppress sticker infos if any
      if (msg.indexOf('[Sticker') !== -1) return;
    }catch(_){}
    return i && i.apply(this, arguments);
  };
  window.__rbC3Logs = true;
})();
</script>
<style data-group="other" id="rb-feld17-25-font-override">
/* Override: Schriftgröße für Felder 17–25 (inkl. Kind-Elemente) */
#feld17, #feld17 *,
#feld18, #feld18 *,
#feld19, #feld19 *,
#feld20, #feld20 *,
#feld21, #feld21 *,
#feld22, #feld22 *,
#feld23, #feld23 *,
#feld24, #feld24 *,
#feld25, #feld25 * {
  font-size: calc(12px * var(--zoom)) !important;
}
</style>
<style data-group="dropdown" id="rb-freitext-override-12px">
/* Freitext-Eingabe (Dropdown-Fuß) – gut lesbar, nicht zu groß */
#rb-dd-free, #rb-dd-free *,
#rb-dd-free-handle, #rb-dd-free-handle * {
  font-size: calc(12px * var(--zoom)) !important;
  line-height: 1.1 !important; /* ein wenig Luft für Unterlängen (g, p, q) */
}
</style>
<script id="rb-feld1-hint-js">

(function(){
  try{
    var h = document.getElementById('rb-feld1-hint');
    if (h && h.parentNode) h.parentNode.removeChild(h);
  }catch(_){}
})();
</script>
<script id="rb-kose-hint-js">
(function(){
  'use strict';
  var LIMIT = (window.RB_HINT_LIMITS && window.RB_HINT_LIMITS.kose) || 17;
  var TEXT  = 'Kosename ist lang. Prüfe ob er gut ins Feld passt! Benutze wenn nötig eine Kurzform.';

  function ensureKoseHint(){
    var anchor = document.getElementById('rb-kose-hint-anchor');
    var btn = document.getElementById('btn-uebernehmen-kosename');
    if (!anchor) anchor = (btn && btn.parentNode) ? btn.parentNode : null;
    if (!anchor) return null;

    var hint = document.getElementById('rb-kose-hint');
    if (!hint){
      hint = document.createElement('div');
      hint.id = 'rb-kose-hint';
      hint.textContent = TEXT;
      hint.style.display = 'none';
    }

    if (hint.parentNode !== anchor){
      if (hint.parentNode) hint.parentNode.removeChild(hint);
      anchor.appendChild(hint);
    }
    return hint;
  }

  function koseValue(){
    var inp = document.getElementById('kosenameInput');
    var v = (inp && inp.value || '').replace('\u00A0',' ').trim();
    return v;
  }

  function updateKose(){
    var hint = ensureKoseHint();
    if (!hint) return;
    var v = koseValue();
    hint.style.display = (v.length >= LIMIT) ? 'block' : 'none';
  }

  function bindKose(){
    var inp = document.getElementById('kosenameInput');
    if (inp && !inp.__koseBoundLen){
      inp.addEventListener('input', updateKose);
      inp.addEventListener('change', updateKose);
      inp.__koseBoundLen = true;
    }
    var btn = document.getElementById('btn-uebernehmen-kosename');
    if (btn && !btn.__koseBoundLen){
      btn.addEventListener('click', function(){ setTimeout(updateKose, 0); });
      btn.__koseBoundLen = true;
    }
  }

  var mo = new MutationObserver(function(){ bindKose(); updateKose(); });
  mo.observe(document.body, { childList:true, subtree:true });

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }
      bindKose(); updateKose();
    });
  } else {
    bindKose(); updateKose();
  }
})();
</script>
<script id="rb-plant-hint-js">
(function(){
  'use strict';
  var LIMIT = (window.RB_HINT_LIMITS && window.RB_HINT_LIMITS.plant) || 17;

  function ensurePlantHint(){
    var anchor = document.getElementById('rb-plant-hint-anchor');
    var btn = document.getElementById('btn-uebernehmen-name');
    if (!anchor) anchor = (btn && btn.parentNode) ? btn.parentNode : null;
    if (!anchor) return null;

    var hint = document.getElementById('rb-plant-hint');
    if (!hint){
      hint = document.createElement('div');
      hint.id = 'rb-plant-hint';
      hint.textContent = (window.RB_STRINGS && RB_STRINGS.plantname_long) || 'Pflanzenname ist lang. Du kannst im Kosenamenfeld eine Kurzform eintragen.';
      hint.style.display = 'none';
    }

    if (hint.parentNode !== anchor){
      if (hint.parentNode) hint.parentNode.removeChild(hint);
      anchor.appendChild(hint);
    }
    return hint;
  }

  function plantValue(){
    var inp = document.getElementById('pflanzensuche');
    var v = (inp && inp.value || '').replace('\u00A0',' ').trim();
    return v;
  }

  function updatePlant(){
    var hint = ensurePlantHint();
    if (!hint) return;
    var v = plantValue();
    hint.style.display = (v.length >= LIMIT) ? 'block' : 'none';
  }

  function bindPlant(){
    var inp = document.getElementById('pflanzensuche');
    if (inp && !inp.__plantBoundLen){
      inp.addEventListener('input', updatePlant);
      inp.addEventListener('change', updatePlant);
      inp.__plantBoundLen = true;
    }
    var btn = document.getElementById('btn-uebernehmen-name');
    if (btn && !btn.__plantBoundLen){
      btn.addEventListener('click', function(){ setTimeout(updatePlant, 0); });
      btn.__plantBoundLen = true;
    }
  }

  var mo = new MutationObserver(function(){ bindPlant(); updatePlant(); });
  mo.observe(document.body, { childList:true, subtree:true });

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }
      bindPlant(); updatePlant();
    });
  } else {
    bindPlant(); updatePlant();
  }
})();
</script>
<style data-group="dropdown" id="rb-hints-style-unified-v3">
/* Einheitlicher Stil für alle Hinweise (weiß + roter Rahmen, schwarze Schrift) */
#rb-dd-free-hint,
#rb-feld1-hint,
#rb-kose-hint,
#rb-plant-hint,
#nohit-toast,
.slot-hint {
  background: #fff !important;
  color: #000 !important;             /* Einheitlich: schwarze Schrift */
  border: 3px solid #b00020 !important; /* Weinrot, 3px */
  border-radius: 6px !important;
  font-size: 12px !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.04) !important;
}

#rb-plant-hint,
#rb-kose-hint{
  margin-top: 4px;
  max-width: 100%;
  box-sizing: border-box;
  position: relative;
  z-index: 10;
}

#rb-kose-hint-anchor{
  display: block;
  width: 100%;
}

#rb-kose-hint{
  position: relative !important;
  float: none !important;
  clear: both !important;
  margin-left: 0 !important;
  align-self: flex-start !important;
}
</style>
<style data-group="base" id="rb-hints-theme">
:root {
  --rb-hint-bg: #fff;
  --rb-hint-text: #000;
  --rb-hint-border-color: #b00020;   /* Weinrot */
  --rb-hint-border-width: 3px;
  --rb-hint-radius: 6px;
  --rb-hint-font-size: 12px;
  --rb-hint-shadow: 0 1px 2px rgba(0,0,0,0.04);
}

/* Einheitlicher Stil für alle Hinweis-Boxen */
#rb-dd-free-hint,
#rb-feld1-hint,
#rb-kose-hint,
#rb-plant-hint,
#nohit-toast,
.slot-hint {
  background: var(--rb-hint-bg) !important;
  color: var(--rb-hint-text) !important;
  border: var(--rb-hint-border-width) solid var(--rb-hint-border-color) !important;
  border-radius: var(--rb-hint-radius) !important;
  font-size: var(--rb-hint-font-size) !important;
  box-shadow: var(--rb-hint-shadow) !important;
}
</style>
<script id="rb-dd-free-hint-linebreak-js">
(function(){
  'use strict';
  function applyBreak(){
    var foot = document.getElementById('rb-dd-foot');
    if(!foot) return;
    var el = foot.querySelector('.rb-muted');
    if(!el) return;
    if(el.__rbBreakApplied) return;
    var t = el.textContent || "";
    var repl = t.replace(/\s*&\s*/, " &\n");
    if(repl !== t){
      el.textContent = repl;
    }
    el.__rbBreakApplied = true;
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', applyBreak);
  } else { applyBreak(); }
  try{
    var mo = new MutationObserver(applyBreak);
    mo.observe(document.body, {childList:true, subtree:true});
  }catch(e){}
})();
</script>
<style data-group="dropdown" id="rb-dd-free-hint-overlay-css">
/* Text normalgewichtig; dickere Pfeile über Unicode (⬆⬇) */
#rb-dd-foot .rb-muted{
  position: relative !important;
  color: transparent !important;   /* Originaltext ausblenden */
  min-height: 2.4em !important;
  line-height: 1.2 !important;
  padding: 2px 8px !important;
  overflow: visible !important;
  font-weight: 400 !important;      /* Container nicht fett */
}
#rb-dd-foot .rb-muted::before,
#rb-dd-foot .rb-muted::after{
  position: absolute;
  left: 8px;
  right: 8px;
  color: #333;                      /* Text grau */
  font-weight: 400 !important;      /* Sicherstellen: Text nicht fett */
  pointer-events: none;
  white-space: nowrap;
}
#rb-dd-foot .rb-muted::before{
  content: "Oben Text tippen ⬆";   /* U+2B06 dicker Pfeil */
  top: 2px;
}
#rb-dd-foot .rb-muted::after{
  content: "Unten ins Feld ziehen ⬇";  /* U+2B07 dicker Pfeil */
  top: 1.45em;
}
</style>
<style data-group="base" id="mid-toolbar-fixed-width">
  /* Einzelschritt: Mittelblock kompakt & einheitlich (nur CSS, kein JS) */
  :root{ --mid-w: 260px; } /* << Stellwert: schmaler als zuvor; bei Bedarf anpassen */

  /* Nur der Mittelblock "Block: Namen" wird auf feste Breite gesetzt */
  .steuerleiste [aria-label="Block: Namen"]{
    flex: 0 0 var(--mid-w) !important;
    width: var(--mid-w) !important;
    max-width: var(--mid-w) !important;
  }

  /* Alle unmittelbaren Kinder füllen genau diese Breite */
  .steuerleiste [aria-label="Block: Namen"] > *{
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
  }

  /* Sicherstellen, dass dynamische Hinweise ebenfalls vollbreit sind */
  .steuerleiste [aria-label="Block: Namen"] #rb-kose-hint,
  .steuerleiste [aria-label="Block: Namen"] #rb-plant-hint{
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;

  }
</style>
<script id="rb-hints-config-js">
// Zentrale Limits für Längenhinweise
window.RB_HINT_LIMITS = {
  kose: 17,
  plant: 17
};
</script>
<style data-group="card" id="kartenbereich-bfc-fix">
  /* Verhindert, dass der Kartenbereich nach unten „überlappt“:
     eigener Block-Formatting-Context + etwas Bodenluft */
  #kartenbereich{
    overflow: hidden !important;                     /* BFC: keine Überlappung der nachfolgenden Elemente */
    padding-bottom: calc(64px * var(--zoom)) !important;  /* kleine Bodenluft innerhalb des Bereichs */
  }
</style>
<style data-group="card" id="kartenbereich-zoom-clip-fix">
  /* Scrollbar bekommt reservierten Platz, ändert Inhalt nicht mehr */
  #spalte-rechts{ scrollbar-gutter: stable; }

  /* Kartenbereich: eigener Block-Kontext ohne Clipping */
  #kartenbereich{
    overflow-x: visible !important;
    overflow-y: visible !important;
    display: flow-root !important;        /* BFC ohne overflow:hidden */
    padding-right: 8px !important;        /* etwas Abstand zur Scrollbar */
    /* Bodenluft belassen, damit Buttons erreichbar bleiben */
    padding-bottom: calc(64px * var(--zoom)) !important;
  }
</style>
<style data-group="base" id="karte-fertig-from-ref-logic">
  /* Aus Referenz übernommen, aber mit fixer 1.5cm Lücke (zoom-synchron) */
  :root { --gap-1p5cm: 56.7px; }
  #spalte-rechts .karte-fertig-actions{
    margin-top: calc(var(--gap-1p5cm) * var(--zoom)) !important;
    display: flex;
    justify-content: center;
    position: static !important;  /* kein Sticky, kein Overlay */
    clear: both;
  }
  #btn-karte-fertig-ok{
    padding: 10px 16px;
    border: 1px solid #000;
    background: #69B07F;
    color: #000;
    border-radius: 8px;
    font: inherit;
    cursor: pointer;
  }
  #btn-karte-fertig-ok:hover{ filter: brightness(0.97); }
  #btn-karte-fertig-ok:active{ filter: brightness(0.94); }
</style>
<style data-group="card" id="karte-fertig-guard-flowroot">
  #kartenbereich{ display: flow-root !important; }
</style>
<script id="ok-button-clip-js">
(function(){
  'use strict';
  function $(sel, ctx){ return (ctx||document).querySelector(sel); }
  function getZoom(){
    var v = getComputedStyle(document.documentElement).getPropertyValue('--zoom');
    var z = parseFloat(v); return (isFinite(z) && z>0) ? z : 1;
  }
  function pxFromCm(cm){ return cm * 37.7952755906; }
  function pxFromMm(mm){ return mm * 3.77952755906; }

  function place(){
    var wrap = $('.front-wrapper');
    var controls = $('#front-controls') || $('.front-controls');
    var clip = wrap ? $('.ok-clip', wrap) : null;
    if(!wrap || !controls || !clip) return;

    var z = getZoom();
    var gap = pxFromCm(1.5) * z + pxFromMm(2); // 1.5cm + 2mm, zoom-synchron

    // Verwende visuelle Positionen: Abstand von Wrap-Top bis Controls-Bottom
    var rWrap = wrap.getBoundingClientRect();
    var rCtl  = controls.getBoundingClientRect();
    var baseTop = (rCtl.bottom - rWrap.top);

    clip.style.top = (baseTop + gap) + 'px';
  }

  function rehook(){
    // Klicks auf Zoom-Buttons (nach Textinhalt) neu platzieren
    document.addEventListener('click', function(ev){
      var t = ev.target;
      var txt = (t && (t.innerText || t.textContent) || '').toLowerCase();
      if (txt.indexOf('zoom') !== -1){
        setTimeout(place, 0);
        setTimeout(place, 60);
        setTimeout(place, 200);
      }
    }, true);

    // Beobachte Änderungen an :root style (z.B. --zoom)
    var root = document.documentElement;
    var obs = new MutationObserver(function(){
      place();
    });
    obs.observe(root, { attributes:true, attributeFilter:['style'] });
  }

  window.addEventListener('load', function(){
    place();
    rehook();
    setTimeout(place, 50);
    setTimeout(place, 200);
  }, {passive:true});
  window.addEventListener('resize', place, {passive:true});
})();
</script>
<div id="extra-bottom-1cm" style="height: calc(10mm * var(--zoom));"></div>
<script id="mark-auswahl-box">
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    // Finde alle selektierbaren Rechtecke und markiere die mit Text "Auswahl"
    var nodes = document.querySelectorAll('.rb-box-rect.selectable');
    nodes.forEach(function(n){
      var t = (n.textContent || '').trim().toLowerCase();
      if (t === 'auswahl') { n.classList.add('is-auswahl'); }
    });
  }catch(e){}
});
</script>
<script id="sticker-hints-table-loader">
(function(){
  'use strict';
  var MASTER_PATHS = [window.masterPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv"];
  function normKey(s){
    s = (s||"").toLowerCase();
    s = s.replace(/ä/g,"ae").replace(/ö/g,"oe").replace(/ü/g,"ue");
    s = s.replace(/\s+/g,"-").replace(/[^a-z0-9\-]/g,"-").replace(/\-+/g,"-");
    s = s.replace(/^\-+|\-+$/g,"");
    return s;
  }
  function parseCSV(text){
    // normalize newlines
    var CR = String.fromCharCode(13), LF = String.fromCharCode(10);
    if (text.indexOf(CR+LF) !== -1) text = text.split(CR+LF).join(LF);
    if (text.indexOf(CR)   !== -1) text = text.split(CR).join(LF);
    var lines = text.split(LF);
    var rows = [];
    for (var r=0;r<lines.length;r++){
      var line = lines[r];
      if (!line || !line.trim()) continue;
      var cells = [], cell = "", inQ = false;
      for (var i=0;i<line.length;i++){
        var ch = line[i];
        if (ch === '"'){ inQ = !inQ; cell += ch; }
        else if (!inQ && (ch === ';' || ch === ',')){ cells.push(cell); cell=""; }
        else { cell += ch; }
      }
      cells.push(cell);
      // unquote
      for (var j=0;j<cells.length;j++){
        var c = (cells[j]||"").trim();
        if (c.startsWith('"') && c.endsWith('"')) c = c.slice(1,-1);
        if (c.indexOf('""') !== -1) c = c.split('""').join('"');
        cells[j] = c;
      }
      rows.push(cells);
    }
    return rows;
  }
  async function fetchText(url){
    try{
      var res = await fetch(url, {cache: 'no-store'});
      if(!res.ok) return null;
      return await res.text();
    }catch(e){ return null; }
  }
  async function loadMaster(){
    // Try server paths first
    for (var i=0;i<MASTER_PATHS.length;i++){
      var t = await fetchText(MASTER_PATHS[i]);
      if (t) return {text:t, src:MASTER_PATHS[i]};
    }
    // Fallback: if a file input with id=fileMaster exists and has a file, read it
    try{
      var fm = document.getElementById('fileMaster');
      if (fm && fm.files && fm.files[0]){
        var f = fm.files[0];
        var txt = await f.text();
        return {text:txt, src:f.name};
      }
    }catch(e){}
    return null;
  }
  async function boot(){
    var m = await loadMaster();
    if(!m){ console.warn("[HINTS] Master nicht gefunden."); return; }
    var rows = parseCSV(m.text);
    if (!rows.length || rows.length < 8 || rows[0].length < 2){
return;
    }
    var hints = {};
    for (var c=1;c<rows[0].length;c++){
      // Zeile 3 (index 2) = Dateiname; fallback: Spaltenkopf
      var raw = (rows[2] && rows[2][c]) ? rows[2][c] : (rows[0][c] || "");
      if (!raw) continue;
      var bn = raw.split('/').pop();
      if (bn.toLowerCase().endsWith(".svg")) bn = bn.slice(0,-4);
      var key = normKey(bn);
      if (!key) continue;
      var w = String((rows[6] && rows[6][c]) || "").trim().toLowerCase();
      var alt = String((rows[7] && rows[7][c]) || "").trim();
      var isWarn = (w === "1" || w === "x" || w === "true" || w === "ja" || w === "warn");
      if (isWarn || alt){ hints[key] = { warn: isWarn ? 1 : 0, alt: alt }; }
    }
    var n = Object.keys(hints).length;
    if (n){
      window.STICKER_HINTS = hints;
      document.dispatchEvent(new Event('sticker-hints-ready'));
    }else{
    }
  }
  document.addEventListener("DOMContentLoaded", boot);
})();
</script>
<script>
(function(){
  var sel = document.getElementById('smileySelect');
  var dd  = document.getElementById('feld7-dd');
  var trg = document.getElementById('feld7-trigger');
  var ico = document.getElementById('feld7-icon');
  var lab = document.getElementById('feld7-label');
  var menu= document.getElementById('feld7-menu');
  if(!sel || !dd || !trg || !menu) return;
  var items = Array.prototype.slice.call(menu.querySelectorAll('.feld7-item'));

  function applyValue(v){
    var old = sel.value;
    sel.value = v;
    if (old !== v) sel.dispatchEvent(new Event('change', {bubbles:true}));
    var it = items.find(function(n){ return n.getAttribute('data-value')===v; }) || items[0];
    var img = it.getAttribute('data-img') || '';
    var text = (it.textContent||'').trim();
    if(img){ ico.style.display=''; ico.src = img; } else { ico.style.display='none'; ico.removeAttribute('src'); }
    lab.textContent = text;
    items.forEach(function(n){ n.setAttribute('aria-selected', n===it ? 'true':'false'); });
  }

  function open(){ dd.classList.add('open'); trg.setAttribute('aria-expanded','true'); var s=menu.querySelector('.feld7-item[aria-selected="true"]')||menu.querySelector('.feld7-item'); if(s)s.focus(); }
  function close(){ dd.classList.remove('open'); trg.setAttribute('aria-expanded','false'); }
  function choose(li){ if(!li) return; applyValue(li.getAttribute('data-value')||''); close(); trg.focus(); }

  trg.addEventListener('click', function(){ dd.classList.contains('open') ? close() : open(); });
  items.forEach(function(li){ li.addEventListener('click', function(){ choose(li); }); });
  document.addEventListener('click', function(e){ if(!dd.contains(e.target)) close(); });

  // Init from current select value (falls extern gesetzt)
  applyValue(sel.value || '');
})();
</script>
<script>
// Feld 7 – Logo Dual-Path Fallback (primary -> alt, falls 404)
(function(){ 
  var primary = "logo_schwarz_fuer_karte.png";
  var alt = "logofuerfeld7.png";

  function attachFallback(imgEl, altSrc){
    if(!imgEl) return;
    var triedAlt = false;
    imgEl.onerror = function(){ 
      if(triedAlt) return; 
      triedAlt = true; 
      imgEl.src = altSrc; 
    };
  }

  // Menu item image
  var logoItem = document.querySelector("#feld7-menu .feld7-item[data-value='logo']");
  if (logoItem) {
    var mi = logoItem.querySelector("img");
    attachFallback(mi, alt);
  }

  // Attach on change to set trigger icon and fallback when 'logo' chosen
  (function(){
    var sel = document.getElementById('smileySelect');
    var ico = document.getElementById('feld7-icon');
    var menu = document.getElementById('feld7-menu');
    if(!sel || !ico || !menu) return;
    sel.addEventListener('change', function(){
      try{ 
        var val = sel.value;
        if (val === 'logo') {
          var li = menu.querySelector(".feld7-item[data-value='logo']");
          var p = (li && li.getAttribute('data-img')) || "logo_schwarz_fuer_karte.png";
          var a = (li && (li.getAttribute('data-altimg') || "logofuerfeld7.png"));
          ico.src = p;
          attachFallback(ico, a);
        }
      }catch(e){}
    });
  })();
})();
</script>
<script>
// Feld 7 – Logo: multiple filename variants fallback (case/extension/name)
(function(){
  function unique(arr){ return arr.filter((v,i)=>arr.indexOf(v)===i); }
  function withExt(p, ext){ return p.replace(/\.(svg|png)$/i, ext); }
  function capFirst(s){ return s.charAt(0).toUpperCase()+s.slice(1); }

  // Get current primary/alt from DOM (menu item)
  var li = document.querySelector("#feld7-menu .feld7-item[data-value='logo']");
  if(!li) return;
  var p = li.getAttribute("data-img") || "";
  var a = li.getAttribute("data-altimg") || "";

  // Build candidates list
  var candidates = [];
  function addVariants(path){
    if(!path) return;
    candidates.push(path);
    // uppercase extension
    candidates.push(withExt(path, ".SVG"));
    // capitalize whole filename (first letter)
    candidates.push(path.replace(/([^\/]+)$/, (m)=>capFirst(m)));
    // capitalize last token (e.g., Karte.svg)
    candidates.push(path.replace(/([^\/_]+)(\.svg)$/i, (m, name, ext)=>capFirst(name)+ext));
    candidates.push(path.replace(/_([a-z])([^\/]*)(\.svg)$/i, (m, c, rest, ext)=>"_"+c.toUpperCase()+rest+ext));
  }
  addVariants(p); addVariants(a);
  // Generic fallbacks
  candidates.push(pathJoin(dirOf(p), "logo.png"));
  candidates.push(pathJoin(dirOf(p), "Logo.png"));

  candidates = unique(candidates);

  function dirOf(path){ var i=path.lastIndexOf("/"); return i>=0? path.slice(0,i+1):""; }
  function pathJoin(dir, file){ return (dir||"")+file; }

  function trySources(imgEl, list){
    if(!imgEl) return;
    var i=0;
    function setNext(){
      if(i>=list.length){ imgEl.onerror=null; return; }
      var src=list[i++];
      // Skip if it's already set
      if(imgEl.src && imgEl.src.indexOf(src)>=0){ setNext(); return; }
      imgEl.src = src;
    }
    imgEl.onerror = setNext;
    setNext(); // kick off
  }

  // Apply to the menu item image
  var menuImg = li.querySelector("img");
  if (menuImg) trySources(menuImg, candidates);

  // Apply when selecting 'logo' for the trigger icon
  var sel = document.getElementById('smileySelect');
  var ico = document.getElementById('feld7-icon');
  if (sel && ico){
    sel.addEventListener('change', function(){
      if (sel.value === 'logo'){
        trySources(ico, candidates.slice());
      }
    });
  }
})();
</script>
<script>
/* Feld 7 – Logo-Option sicherstellen (Primary: Unterstrich, Fallback: ohne) */
(function(){
  var base = '';
  var primary = base + 'logo_schwarz_fuer_karte.png';
  var alt     = base + 'logoschwarzfuerkarte.png';

  var sel = document.getElementById('smileySelect');
  if (!sel) return;

  // Hidden-Select: Logo-Option anlegen/aktualisieren
  var opt = sel.querySelector('option[value="logo"]');
  if (!opt) {
    opt = document.createElement('option');
    opt.value = 'logo';
    opt.textContent = 'Logo';
    sel.appendChild(opt);
  }
  opt.setAttribute('data-img', primary);

  // Menü (unterstütze beide Varianten aus unseren Builds)
  var menu = document.getElementById('feld7-menu') || document.getElementById('smileyMenu');
  var dd   = document.getElementById('feld7-dd')   || document.getElementById('smileyDd');
  var trg  = document.getElementById('feld7-trigger') || document.getElementById('smileyTrigger');
  var ico  = document.getElementById('feld7-icon')    || document.getElementById('smileyIcon');
  var lab  = document.getElementById('feld7-label')   || document.getElementById('smileyLabel');

  // Logo-Menüpunkt anlegen, falls nicht vorhanden
  var item = menu && menu.querySelector('[data-value="logo"]');
  if (menu && !item) {
    var cls = (menu.id === 'feld7-menu') ? 'feld7-item' : 'smiley-item';
    item = document.createElement('li');
    item.className = cls;
    item.setAttribute('role','option');
    item.setAttribute('tabindex','-1');
    item.setAttribute('data-value','logo');
    item.setAttribute('data-img', primary);
    item.setAttribute('data-altimg', alt);

    var img = new Image();
    img.alt = 'Logo';
    var triedAlt = false;
    img.onerror = function(){ if(!triedAlt){ triedAlt = true; img.src = alt; } };
    img.src = primary;
    item.appendChild(img);

    var t = document.createElement('span');
    t.textContent = 'Logo';
    item.appendChild(t);

    item.addEventListener('click', function(){
      sel.value = 'logo';
      sel.dispatchEvent(new Event('change', {bubbles:true}));
      if (ico){ ico.style.display=''; ico.src = primary; }
      if (lab){ lab.textContent = 'Logo'; }
      if (dd) dd.classList.remove('open');
      if (trg) trg.focus();
    });

    menu.appendChild(item);
  }
})();
</script>
<script id="feld7-symbol-bind">
(function(){
  // Ziel: Symbol aus dem Feld-7-Dropdown in die Vorschau (div#symbolAnzeige) setzen.
  var dd = document.getElementById('feld7-dd');
  var sel = document.getElementById('smileySelect'); // Fallback / Tastatur
  var slot = document.getElementById('symbolAnzeige');
  if(!slot){ return; }

  function setSymbol(src){
    if(!slot) return;
    if(!src || src === 'none'){ slot.innerHTML = ''; return; }
    var img = new Image();
    img.alt = 'Symbol';
    img.style.maxWidth = '100%';
    img.style.maxHeight = '100%';
    img.style.objectFit = 'contain';
    img.src = src;
    slot.innerHTML = '';
    slot.appendChild(img);
  }

  // 1) Klick auf Custom-Dropdown-Option
  if(dd){
    dd.addEventListener('click', function(ev){
      var li = ev.target.closest('li');
      if(!li) return;
      // Quelle bevorzugt vom <img src="..."> in der Option nehmen
      var img = li.querySelector('img');
      var src = (img && img.getAttribute('src')) || li.getAttribute('data-src') || '';
      // "kein Symbol" handlen
      var val = (li.getAttribute('data-value') || '').toLowerCase();
      if(val.includes('kein') || val === 'none' || val === 'null'){
        setSymbol('');
      }else{
        setSymbol(src);
      }
    });
  }

  // 2) Fallback: Standard-Select (falls benutzt)
  if(sel){
    var map = {
      '': '',
      'kein-symbol': '',
      'kein symbol': '',
      'smiley': 'smiley.png',
      'pfeil':  'pfeil.png',
      'logo':  'logo_fuer_feld7.png'
    };
    sel.addEventListener('change', function(){
      var key = (sel.value || '').toLowerCase().trim();
      setSymbol(map[key] || '');
    });
  }
})();
</script>
<script id="feld7-clear-default">
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  var slot = document.getElementById('symbolAnzeige');
  if (slot) {
    // Wenn beim Laden noch Text (z.B. "logo") drinsteht: leeren
    if (slot.childNodes.length === 1 && slot.childNodes[0].nodeType === Node.TEXT_NODE) {
      slot.textContent = '';
    }
  }
});
</script>
<script id="fm-wixrahmen-plus70">
// Findet zur Laufzeit den Container mit berechneter Breite ~980px
// und erhöht dessen sichtbare Höhe um +70px (ohne Rest des Layouts zu brechen).
window.addEventListener('load', function(){
  try{
    var divs = Array.from(document.querySelectorAll('div'));
    var candidates = divs.filter(function(el){
      var cs = getComputedStyle(el);
      var w = parseFloat(cs.width) || 0;
      return Math.round(w) === 980;
    });
    if(!candidates.length) return;
    // Wähle den größten Kandidaten (höchste aktuelle Höhe)
    var target = candidates.reduce(function(a,b){
      return (a.getBoundingClientRect().height >= b.getBoundingClientRect().height) ? a : b;
    });
    var cs = getComputedStyle(target);
    var h = target.getBoundingClientRect().height;
    var newH = Math.round(h + 86);
    // Wenn Element eine feste Höhe hat -> erhöhen; sonst min-height setzen
    if(cs.height !== 'auto' && !cs.height.endsWith('%')){
      target.style.height = newH + 'px';
    } else {
      target.style.minHeight = newH + 'px';
    }
    // Fallback: wenn gar keine Höhe messbar war, erhöhe Innenabstand unten
    if(!h || h < 10){
      var pb = parseFloat(cs.paddingBottom) || 0;
      target.style.paddingBottom = (pb + 86) + 'px';
    }
    target.setAttribute('data-wixrahmen-980', 'height+' + 86);
  }catch(e){ /* still */ }
});</script>
<style data-group="other" id="wixrahmen-plus70">
/* Wixrahmen (980px breit) unten um +70px erweitern */
.frame{ padding-bottom: calc(86px + var(--frame-extra, 0px)) !important; }
</style>
<style data-group="base" id="feld6-input-minus-2cm">
/* Feld 6 (Spruch) – Eingabefeld im Dropdown/Popup 2 cm schmaler */
#spruchPopup .sp-body #spruchPopupInput,
#spruchPopupInput{
  box-sizing: border-box !important;
  width: calc(100% - 2cm) !important;
  max-width: calc(100% - 2cm) !important;
}
</style>
<style data-group="base" id="feld6-input-minus-1_5cm">
/* Feld 6 – Eingabefeld 1,5 cm schmaler (übersteuert die vorherigen 2 cm) */
#spruchPopup .sp-body #spruchPopupInput,
#spruchPopupInput{
  box-sizing: border-box !important;
  width: calc(100% - 1.5cm) !important;
  max-width: calc(100% - 1.5cm) !important;
}
</style>
<style data-group="base" id="rb-dd-free-hint-stable-right">
#rb-dd-body {
  display: grid;
  grid-template-columns: 1fr 260px;
  grid-auto-rows: min-content;
  column-gap: 10px;
  align-items: center;
}
/* Eingabefeld (linke Spalte) */
#rb-dd-free{ grid-column: 1; }
/* Hinweis rechts, über beide Zeilen (Input + Buttons) */
#rb-dd-free-hint{
  grid-column: 2;
  grid-row: 1 / span 2;
  align-self: start;
  background:#fff !important;
  color:#000 !important;
  border:3px solid #b00020 !important;
  border-radius:6px !important;
  padding:8px 10px !important;
  font-size:12px !important;
  line-height:1.35 !important;
  box-shadow:0 1px 2px rgba(0,0,0,0.05) !important;
  max-width: 260px;
}
/* Buttons bleiben links unter dem Input (Standardfluss) */
</style>
<script id="rb-dd-free-hint-toggle-stable">
(function(){
  var sel = document.getElementById('spruchSelect');
  var hint = document.getElementById('rb-dd-free-hint');
  function update(){
    if(!sel || !hint) return;
    var show = (sel.value === '__custom__');
    hint.style.display = show ? 'block' : 'none';
  }
  if(sel){
    sel.addEventListener('change', update);
    // Initial
    update();
  }
})();
</script>
<style data-group="base" id="rb-dd-free-hint-flex-layout">
/* Ensure dropdown containers allow the hint to be seen */
#rb-dropdown, #rb-dd-body { overflow: visible !important; }

/* Place input (left) and hint (right) without changing the input width */
#rb-dd-body {
  display: flex !important;
  align-items: flex-start;
  gap: 10px;
}
#rb-dd-free{ flex: 1 1 auto; min-width: 0; } /* input area */
#rb-dd-free-hint{
  flex: 0 0 240px;
  display: block; /* default visible; JS will toggle based on selection */
  background:#fff !important;
  color:#000 !important;
  border:3px solid #b00020 !important;
  border-radius:6px !important;
  padding:8px 10px !important;
  font-size:12px !important;
  line-height:1.35 !important;
  box-shadow:0 1px 2px rgba(0,0,0,0.05) !important;
}
</style>
<script id="o1p-bind-auswahl">
// O1q: Robuster Klick-Handler für "Auswahl" (verschiedene Markups)
(function(){
  function isAuswahlButton(el){
    if(!el) return false;
    const txt = (el.innerText || el.textContent || '').trim().toLowerCase();
    if(txt === 'auswahl') return true;
    // Fallback: data-Attribute
    if(el.dataset && (el.dataset.action === 'auswahl' || el.dataset.role === 'auswahl')) return true;
    return false;
  }
  document.addEventListener('click', function(ev){
    const target = ev.target;
    // finde die Box
    const box = target.closest && target.closest('.rb-box');
    if(!box) return;
    // finde möglichen Button/Klickfläche
    let btn = target.closest('button, .rb-cta, .btn, [role="button"], .auswahl');
    if(!isAuswahlButton(btn)){
      // Fallback: suche in der Box nach einem Button mit Text "Auswahl"
      btn = Array.from(box.querySelectorAll('button, .rb-cta, .btn, [role="button"], .auswahl')).find(isAuswahlButton);
    }
    if(!isAuswahlButton(btn)) return;
    // Dropdown ermitteln
    const dd = document.getElementById('rb-dropdown');
    if(!dd) return;
    // Position direkt unter der Box
    const rect = box.getBoundingClientRect();
    const x = window.scrollX + rect.left + 8;
    const y = window.scrollY + rect.bottom + 6;
    dd.style.position = 'absolute';
    dd.style.left = x + 'px';
    dd.style.top = y + 'px';
    dd.style.zIndex = 9999;
    dd.style.display = 'block';
    dd.classList.add('open');
    // Schließen bei Außenklick
    const closer = function(e){
      if(!dd.contains(e.target) && !box.contains(e.target)){
        dd.classList.remove('open');
        dd.style.display = 'none';
        document.removeEventListener('click', closer, true);
      }
    };
    document.addEventListener('click', closer, true);
    ev.preventDefault();
  }, true);
})();
</script>
<script>
// --- Slot↔Slot Tausch/Umsetzen für Sticker (Front 2–5, Back 8–16) ---
// Einzelschritt: fügt nur eine Drop-Logik für Slot→Slot hinzu. Keine Änderung an SVG/Koordinaten.
// Drops aus roten Boxen laufen weiter über empfangeSticker(...).

(function(){
  'use strict';
  // Quelle: Slot-Drag setzt text/plain = 'feldX' (siehe makeSlotDraggable)
  var SLOT_RE = /^feld(2|3|4|5|8|9|10|11|12|13|14|15|16)$/;

  function copyDataset(src, dst){
    if (!dst || !dst.dataset) return;
    // Ziel zunächst säubern
    delete dst.dataset.rbType;
    delete dst.dataset.rbLabel;
    delete dst.dataset.rbOriginSticker;
    // dann Werte (falls vorhanden) übernehmen
    if (src && src.dataset){
      if (src.dataset.rbType)          dst.dataset.rbType = src.dataset.rbType;
      if (src.dataset.rbLabel)         dst.dataset.rbLabel = src.dataset.rbLabel;
      if (src.dataset.rbOriginSticker) dst.dataset.rbOriginSticker = src.dataset.rbOriginSticker;
    }
  }

  function swapDataset(a, b){
    if (!a || !b || !a.dataset || !b.dataset) return;
    var aType=a.dataset.rbType, aLabel=a.dataset.rbLabel, aOrig=a.dataset.rbOriginSticker;
    var bType=b.dataset.rbType, bLabel=b.dataset.rbLabel, bOrig=b.dataset.rbOriginSticker;
    // a <- b
    if (bType)  a.dataset.rbType  = bType;  else delete a.dataset.rbType;
    if (bLabel) a.dataset.rbLabel = bLabel; else delete a.dataset.rbLabel;
    if (bOrig)  a.dataset.rbOriginSticker = bOrig; else delete a.dataset.rbOriginSticker;
    // b <- a
    if (aType)  b.dataset.rbType  = aType;  else delete b.dataset.rbType;
    if (aLabel) b.dataset.rbLabel = aLabel; else delete b.dataset.rbLabel;
    if (aOrig)  b.dataset.rbOriginSticker = aOrig; else delete b.dataset.rbOriginSticker;
  }

  function onSlotDrop(ev){
    try{
      var target = ev.currentTarget;
      var txt = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
      if (!SLOT_RE.test(txt)) return; // kein Slot→Slot Drop → Standard-empfangeSticker übernimmt
      ev.preventDefault();
      ev.stopImmediatePropagation(); // verhindert Aufruf von inline ondrop=empfangeSticker(...)

      if (txt === target.id) return; // Drop auf sich selbst → no-op

      var src = document.getElementById(txt);
      if (!src) return;

      var srcHTML = src.innerHTML;
      var tgtHTML = target.innerHTML;

      var targetEmpty = !tgtHTML || !tgtHTML.trim();

      if (targetEmpty){
        // MOVE: Inhalt + Dataset von src → target, src leeren
        target.innerHTML = srcHTML;
        copyDataset(src, target);
        src.innerHTML = '';
        if (src.dataset){
          delete src.dataset.rbType;
          delete src.dataset.rbLabel;
          delete src.dataset.rbOriginSticker;
        }
      }else{
        // SWAP: Inhalte und Datasets tauschen
        target.innerHTML = srcHTML;
        src.innerHTML = tgtHTML;
        swapDataset(src, target);
      }

      // Nach DOM-Update: Draggability für Mülleimer weiter sicherstellen
      try{
        if (typeof makeSlotDraggable === 'function'){
          makeSlotDraggable(target);
          makeSlotDraggable(src);
        }
      }catch(_){}
    }catch(_){}
  }

  function onSlotDragOver(ev){
    try{
      var txt = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
      if (SLOT_RE.test(txt)){
        ev.preventDefault();
        try{ ev.dataTransfer.dropEffect = 'move'; }catch(_){}
      }
    }catch(_){}
  }

  function bindSlotSwap(){
    var ids = [2,3,4,5,7,8,9,10,11,12,13,14,15,16].map(function(n){ return 'feld'+n; });
    ids.forEach(function(id){
      var slot = document.getElementById(id);
      if (!slot || slot.__rbSwapBound) return;
      slot.addEventListener('dragover', onSlotDragOver, true);
      slot.addEventListener('drop', onSlotDrop, true);
      slot.__rbSwapBound = true;
    });
  }

  // sofort versuchen zu binden; falls Slots später gefüllt werden, erneut binden
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bindSlotSwap, {once:true});
  }else{
    bindSlotSwap();
  }
  // Fallback: nach Umschalten/DOM-Manipulationen Slots erneut binden
  setTimeout(bindSlotSwap, 0);
})();
</script>
<script>
// --- Slot↔Slot Tausch/Umsetzen für TEXT (Rückseite Felder 17–25) ---
// Einzelschritt: fügt nur eine Drop-Logik für Slot→Slot hinzu. Keine Änderung an SVG/Koordinaten.
// Drops aus Dropdown (Freitext/Optionen) laufen weiter über empfangeText(...).

(function(){
  'use strict';
  var SLOT_RE = /^feld(1[7-9]|2[0-5])$/;

  function copyDatasetText(src, dst){
    if (!dst || !dst.dataset) return;
    // reset target markers
    delete dst.dataset.rbType;
    delete dst.dataset.rbLabel;
    delete dst.dataset.rbOrigin;
    if (src && src.dataset){
      if (src.dataset.rbType)   dst.dataset.rbType   = src.dataset.rbType;
      if (src.dataset.rbLabel)  dst.dataset.rbLabel  = src.dataset.rbLabel;
      if (src.dataset.rbOrigin) dst.dataset.rbOrigin = src.dataset.rbOrigin;
    }
  }

  function swapDatasetText(a, b){
    if (!a || !b || !a.dataset || !b.dataset) return;
    var aType=a.dataset.rbType, aLabel=a.dataset.rbLabel, aOrig=a.dataset.rbOrigin;
    var bType=b.dataset.rbType, bLabel=b.dataset.rbLabel, bOrig=b.dataset.rbOrigin;
    // a <- b
    if (bType)  a.dataset.rbType  = bType;  else delete a.dataset.rbType;
    if (bLabel) a.dataset.rbLabel = bLabel; else delete a.dataset.rbLabel;
    if (bOrig)  a.dataset.rbOrigin = bOrig; else delete a.dataset.rbOrigin;
    // b <- a
    if (aType)  b.dataset.rbType  = aType;  else delete b.dataset.rbType;
    if (aLabel) b.dataset.rbLabel = aLabel; else delete b.dataset.rbLabel;
    if (aOrig)  b.dataset.rbOrigin = aOrig; else delete b.dataset.rbOrigin;
  }

  function onTextSlotDragOver(ev){
    try{
      var txt = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
      if (SLOT_RE.test(txt)){
        ev.preventDefault();
        try{ ev.dataTransfer.dropEffect = 'move'; }catch(_){}
      }
    }catch(_){}
  }

  function onTextSlotDrop(ev){
    try{
      var target = ev.currentTarget;
      var payload = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
      if (!SLOT_RE.test(payload)) return; // kein Slot→Slot → Standard-Handler (empfangeText) darf laufen
      ev.preventDefault();
      ev.stopImmediatePropagation();
      try{ if (ev.dataTransfer && ev.dataTransfer.clearData){ ev.dataTransfer.clearData(); ev.dataTransfer.setData('text/plain',''); } }catch(_){} // verhindert andere Drop-Handler (inkl. inline ondrop / Capture)

      if (payload === target.id) return; // no-op

      var src = document.getElementById(payload);
      if (!src) return;

      var srcHTML = src.innerHTML;
      var tgtHTML = target.innerHTML;
      var targetEmpty = !tgtHTML || !tgtHTML.trim();

      if (targetEmpty){
        // MOVE
        target.innerHTML = srcHTML;
        copyDatasetText(src, target);
        src.innerHTML = '';
        if (src.dataset){
          delete src.dataset.rbType;
          delete src.dataset.rbLabel;
          delete src.dataset.rbOrigin;
        }
      }else{
        // SWAP
        target.innerHTML = srcHTML;
        src.innerHTML = tgtHTML;
        swapDatasetText(src, target);
      }

      // Slots sind selbst draggable (ID wird gesetzt) – kein Rebind nötig.
      // Trotzdem leichtes Rebind-Signal, falls Funktion existiert.
      try{
        if (typeof makeSlotDraggable === 'function'){
          makeSlotDraggable(target);
          makeSlotDraggable(src);
        }
      }catch(_){}
    }catch(_){}
  }

  function bindTextSwap(){
    for (var i=17; i<=25; i++){
      var id = 'feld'+i;
      var el = document.getElementById(id);
      if (!el || el.__rbTextSwapBound) continue;
      el.addEventListener('dragover', onTextSlotDragOver, true);
      el.addEventListener('drop', onTextSlotDrop, true);
      el.__rbTextSwapBound = true;
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bindTextSwap, {once:true});
  }else{
    bindTextSwap();
  }
  setTimeout(bindTextSwap, 0);

  // Zusätzlich: Dokumentweites Capture, damit wir VOR bestehenden Capture-Handlern drankommen
  function docCaptureSwap(ev){
    try{
      var payload = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
      if (!SLOT_RE.test(payload)) return; // kein Slot→Slot
      var t = ev.target;
      if (!t || !t.closest) return;
      var sel = '#feld17,#feld18,#feld19,#feld20,#feld21,#feld22,#feld23,#feld24,#feld25';
      var target = t.closest(sel);
      if (!target) return;
      // Ziel ist Text-Slot → selben Ablauf wie onTextSlotDrop
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation();
      try{ if (ev.dataTransfer && ev.dataTransfer.clearData){ ev.dataTransfer.clearData(); ev.dataTransfer.setData('text/plain',''); } }catch(_){}
      if (payload === target.id) return;
      var src = document.getElementById(payload);
      if (!src) return;
      var srcHTML = src.innerHTML;
      var tgtHTML = target.innerHTML;
      var targetEmpty = !tgtHTML || !tgtHTML.trim();
      if (targetEmpty){
        target.innerHTML = srcHTML;
        copyDatasetText(src, target);
        src.innerHTML = '';
        if (src.dataset){
          delete src.dataset.rbType;
          delete src.dataset.rbLabel;
          delete src.dataset.rbOrigin;
        }
      }else{
        target.innerHTML = srcHTML;
        src.innerHTML = tgtHTML;
        swapDatasetText(src, target);
      }
      try{
        if (typeof makeSlotDraggable === 'function'){
          makeSlotDraggable(target);
          makeSlotDraggable(src);
        }
      }catch(_){}
    }catch(_){}
  }
  document.addEventListener('drop', docCaptureSwap, true);

})();
</script>
<style data-group="other" id="rb-drop-preview">
/* rein visuelle Vorschau, kein Layout-Shift */
.rb-drop-ok { box-shadow: 0 0 0 3px rgba(0,0,0,0.35) inset; border-radius: 4px; }
.rb-trash-ok { box-shadow: 0 0 0 3px rgba(0,0,0,0.25) inset; border-radius: 6px; }
</style>
<script>
// --- Universelle Drop-Vorschau: Sticker (2–5,8–16), Text (17–25), Mülleimer ---
// Nur Optik: Fügt/entfernt Klassen, keine Logikänderungen.

(function(){
  'use strict';

  var STICKER_SLOT_RE = /^feld(2|3|4|5|8|9|10|11|12|13|14|15|16)$/;
  var TEXT_SLOT_RE    = /^feld(1[7-9]|2[0-5])$/;
  var ALL_SLOTS_SEL   = ['#feld2','#feld3','#feld4','#feld5','#feld8','#feld9','#feld10','#feld11','#feld12','#feld13','#feld14','#feld15','#feld16',
                         '#feld17','#feld18','#feld19','#feld20','#feld21','#feld22','#feld23','#feld24','#feld25'].join(',');

  function getTrash(){
    return document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
  }

  function parsePayload(ev){
    var raw = '';
    try{ raw = ev.dataTransfer && ev.dataTransfer.getData('text/plain') || ''; }catch(_){}
    var p = {raw: raw, kind:'unknown'};
    if (!raw) return p;
    // Slot-IDs
    if (STICKER_SLOT_RE.test(raw)) { p.kind='slot-sticker'; return p; }
    if (TEXT_SLOT_RE.test(raw))    { p.kind='slot-text';    return p; }
    // Sticker aus Boxen: JSON mit type=sticker oder URL mit / oder .svg/.png
    try{ var obj = JSON.parse(raw); if (obj && obj.type==='sticker' && obj.url){ p.kind='sticker'; return p; } }catch(_){}
    if (/sticker\//i.test(raw) || /\.(svg|png|jpg|jpeg)$/i.test(raw)){ p.kind='sticker'; return p; }
    // ansonsten normaler Text
    p.kind='text';
    return p;
  }

  function isValidTarget(kind, el){
    if (!el) return false;
    var id = el.id || '';
    if (!id) return false;
    if (kind==='sticker' || kind==='slot-sticker'){
      return STICKER_SLOT_RE.test(id);
    }
    if (kind==='text' || kind==='slot-text'){
      return TEXT_SLOT_RE.test(id);
    }
    return false;
  }

  function addClass(el, cls){ try{ if (el) el.classList.add(cls); }catch(_){ } }
  function removeClass(el, cls){ try{ if (el) el.classList.remove(cls); }catch(_){ } }

  function clearAllPreviews(){
    try{ document.querySelectorAll(ALL_SLOTS_SEL).forEach(function(n){ n.classList.remove('rb-drop-ok'); }); }catch(_){}
    try{ var tr = getTrash(); if (tr) tr.classList.remove('rb-trash-ok'); }catch(_){}
  }

  // Highlight auf gültigen Slots
  function onDragEnterOver(ev){
    try{
      var p = parsePayload(ev);
      var t = ev.target && ev.target.closest ? ev.target.closest(ALL_SLOTS_SEL) : null;
      if (isValidTarget(p.kind, t)){
        addClass(t, 'rb-drop-ok');
        try{ ev.preventDefault(); ev.dataTransfer.dropEffect = 'move'; }catch(_){}
      }
      // Trash highlight nur, wenn ein Slot gezogen wird (löschen möglich)
      var tr = getTrash();
      if (tr){
        if (p.kind==='slot-sticker' || p.kind==='slot-text'){
          addClass(tr, 'rb-trash-ok');
        }else{
          removeClass(tr, 'rb-trash-ok');
        }
      }
    }catch(_){}
  }

  function onDragLeave(ev){
    try{
      var t = ev.target && ev.target.closest ? ev.target.closest(ALL_SLOTS_SEL) : null;
      if (t) removeClass(t, 'rb-drop-ok');
    }catch(_){}
  }

  function onDropEnd(ev){
    clearAllPreviews();
  }

  document.addEventListener('dragenter', onDragEnterOver, true);
  document.addEventListener('dragover',  onDragEnterOver, true);
  document.addEventListener('dragleave', onDragLeave, true);
  document.addEventListener('drop',      onDropEnd, true);
  document.addEventListener('dragend',   onDropEnd, true);
})();
</script>
<style data-group="other" id="feld7-dd-polish">
/* Feld 7 Dropdown – CSS-only Feinschliff (keine Logikänderung) */
#feld7-dd { max-width: 280px; }
#feld7-menu{
  right: 0; left: auto;           /* bündig am Trigger ausrichten */
  min-width: 100%; max-width: 320px;
  border-radius: 10px;
  box-shadow: 0 8px 20px rgba(0,0,0,.12);
  background: #FFF7CC;            /* harmoniert mit deinen Gelbtönen */
}

.feld7-item{
  display: flex; align-items: center; gap: 12px;
  padding: 8px 14px;
  min-height: 44px;               /* kompakter, aber gut klickbar */
  font-size: 15px; line-height: 1.3;
  font-weight: 500;               /* nicht fett, aber lesbar */
  cursor: pointer;
}
.feld7-item img{ width: 24px; height: 24px; display:block; }

/* Hover/Active dezent – kein Layout-Shift */
.feld7-item:hover{ background: rgba(0,0,0,.06); }
.feld7-item[aria-selected="true"]{ background:#FFEAA3; }

/* Scrollhöhe begrenzen; Dropdown verdeckt weniger */
#feld7-menu{ max-height: 260px; overflow:auto; }

/* Tastaturfokus sichtbar ohne Springen */
.feld7-item:focus{ outline: 2px solid rgba(0,0,0,.35); outline-offset: -2px; }
</style>
<style data-group="other" id="feld7-dd-polish-v2">
/* Feld 7: Breite auf Inhaltsmaß reduzieren (fit), ohne Layout-Shift */
#feld7-dd{ width: auto !important; max-width: none !important; display:inline-block !important; }
#feld7-trigger{ width: auto !important; }
#feld7-menu{
  left: auto !important; right: 0 !important;
  min-width: 0 !important;             /* nicht mehr an Triggerbreite binden */
  width: max-content !important;        /* an Inhalt anpassen */
  max-width: 240px !important;          /* Sicherheitsgrenze */
  white-space: nowrap !important;       /* keine Zeilenumbrüche in Einträgen */
}
/* Falls die Toolbar die Spalte stretcht: verhinde rtes Weiten */
#feld7-dd, #feld7-trigger{ flex: 0 0 auto !important; }
</style>
<style data-group="other" id="feld7-dd-polish_v4_align">
/* Feld 7: Icon + Text sauber in einer Linie, volle Zeilenbreite */
#feld7-menu{ padding: 6px 6px !important; } /* etwas Innenraum um die Liste */
#feld7-menu .feld7-item{
  display: flex !important;
  align-items: center !important;
  gap: 12px !important;
  padding: 8px 10px !important;
  min-height: 44px !important;
  width: 100% !important;            /* Hintergrund über volle Breite */
  box-sizing: border-box !important;
}
#feld7-menu .feld7-item > img{
  width: 24px !important;
  height: 24px !important;
  flex: 0 0 24px !important;
  display: block !important;
  margin: 0 !important;
  background: transparent !important;
}
#feld7-menu .feld7-item > span{
  flex: 1 1 auto !important;
  min-width: 0 !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
/* Hover/Active auf der ganzen Zeile */
#feld7-menu .feld7-item:hover{ background: rgba(0,0,0,.06) ; }
#feld7-menu .feld7-item[aria-selected="true"]{ background: #FFEAA3 !important; }
/* Kinder klicken nicht einzeln: Events auf <li> */
#feld7-menu .feld7-item > *{ pointer-events: none !important; }
</style>
<style data-group="other" id="hint-unify-step1">
/* Schritt 1 – Hinweise vereinheitlichen (Optik + Layering, keine Logikänderung) */

/* Gemeinsamer Look: warme Gelbfläche, ruhige Typo, dezenter Schatten */
.slot-hint,
.nohit-toast{
  background: transparent !important; /* neutralized */
  border: 1px solid #E6C768 !important;
  color: #3b2e04 !important;
  border-radius: 10px !important;
  padding: 8px 10px !important;
  line-height: 1.3 !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.10) !important;
  font-size: 14px !important;
}

/* Close-Button konsistent und immer innen rechts oben */
.slot-hint .slot-hint-close{
  position: absolute !important;
  top: 2px !important;
  right: 6px !important;
  font-weight: 700 !important;
  cursor: pointer !important;
  opacity: .85 !important;
}

/* Layering: über roten Boxen, unter der Steuerleiste */
.slot-hint,
.nohit-toast{
  position: absolute; /* respektiert vorhandene Positionsanker */
  z-index: 15 !important; /* .steuerleiste-Kinder haben z-index:1; wir liegen drüber den Boxen, unter Tooltips */
}

/* Sicherheitsnetz: keine Layout-Verschiebung durch Rahmen/Outline */
.slot-hint, .nohit-toast{ box-sizing: border-box !important; }
</style>
<style data-group="card" id="hint-unify-step1-redframe">
/* Override: Einheitlicher roter Rahmen für alle Hinweise (Sticker-Hinweis & Kein-Treffer-Toast) */
#karte-rueckseite .slot-hint,
.slot-hint,
.nohit-toast{
  border: 0.5mm solid #C62828 !important; /* kräftiges Rot, wie besprochen */
}
</style>
<style data-group="base" id="hint-unify-step1-final">
/* FINAL Override: Einheitliche Hinweise (Sticker & Kein-Treffer) */
/* Vorgabe: Hintergrund WEISS, Rahmen WEINROT, einheitliche Schrift & Größe */
:root { --hint-burgundy: #800020; }

.slot-hint,
.nohit-toast{
  background: #FFFFFF !important;
  border: 0.5mm solid var(--hint-burgundy) !important;
  color: #1f1f1f !important;
  font-size: 14px !important;
  font-family: inherit !important;   /* überall gleiche Schriftfamilie der UI */
  line-height: 1.35 !important;
  border-radius: 8px !important;
  padding: 8px 10px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.08) !important;
  box-sizing: border-box !important;
}

/* Close-Icon im selben Farbraum (weinrot) */
.slot-hint .slot-hint-close{
  color: var(--hint-burgundy) !important;
  font-weight: 700 !important;
  opacity: .95 !important;
}

/* Layering konsistent: über Boxen, unter Toolbar (die i.d.R. z-index:1 hat) */
.slot-hint,
.nohit-toast{
  position: absolute;
  z-index: 15 !important;
}
</style>
<style data-group="card" id="hint-unify-step5-backside-fix">
/* Final-Override (hoch-spezifisch): Sticker-Hinweis auf Kartenrückseite angleichen */
#karte-rueckseite .slot-hint{
  background: #FFFFFF !important;
  border: 0.5mm solid var(--hint-burgundy, #800020) !important;
  color: #1f1f1f !important;
  font-size: 14px !important;
  font-family: inherit !important;
  line-height: 1.35 !important;
  border-radius: 8px !important;
  padding: 8px 10px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.08) !important;
  box-sizing: border-box !important;
  z-index: 15 !important; /* über Boxen, unter Toolbar */
}
</style>
<style data-group="base" id="hint-unify-step6-sp-hint">
/* Einheitlich wie alle Hinweise: Freitext-Hinweis (Feld 6) */
#spruchPopup .sp-hint,
#spruch-popup-hint{
  background: #FFFFFF !important;
  border: 0.5mm solid #800020 !important;  /* weinrot */
  color: #1f1f1f !important;
  font-size: 14px !important;
  font-family: inherit !important;
  line-height: 1.35 !important;
  border-radius: 8px !important;
  padding: 8px 10px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.08) !important;
  box-sizing: border-box !important;
}
/* Falls die Überschrift 'Freitext' im Panel ein anderes Padding drückt: neutral bleiben */
#spruchPopup .sp-head + .sp-body .sp-hint{ margin-top: 8px !important; }
</style>
<style data-group="base" id="hint-unify-step7-backside-equalize">
/* Rückseiten-Sticker-Hinweis exakt an andere Hinweise angleichen */
:root { --hint-burgundy: #800020; }

#karte-rueckseite .slot-hint{
  background: #FFFFFF !important;
  border: 0.5mm solid var(--hint-burgundy) !important;
  color: #1f1f1f !important;
  font-size: 14px !important;
  font-family: inherit !important;
  line-height: 1.35 !important;
  border-radius: 8px !important;
  padding: 8px 10px !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.08) !important;
  box-sizing: border-box !important;
  z-index: 15 !important;
}

/* Titelzeile NICHT extra „Header“-artig – wie normaler Text, nur minimal betont */
#karte-rueckseite .slot-hint .slot-hint-title{
  font-weight: 500 !important;    /* kein Bold */
  font-size: 14px !important;
  line-height: 1.35 !important;
  margin: 0 0 4px 0 !important;   /* kleiner Abstand, kein Balkenlook */
  color: inherit !important;
}

/* Close-Icon in Weinrot, passend zum Rahmen */
#karte-rueckseite .slot-hint .slot-hint-close{
  color: var(--hint-burgundy) !important;
  opacity: .95 !important;
}

/* Saubere Absatzabstände im Text */
#karte-rueckseite .slot-hint p{ margin: 0 0 6px 0 !important; }
#karte-rueckseite .slot-hint p:last-child{ margin-bottom: 0 !important; }
</style>
<style data-group="base" id="hint-unify-step8-thicker-borders">
/* Rahmenstärke angleichen: Rückseiten-Stickerhinweis & Feld-6-Freitext-Hinweis */
:root { --hint-burgundy: #800020; }

#karte-rueckseite .slot-hint,
#spruchPopup .sp-hint,
#spruch-popup-hint{
  border-width: 0.7mm !important;    /* etwas kräftiger, wie die übrigen Hinweise */
  border-style: solid !important;
  border-color: var(--hint-burgundy) !important;
}
</style>
<style data-group="other" id="dropdown-unify-step3">
/* Schritt 3 – Dropdowns konsolidieren (Optik-only, konservativ) */

/* Autocomplete (Pflanzensuche) */
.ac-anchor{ position: relative; display: inline-block; }
.ac-list{
  /* Behalten: Positionierung & min Breite */
  left: 0; top: calc(100% + 4px);
  max-height: 260px; overflow-y: auto;
  /* Vereinheitlichung: Ecken/Schatten/Border */
  background: #fff; border: 1px solid #bbb; border-radius: 10px;
  box-shadow: 0 8px 20px rgba(0,0,0,.12);
}
.ac-item, .ac-empty{
  padding: 8px 12px; min-height: 40px; display: flex; align-items: center;
  font-size: 15px; line-height: 1.3;
}
.ac-item:hover, .ac-item.active{ background: #f2f4f6; }

/* Feld 7 (bleibt Triggerbreite; Breitenlogik aus v3/v4 behalten) */
#feld7-menu{
  border-radius: 10px; box-shadow: 0 8px 20px rgba(0,0,0,.12);
}
#feld7-menu .feld7-item{
  padding: 8px 12px; min-height: 44px;
  font-size: 15px; line-height: 1.3;
}
#feld7-menu .feld7-item:hover{ background: rgba(0,0,0,.06); }
#feld7-menu .feld7-item[aria-selected="true"]{ background: #FFEAA3; }
</style>
<style data-group="base" id="zindex-vars-and-bindings">
/* Z-Index-Schema (Dokumentation, ohne Verhaltensänderung)
   - --z-hint:     Hinweise über Boxen, unter Toolbar (bisher 15)
   - --z-dropdown: Autocomplete/Dropdown-Overlays (bisher 2000)
   Werte sind so gesetzt, dass sie exakt dem aktuellen Verhalten entsprechen.
*/
:root{
  --z-hint: 15;
  --z-dropdown: 2000;
}

/* Rebinding mit identischen Werten (kein visuelles/funktionales Delta) */
.slot-hint,
.nohit-toast{ z-index: var(--z-hint, 15) !important; }

.ac-list{ z-index: var(--z-dropdown, 2000) !important; }
</style>
<style data-group="base" id="zindex-fix-spruch-feld7">
/* Layer-Fix: Freitext-Popup immer über Dropdowns (Feld 6/7 & Autocomplete) */
:root{ --z-panel: 3001; } /* größer als --z-dropdown (2000) */
.spruch-popup, #spruchPopup{
  position: absolute;
  z-index: var(--z-panel, 3001) !important;
}
/* Sicherheitsnetz: Dropdowns bleiben darunter */
#feld7-menu{ z-index: var(--z-dropdown, 2000) !important; }
.ac-list{ z-index: var(--z-dropdown, 2000) !important; }
</style>
<style data-group="dropdown" id="rb-dd-free-width-151-5">/* Einzelschritt: Dragtext-Eingabefeld in gelber Box exakt 151.5px breit */
#rb-dd-free{
  width: 151.5px !important;
  min-width: 151.5px !important;
  max-width: 151.5px !important;
  display: block;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}</style>
<script id="rb-dd-free-151px-guard">
/* Feld 6 – Freitext (Dropdown): sichtbare Textbreite auf 151px begrenzen */
(function(){
  'use strict';
  var MAX = 151; // px
  var el = document.getElementById('rb-dd-free');
  if(!el) return;

  // Mess-Span mit gleichen Font-Eigenschaften
  var meas = document.createElement('span');
  meas.style.position = 'fixed';
  meas.style.top = '-9999px';
  meas.style.left = '-9999px';
  meas.style.whiteSpace = 'pre';
  document.body.appendChild(meas);

  function syncFont(){
    var cs = getComputedStyle(el);
    ['font','fontSize','fontFamily','fontWeight','fontStyle','letterSpacing','textTransform','fontVariant'].forEach(function(p){
      try{ meas.style[p] = cs[p]; }catch(_){}
    });
  }
  function widthOf(text){
    meas.textContent = (text || '').replace(/ /g, '\u00A0');
    return meas.getBoundingClientRect().width;
  }
  function clampToMax(text){
    if(widthOf(text) <= MAX) return text;
    var lo=0, hi=text.length, ok=0;
    while(lo<=hi){
      var mid=(lo+hi)>>1;
      var s=text.slice(0, mid);
      if(widthOf(s) <= MAX){ ok=mid; lo=mid+1; } else { hi=mid-1; }
    }
    return text.slice(0, ok);
  }
  function placeCaretEnd(node){
    try{
      var range=document.createRange();
      range.selectNodeContents(node);
      range.collapse(false);
      var sel=window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }catch(_){}
  }
  function onInput(){
    var t=el.textContent||'';
    if(widthOf(t) <= MAX) return;
    el.textContent = clampToMax(t);
    placeCaretEnd(el);
  }
  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

      syncFont(); onInput();
    }, {once:true});
  }else{
    syncFont(); onInput();
  }
  el.addEventListener('input', onInput);
  window.addEventListener('resize', syncFont);
})();
</script>
<style data-group="card" id="hint-backside-opaque-fix">
/* Rückseiten-Hinweis: immer deckend und gut lesbar */
#karte-rueckseite .slot-hint{
  background: #FFFFFF !important;
  border: 0.7mm solid #800020 !important;  /* Weinrot, wie vereinbart */
  color: #1f1f1f !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.10) !important;
  border-radius: 8px !important;
  padding: 8px 10px !important;
  opacity: 1 !important;
  backdrop-filter: none !important;
}
#karte-rueckseite .slot-hint .slot-hint-title{
  font-weight: 500 !important;
  margin: 0 0 4px 0 !important;
  color: inherit !important;
}
#karte-rueckseite .slot-hint .slot-hint-close{
  color: #800020 !important;
  opacity: .95 !important;
}
</style>
<style data-group="card" id="hint-backside-opaque-before">
/* Rückseite: opake Hint-Fläche per ::before, unabhängig von Kinder-Background-Resets */
#karte-rueckseite .slot-hint{
  position: relative;               /* Anker für ::before */
  z-index: var(--z-hint, 15);       /* bleibt auf Hint-Ebene */
}
#karte-rueckseite .slot-hint::before{
  content: "";
  position: absolute;
  inset: 0;                         /* füllt die ganze Hint-Box */
  background: #FFFFFF;              /* deckend weiß */
  border: 0.7mm solid #800020;      /* Weinroter Rahmen */
  border-radius: 8px;
  box-shadow: 0 6px 18px rgba(0,0,0,.10);
  z-index: -1;                      /* hinter dem Inhalt der Hint-Box */
}
</style>
<style data-group="card" id="hint-backside-opaque-layering">
/* Layer-Korrektur: Hintergrundplatte vor dem Parent-Background, unter dem Inhalt */
#karte-rueckseite .slot-hint{ position: relative; }
#karte-rueckseite .slot-hint::before{
  z-index: 0;                /* vor dem Elementhintergrund, sichtbar */
}
#karte-rueckseite .slot-hint > *{
  position: relative;
  z-index: 1;                /* Inhalt über der weißen Platte */
}
</style>
<style data-group="card" id="hint-backside-single-border">
/* Rückseite: Doppelrahmen vermeiden – nur ::before zeichnet den Rahmen/Hintergrund */
#karte-rueckseite .slot-hint{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important; /* Schatten liegt auf ::before */
}
/* ::before behält Weiß+Weinrot (bereits gesetzt) */
</style>
<style data-group="card" id="hint-backside-single-border-undo">
/* Schritt: Transparenz-Fix – Rückseiten-Hinweis wieder deckend,
   überschreibt 'hint-backside-single-border' am Dokumentende. */
#karte-rueckseite .slot-hint{
  background: #FFFFFF !important;
  border: 0.7mm solid #800020 !important;
  box-shadow: 0 6px 18px rgba(0,0,0,.10) !important;
  opacity: 1 !important;
  filter: none !important;
  mix-blend-mode: normal !important;
  backdrop-filter: none !important;
}
#karte-rueckseite .slot-hint::before{ display: none !important; }
</style>
<script id="hint-layer-script-step2">/* === Einzelschritt 2: .slot-hint konsequent in den Hint-Layer verschieben === */
(function(){
  function ensureHintLayer(){
    var fig = document.querySelector('#karte-rueckseite');
    if(!fig) return null;
    var layer = fig.querySelector('#hint-layer');
    if(!layer){
      layer = document.createElement('div');
      layer.id = 'hint-layer';
      layer.style.position = 'absolute';
      layer.style.inset = '0';
      layer.style.zIndex = '12000';
      layer.style.pointerEvents = 'none';
      layer.style.isolation = 'isolate';
      fig.appendChild(layer);
    }
    return layer;
  }

  function moveHintsIntoLayer(root){
    var layer = ensureHintLayer();
    if(!layer) return;
    var list = (root || document).querySelectorAll('#karte-rueckseite .slot-hint');
    list.forEach(function(el){
      if(el.parentElement !== layer){
        layer.appendChild(el);
      }
    });
  }

  // Initial move after DOM is ready
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }
 moveHintsIntoLayer(document); });
  } else {
    moveHintsIntoLayer(document);
  }

  // Observe future DOM mutations under #karte-rueckseite
  var fig = document.querySelector('#karte-rueckseite');
  if(fig && 'MutationObserver' in window){
    var obs = new MutationObserver(function(muts){
      var layer = ensureHintLayer();
      muts.forEach(function(m){
        // Änderungen im hint-layer selbst ignorieren, um Endlosschleifen zu vermeiden
        if (m.target === layer) return;
        if (!m.addedNodes) return;
        m.addedNodes.forEach(function(n){
          if(n.nodeType !== 1) return;
          if(n.classList.contains('slot-hint')){
            if(n.parentElement !== layer){ layer.appendChild(n); }
          } else {
            var inner = n.querySelectorAll ? n.querySelectorAll('.slot-hint') : [];
            inner.forEach(function(el){ if(el.parentElement !== layer){ layer.appendChild(el); } });
          }
        });
      });
    });
    obs.observe(fig, { childList: true, subtree: true });
  }
})();</script><style data-group="card" id="hint-close-bigger-step3">
/* Einzelschritt 3: Close-Button im Hinweis vergrößern + leichter klickbar machen */
#karte-rueckseite #hint-layer .slot-hint{
  padding-right: calc(22px * var(--zoom)) !important; /* Platz für größeres X */
}
#karte-rueckseite #hint-layer .slot-hint .slot-hint-close{
  position: absolute !important;
  top: calc(2px * var(--zoom)) !important;
  right: calc(4px * var(--zoom)) !important;
  font-size: calc(18px * var(--zoom)) !important;  /* X sichtbar größer */
  line-height: 1 !important;
  width: auto !important;
  height: auto !important;
  padding: calc(6px * var(--zoom)) !important;     /* größere Klickfläche */
  margin: 0 !important;
  cursor: pointer !important;
  user-select: none !important;
  -webkit-tap-highlight-color: transparent;
}
#karte-rueckseite #hint-layer .slot-hint .slot-hint-close:hover{
  opacity: 1 !important;
  transform: scale(1.06);
}
</style><style data-group="base" id="rb-dd-bars-fullwidth">
/* Einzelschritt: Die zwei Felder ober/unter der Eingabe auf Rahmenbreite ziehen */
#rb-dropdown #rb-dd-body #rb-dd-free-handle,
#rb-dropdown #rb-dd-foot #rb-dd-free-handle,
#rb-dropdown #rb-dd-body .rb-dd-item,
#rb-dropdown #rb-dd-foot .rb-dd-item{
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
}
</style><style data-group="dropdown" id="rb-free-fitframe-and-handle-width">
/* Einzelschritt: 
   - Eingabefeld #rb-dd-free bündig in den Rahmen
   - Drop-Pille #rb-dd-free-handle exakt 151.5px
*/
#rb-dropdown #rb-dd-free{
  margin-left: 6px !important;
  margin-right: 6px !important;
  width: calc(100% - 12px) !important;   /* Rahmen-Innenabstand links/rechts 6px */
  max-width: calc(100% - 12px) !important;
  box-sizing: border-box !important;
}

#rb-dropdown #rb-dd-foot #rb-dd-free-handle{
  width: 151.5px !important;
  max-width: 151.5px !important;
  min-width: 151.5px !important;
  margin-left: 6px !important;
  margin-right: 6px !important;
  box-sizing: border-box !important;
}
</style><style data-group="base" id="rb-dd-flush-fix">
/* Einzelschritt: Freitext & Drop-Pille bündig in den Rahmen setzen */
#rb-dropdown #rb-dd-body{ 
  padding-left: 0 !important; 
  padding-right: 0 !important; 
}
#rb-dropdown #rb-dd-free{
  margin-left: 0 !important;
  margin-right: 0 !important;
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
  overflow: hidden !important; /* keine Überstände durch Rundung */
}
#rb-dropdown #rb-dd-foot #rb-dd-free-handle{
  margin-left: 0 !important;
  margin-right: auto !important;   /* links bündig, ragt nicht rechts raus */
  width: 151.5px !important;
  max-width: 151.5px !important;
  min-width: 151.5px !important;
  box-sizing: border-box !important;
}
</style><style data-group="dropdown" id="rb-dd-left-shift-2-5mm">
/* Einzelschritt: Beide Elemente 2.5mm nach links schieben */
#rb-dropdown #rb-dd-free{
  margin-left: -2.5mm !important;
  width: 100% !important;
  max-width: 100% !important;
}
#rb-dropdown #rb-dd-foot #rb-dd-free-handle{
  margin-left: -2.5mm !important;
  width: 151.5px !important;
  max-width: 151.5px !important;
  min-width: 151.5px !important;
}
</style><script defer="True" id="nohit-toast-fit">
(function(){
  try{
    var input = document.getElementById('pflanzensuche');
    var toast = document.getElementById('nohit-toast');
    if(!input || !toast) return;
    function fit(){
      var w = window.getComputedStyle(input).width;
      if(w) toast.style.width = w;
    }
    // initial + responsive
    window.addEventListener('resize', fit, {passive:true});
    if (window.ResizeObserver) {
      var ro = new ResizeObserver(fit);
      ro.observe(input);
    }
    fit();
  }catch(e){/* silent */}
})();</script><script defer="True" id="rb-plant-hint-fit">
(function(){
  try{
    var input = document.getElementById('pflanzensuche');
    var hint  = document.getElementById('rb-plant-hint');
    if(!input) return;
    function fit(){
      if (!hint) hint = document.getElementById('rb-plant-hint');
      if (!hint) return;
      var w = window.getComputedStyle(input).width;
      if (w) hint.style.width = w;
    }
    window.addEventListener('resize', fit, {passive:true});
    if (window.ResizeObserver) new ResizeObserver(fit).observe(input);
    // Falls der Hint erst später ins DOM kommt, wiederholt prüfen
    var tries = 0;
    var timer = setInterval(function(){
      hint = document.getElementById('rb-plant-hint');
      if (hint || ++tries > 20){ clearInterval(timer); fit(); }
    }, 150);
    fit();
  }catch(e){/* silent */}
})();</script><script defer="True" id="autoscroll-spalte1">
// E8: Auto-Scroll für Spalte 1 (#spalte-links) beim Ziehen von Stickern
(function(){
  var container = document.getElementById('spalte-links');
  if(!container) return;
  var active = false, lastY = 0, rafId = null;
  var EDGE = 60;       // px Bereich am oberen/unteren Rand
  var MAX = 18;        // px pro Frame scrollen (sanft)
  function step(){
    if(!active){ rafId = null; return; }
    var r = container.getBoundingClientRect();
    var delta = 0;
    if (lastY < r.top + EDGE) {
      var k = (r.top + EDGE - lastY) / EDGE;
      delta = -Math.min(MAX, Math.max(2, k * MAX));
    } else if (lastY > r.bottom - EDGE) {
      var k2 = (lastY - (r.bottom - EDGE)) / EDGE;
      delta =  Math.min(MAX, Math.max(2, k2 * MAX));
    }
    if (delta !== 0) container.scrollTop += delta;
    rafId = window.requestAnimationFrame(step);
  }
  container.addEventListener('dragover', function(e){
    active = true;
    lastY = e.clientY || 0;
    if(!rafId) rafId = window.requestAnimationFrame(step);
  }, {passive:true});
  ['dragleave','drop','dragend'].forEach(function(ev){
    container.addEventListener(ev, function(){ active = false; }, {passive:true});
  });
})();</script><script defer="True" id="autoscroll-window">
// E8a: Fenster-Auto-Scroll beim Ziehen (oben & unten), unabhängig vom Container
(function(){
  var active = false, lastY = 0, rafId = null;
  var EDGE = 80;   // px Randzone am Viewport
  var MAX = 24;    // px pro Frame (sanft)

  function step(){
    if(!active){ rafId = null; return; }
    var h = window.innerHeight || document.documentElement.clientHeight;
    var delta = 0;

    if (lastY < EDGE){
      var kTop = (EDGE - lastY) / EDGE;
      delta = -Math.min(MAX, Math.max(2, kTop * MAX));
    } else if (lastY > h - EDGE){
      var kBot = (lastY - (h - EDGE)) / EDGE;
      delta =  Math.min(MAX, Math.max(2, kBot * MAX));
    }

    if (delta !== 0){
      window.scrollBy(0, delta);
    }
    rafId = window.requestAnimationFrame(step);
  }

  function onOver(e){
    lastY = e.clientY || 0;
    if(!active){
      active = true;
      if(!rafId) rafId = window.requestAnimationFrame(step);
    }
  }
  function stop(){ active = false; }

  // Auf dem ganzen Dokument aktiv
  document.addEventListener('dragover', onOver, {passive:true});
  document.addEventListener('dragend',  stop,   {passive:true});
  document.addEventListener('drop',     stop,   {passive:true});
  document.addEventListener('dragleave',stop,   {passive:true});
})();</script><style id="spalte-scroll-arrows-css">
/* E9: Pfeil-Buttons in Spalte 1 zum Scrollen */
#spalte-links{ position: relative !important; }
#spalte-scroll-up, #spalte-scroll-down{
  position: absolute; right: 6px;
  width: 24px; height: 24px;
  border-radius: 6px;
  background: rgba(0,0,0,0.75);
  color: #fff;
  font: 700 14px/24px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  text-align: center;
  cursor: pointer;
  user-select: none;
  z-index: 5000;
  display: none; /* wird per JS eingeblendet, wenn nötig */
}
#spalte-scroll-up{ top: 6px; }
#spalte-scroll-down{ bottom: 6px; }
#spalte-scroll-up:hover, #spalte-scroll-down:hover{ background: rgba(0,0,0,0.9); }
</style><script defer="True" id="spalte-scroll-arrows-js">
(function(){
  var col = document.getElementById('spalte-links');
  if(!col) return;

  // Create buttons
  function btn(id, txt){ var b = document.createElement('div'); b.id = id; b.textContent = txt; return b; }
  var up = document.getElementById('spalte-scroll-up') || btn('spalte-scroll-up','▲');
  var dn = document.getElementById('spalte-scroll-down') || btn('spalte-scroll-down','▼');
  if(!up.parentNode) col.appendChild(up);
  if(!dn.parentNode) col.appendChild(dn);

  function needed(){
    // Show buttons only if there is actually overflow
    var need = (col.scrollHeight - col.clientHeight) > 2;
    up.style.display = dn.style.display = need ? 'block' : 'none';
  }

  function stepper(deltaPerFrame){
    var id = null, running = false;
    function frame(){
      if(!running){ id = null; return; }
      col.scrollTop += deltaPerFrame;
      id = requestAnimationFrame(frame);
    }
    return {
      start: function(){ if(!running){ running = true; if(!id) id = requestAnimationFrame(frame); } },
      stop:  function(){ running = false; }
    };
  }

  var upRun = stepper(-12);
  var dnRun = stepper( 12);

  function clickScroll(dir){
    col.scrollBy({ top: dir*80, left: 0, behavior: 'smooth' });
  }

  // Events
  up.addEventListener('mousedown', function(e){ e.preventDefault(); upRun.start(); });
  up.addEventListener('mouseup',   function(){ upRun.stop(); });
  up.addEventListener('mouseleave',function(){ upRun.stop(); });
  up.addEventListener('click',     function(e){ e.preventDefault(); clickScroll(-1); });

  dn.addEventListener('mousedown', function(e){ e.preventDefault(); dnRun.start(); });
  dn.addEventListener('mouseup',   function(){ dnRun.stop(); });
  dn.addEventListener('mouseleave',function(){ dnRun.stop(); });
  dn.addEventListener('click',     function(e){ e.preventDefault(); clickScroll(+1); });

  // Touch support
  up.addEventListener('touchstart', function(e){ e.preventDefault(); upRun.start(); }, {passive:false});
  up.addEventListener('touchend',   function(){ upRun.stop(); }, {passive:true});
  dn.addEventListener('touchstart', function(e){ e.preventDefault(); dnRun.start(); }, {passive:false});
  dn.addEventListener('touchend',   function(){ dnRun.stop(); }, {passive:true});

  // Observe size & content changes
  needed();
  window.addEventListener('resize', needed, {passive:true});
  if(window.ResizeObserver){
    var ro = new ResizeObserver(needed);
    ro.observe(col);
  }
})();</script><style id="scroll-dock-css">
/* E9c: kompakter Button, optisch über der Scrolleiste (Overlay) */
#spalte-scroll-up, #spalte-scroll-down{ display: none !important; }
#scroll-dock-down{
  position: fixed;
  width: 22px; height: 22px;
  border-radius: 6px;
  background: rgba(0,0,0,0.65);
  color: #fff;
  font: 700 14px/22px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  text-align: center;
  cursor: pointer;
  user-select: none;
  z-index: 2500;
  box-shadow: 0 1px 2px rgba(0,0,0,.25);
  transition: transform .05s ease-in-out, background .1s;
}
#scroll-dock-down:hover{ background: rgba(0,0,0,0.85); transform: translateY(0); }
#scroll-dock-down:active{ transform: translateY(1px) scale(0.98); }

#scroll-dock-up{
  position: fixed;
  width: 22px; height: 22px;
  border-radius: 6px;
  background: rgba(0,0,0,0.65);
  color: #fff;
  font: 700 14px/22px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  text-align: center;
  cursor: pointer;
  user-select: none;
  z-index: 2500;
  box-shadow: 0 1px 2px rgba(0,0,0,.25);
  transition: transform .05s ease-in-out, background .1s;
  display: none;
}
#scroll-dock-up:hover{ background: rgba(0,0,0,0.85); transform: translateY(0); }
#scroll-dock-up:active{ transform: translateY(1px) scale(0.98); }
</style><script defer="True" id="scroll-dock-js">
(function(){
  var col = document.getElementById('spalte-links');
  if(!col) return;

  function create(id, txt){
    var el = document.getElementById(id);
    if(!el){
      el = document.createElement('div');
      el.id = id;
      el.textContent = txt;
      document.body.appendChild(el);
    }
    return el;
  }

  var down = create('scroll-dock-down','▼');
  var up   = create('scroll-dock-up','▲');

  // Continuous runners
  function runner(delta){
    var running = false, rafId = null;
    function frame(){
      if(!running){ rafId = null; return; }
      col.scrollTop += delta;
      rafId = requestAnimationFrame(frame);
    }
    return {
      start(){ if(!running){ running = true; if(!rafId) rafId = requestAnimationFrame(frame);} },
      stop(){ running = false; }
    };
  }
  var runUp = runner(-14);
  var runDn = runner( 14);

  function clickScroll(dir){ col.scrollBy({ top: dir*120, left: 0, behavior: 'smooth' }); }

  // Bind interactions
  [['mousedown','mouseup','mouseleave','touchstart','touchend','click']].forEach(()=>{}); // no-op to keep lints calm
  up.addEventListener('mousedown',  function(e){ e.preventDefault(); runUp.start(); });
  up.addEventListener('mouseup',    function(){ runUp.stop(); });
  up.addEventListener('mouseleave', function(){ runUp.stop(); });
  up.addEventListener('click',      function(e){ e.preventDefault(); clickScroll(-1); });
  up.addEventListener('touchstart', function(e){ e.preventDefault(); runUp.start(); }, {passive:false});
  up.addEventListener('touchend',   function(){ runUp.stop(); }, {passive:true});

  down.addEventListener('mousedown',  function(e){ e.preventDefault(); runDn.start(); });
  down.addEventListener('mouseup',    function(){ runDn.stop(); });
  down.addEventListener('mouseleave', function(){ runDn.stop(); });
  down.addEventListener('click',      function(e){ e.preventDefault(); clickScroll(+1); });
  down.addEventListener('touchstart', function(e){ e.preventDefault(); runDn.start(); }, {passive:false});
  down.addEventListener('touchend',   function(){ runDn.stop(); }, {passive:true});

  // Position & sizing
  function place(){
    var XADJ = 6; // px Feinausrichtung nach rechts
    var r = col.getBoundingClientRect();
    // Compute scrollbar width (fallback to 12 if overlay scrollbars report 0)
    var sbw = (col.offsetWidth - col.clientWidth);
    if(!sbw || sbw < 8) sbw = 12;

    // Size buttons to scrollbar width
    var w = sbw + 'px';
    down.style.width = w; up.style.width = w;

    // Align over the scrollbar track inside the column
    var left = r.right - sbw;  // inside the column
    var downTop = Math.round(window.innerHeight * 0.55);
    var gap = 6; // distance between buttons
    var upTop = downTop - (down.offsetHeight || 22) - gap;

    down.style.left = (left + XADJ) + 'px';
    down.style.top  = downTop + 'px';
    up.style.left   = (left + XADJ) + 'px';
    up.style.top    = upTop + 'px';

    // Show only when column is on screen and overflow exists
    var onScreen = r.bottom > 0 && r.top < (window.innerHeight||0);
    var need = (col.scrollHeight - col.clientHeight) > 2;
    var vis = (onScreen && need) ? 'block' : 'none';
    down.style.display = vis;
    up.style.display   = vis;
  }

  place();
  window.addEventListener('resize', place, {passive:true});
  window.addEventListener('scroll', place, {passive:true});
  if(window.ResizeObserver){ new ResizeObserver(place).observe(col); }
})();</script><style id="rb-dd-fix-freetext-F2">
/* F2: exakte Ausrichtung Freitext + Drop-Pille in den gelben Boxen */
#rb-dropdown #rb-dd-body{ padding-left:0 !important; padding-right:0 !important; }

#rb-dropdown #rb-dd-free{
  margin-left: -2.5mm !important;
  margin-right: 0 !important;
  width: 100% !important;
  max-width: 100% !important;
  box-sizing: border-box !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: clip !important;
}

#rb-dropdown #rb-dd-foot #rb-dd-free-handle{
  margin-left: -2.5mm !important;
  width: 151.5px !important;
  min-width: 151.5px !important;
  max-width: 151.5px !important;
  box-sizing: border-box !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

#rb-dropdown .rb-dd-item{
  width: 100% !important;
  max-width: 100% !important;
  margin-left: 0 !important;
  margin-right: 0 !important;
  box-sizing: border-box !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
</style><style id="f3-dropdown-zindex">
/* F3: Dropdown stets über Hilfs-Overlays */
#rb-dropdown{ z-index: 9999 !important; }
</style><script defer="True" id="f3-dropdown-pointer-guard">
(function(){
  var dd   = document.getElementById('rb-dropdown');
  var up   = document.getElementById('scroll-dock-up');
  var down = document.getElementById('scroll-dock-down');
  if(!dd || (!up && !down)) return;

  function visible(el){
    if(!el) return false;
    // consider visible when it takes space and is not hidden
    var s = window.getComputedStyle(el);
    if(s.display === 'none' || s.visibility === 'hidden' || s.opacity === '0') return false;
    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
  }

  function apply(){
    var on = visible(dd);
    if(up)   up.style.pointerEvents   = on ? 'none' : 'auto';
    if(down) down.style.pointerEvents = on ? 'none' : 'auto';
  }

  // Initial + react to changes
  apply();
  var obsCfg = { attributes:true, attributeFilter:['style','class'], subtree:false };
  if(window.MutationObserver){
    new MutationObserver(apply).observe(dd, obsCfg);
  }
  window.addEventListener('resize', apply, {passive:true});
})();</script><script defer="True" id="strings-loader-T1-fix">
// T1-fix: Hinweise aus CSV laden und robust überschreiben.
// Datei: ./csv_tabellen/strings.csv
// Format: key;value  (Semikolon)  ODER  key,value (Komma).
(function(){
  function parseCSV(text){
    var lines = text.split(/\r?\n/).filter(Boolean);
    var map = {};
    for (var i=0;i<lines.length;i++){
      var line = lines[i];
      var parts = line.split(";");
      if (parts.length < 2) parts = line.split(",");
      if (parts.length >= 2){
        var k = (parts[0]||"").trim();
        var v = (parts.slice(1).join(parts.length>2?";":",")||"").trim();
        if (k) map[k] = v;
      }
    }
    return map;
  }

  function setNoHit(txt){
    var el = document.getElementById('nohit-toast');
    if (!el || !txt) return;
    el.textContent = txt;
  }

  function setPlantNameLong(txt){
    if (!txt) return;
    function findEl(){
      return document.getElementById('rb-plant-hint') || document.getElementById('name-long-toast');
    }
    function apply(el){
      if (!el) return false;
      el.textContent = txt;
      return true;
    }
    var el = findEl();
    if (apply(el)) {
      if (window.MutationObserver && el){
        var mo2 = new MutationObserver(function(){ apply(el); });
        mo2.observe(el, {childList:true, characterData:true, subtree:true, attributes:false});
      }
      return;
    }
    if (window.MutationObserver){
      var mo = new MutationObserver(function(){
        var el2 = findEl();
        if (apply(el2)) mo.disconnect();
      });
      mo.observe(document.body, {childList:true, subtree:true});
    }
    var tries = 0, t = setInterval(function(){
      if (apply(findEl()) || ++tries > 40) clearInterval(t);
    }, 150);
  }

  function setNicknameLong(txt){
        txt = String(txt || '').replace(/;;+/g,';').replace(/\s*;+\s*$/, '');
if (!txt) return;
    var PREFIX = 'Hinweis: Name/Kosename ist sehr lang';
    function applyTo(el){
      if (!el) return false;
      el.textContent = txt;
      return true;
    }
    function scanReplace(root){
      var ctx = (root && root.querySelectorAll) ? root : document;
      var nodes = ctx.querySelectorAll('*');
      for (var i=0;i<nodes.length;i++){
        var t = (nodes[i].textContent||'').trim();
        if (t.indexOf(PREFIX) === 0){
          return applyTo(nodes[i]);
        }
      }
      return false;
    }
    if (scanReplace(document)) return;
    if (window.MutationObserver){
      var mo = new MutationObserver(function(muts){
        for (var i=0;i<muts.length;i++){
          if (scanReplace(muts[i].target)) { mo.disconnect(); return; }
        }
      });
      mo.observe(document.body, {childList:true, characterData:true, subtree:true, attributes:false});
    }
    var tries = 0, t = setInterval(function(){
      if (scanReplace(document) || ++tries > 40) clearInterval(t);
    }, 150);
  }

  fetch('./csv_tabellen/strings.csv').then(function(r){
    if (!r.ok) throw 0;
    return r.text();
  }).then(function(txt){
    var map = parseCSV(txt);
    
    try{
      if (map && typeof map === 'object'){
        Object.keys(map).forEach(function(k){
          var v = map[k];
          if (typeof v === 'string'){
            v = v.replace(/;;+/g, ';').replace(/\s*;+\s*$/, '');
            map[k] = v;
          }
        });
      }
    }catch(_){}
if (map.nohit_text)     setNoHit(map.nohit_text);
    if (map.plantname_long) setPlantNameLong(map.plantname_long);
    if (map.nickname_long)  setNicknameLong(map.nickname_long);
  }).catch(function(){ /* kein CSV -> Standardtexte bleiben */ });
})();</script><script defer="True" id="csv-dataloader-T8">
// T8-1: CSV DataLoader – nur Daten einlesen & indizieren, keine UI-Änderung.
(function(){
  // Konfigurierbarer Asset-Pfad (nur Basis, Dateinamen kommen aus Master-Tabelle)
  window.RB_ASSETS = window.RB_ASSETS || {
    iconBase: "./",
    watermarkBase: "./"
  };

  var csvPath = (window.csvPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/pflanzendaten.csv");
  var masterPath = (window.masterPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv");

  function detectSep(text){
    // einfache Heuristik
    var first = (text.split(/\r?\n/)[0] || "");
    var sc = (first.match(/;/g)||[]).length;
    var cc = (first.match(/,/g)||[]).length;
    return sc>=cc ? ";" : ",";
  }
  function parseCSV(text){
    var sep = detectSep(text);
    var lines = text.split(/\r?\n/);
    var rows = [];
    for (var i=0;i<lines.length;i++){
      var line = lines[i];
      if (!line || /^\s*$/.test(line)) continue;
      var parts = line.split(sep);
      rows.push(parts.map(function(s){ return s.trim(); }));
    }
    return rows;
  }

  function indexMaster(rows){
    // Erwartung: Kopfzeile = Feature-Namen (z.B. 'sonnig', 'halbschattig', ...)
    // Zeile 1: Dateiname SVG, Zeile 2: Wasserzeichen PNG, Zeile 3: Kategorie,
    // Zeile 4: Pflegehinweis (kurz), Zeile 5: Hinweis für Rückseite, Zeile 6: Hinweistext (lang)
    if (!rows || rows.length < 7) return { features:{}, order:[], categories:[] };
    var header = rows[0]; // Feature-Namen
    var features = {};
    var order = [];
    var catsSet = Object.create(null);

    for (var c=0; c<header.length; c++){
      var name = header[c];
      if (!name) continue;
      // optional: Wenn header c numerisch ist, als id verwenden, sonst name
      var numId = null;
      if (/^\d+$/.test(name)) numId = parseInt(name,10);
      // Mappings aus fixierten Zeilen
      var iconSVG       = (rows[1][c] || "");
      var watermarkPNG  = (rows[2][c] || "");
      var kategorie     = (rows[3][c] || "");
      var pflegeLabel   = (rows[4][c] || "");
      var hintBack      = (rows[5][c] || "");
      var hintLong      = (rows[6][c] || "");
      if (kategorie) catsSet[kategorie] = true;

      var fid = numId!=null ? String(numId) : String(c+1); // stabile ID
      features[fid] = {
        id: fid,
        colIndex: c,
        name: name,
        iconSVG: iconSVG,
        watermarkPNG: watermarkPNG,
        kategorie: kategorie,
        pflegeLabel: pflegeLabel,
        hintBack: hintBack,
        hintLong: hintLong
      };
      order.push(fid);
    }
    return { features: features, order: order, categories: Object.keys(catsSet) };
  }

  function indexPlants(rows, master){
    if (!rows || rows.length < 2) return { plants:[], colMap:{} };
    var header = rows[0];
    // Spalten für Namen erkennen
    function idxOf(label){
      var i = header.findIndex(function(h){ return (h||"").toLowerCase() === label; });
      return i;
    }
    var iAnz   = idxOf("anzeigename");
    var iLat   = idxOf("lateinischer name");
    var iAlt   = idxOf("alternativnamen");

    var plants = [];
    for (var r=1; r<rows.length; r++){
      var row = rows[r];
      if (!row || row.length===0) continue;
      var name = (iAnz>=0 ? row[iAnz] : (row[0]||"")).trim();
      if (!name) continue;
      var lat  = iLat>=0 ? (row[iLat]||"") : "";
      var alt  = iAlt>=0 ? (row[iAlt]||"") : "";
      // aktive Merkmale anhand "nicht-leer"
      var active = [];
      for (var c=0; c<header.length; c++){
        // skip the known non-feature columns
        if (c===iAnz || c===iLat || c===iAlt) continue;
        var val = (row[c]||"").trim();
        if (val){ // nicht-leer = aktiv
          // Feature-ID ermitteln: entweder numerischer Header oder Spaltenindex
          var head = (header[c]||"").trim();
          var fid = /^\d+$/.test(head) ? String(parseInt(head,10)) : String(c+1);
          if (master.features[fid]) active.push(fid);
        }
      }
      plants.push({
        display: name,
        latin: lat,
        alt: alt,
        activeFeatures: active
      });
    }
    return { plants: plants };
  }

  
// Load both CSVs, then build RB_DATA
  Promise.all([
    fetchCsv(csvPath),
    fetchCsv(masterPath)
  ]).then(function(txts){
    var plantRows  = parseCSV(txts[0]);
    var masterRows = parseCSV(txts[1]);
    var master = indexMaster(masterRows);
    var plant  = indexPlants(plantRows, master);

    window.RB_DATA = {
      features: master.features,
      featureOrder: master.order,
      categories: master.categories,
      headers: (plantRows && plantRows[0]) ? plantRows[0] : [],
      rows: plantRows,
      plants: plant.plants,
      master: master
    };
    window.__DEBUG__ && console.info('[RB_DATA]', 'CSV geladen:', {
      pflanzendaten: (plantRows && plantRows.length),
      master: (masterRows && masterRows.length)
    });
  }).catch(function(err){
    window.__DEBUG__ && console.warn('[RB_DATA] CSVs nicht gefunden – UI läuft mit Defaults weiter.', err && err.message || err);
  });
})();</script><script defer="True" id="closepanel-guard-f4b">
// F4b: Safe wrapper for closePanel to avoid null.style errors, without altering original implementation.
(function(){
  function wrapOnce(){
    var orig = window.closePanel;
    if (typeof orig !== 'function') return false;
    if (orig && orig._rbWrapped) return true;
    function safeClose(el){
      try{
        if (typeof el === 'string') el = document.querySelector(el);
        if (!el || !el.style) return;
        return orig.call(this, el);
      }catch(e){ /* swallow */ }
    }
    safeClose._rbWrapped = true;
    window.closePanel = safeClose;
    return true;
  }
  // Try now and for a short while, in case closePanel is defined later
  if (!wrapOnce()){
    var tries = 0, t = setInterval(function(){
      if (wrapOnce() || ++tries > 40) clearInterval(t);
    }, 150);
  }
})();</script><script defer="True" id="rb-hints-t83">
// T8-3: Pflegehinweise aus RB_DATA berechnen (nur Daten, keine Anzeigeänderung).
(function(){
  function byDisplay(name){
    name = (name||"").trim().toLowerCase();
    if (!name || !window.RB_DATA || !Array.isArray(RB_DATA.plants)) return null;
    for (var i=0;i<RB_DATA.plants.length;i++){
      var p = RB_DATA.plants[i];
      if ((p.display||"").trim().toLowerCase() === name) return p;
    }
    return null;
  }
  function computeHints(plant){
    var res = { features:[], front:[], back:[], long:[] };
    if (!plant || !window.RB_DATA) return res;
    var order = RB_DATA.featureOrder || [];
    var map   = RB_DATA.features || {};
    var set = new Set(plant.activeFeatures || []);
    for (var i=0;i<order.length;i++){
      var fid = order[i];
      if (!set.has(fid)) continue;
      var f = map[fid]; if (!f) continue;
      res.features.push(fid);
      if (f.pflegeLabel) res.front.push({id:fid, text:f.pflegeLabel, cat:f.kategorie||""});
      if (f.hintBack)    res.back.push({id:fid, text:f.hintBack, cat:f.kategorie||""});
      if (f.hintLong)    res.long.push({id:fid, text:f.hintLong, cat:f.kategorie||""});
    }
    return res;
  }
  function setDataAttrs(hints){
    try{
      var front = document.getElementById('karte-vorderseite');
      var back  = document.getElementById('karte-rueckseite');
      if (front) front.dataset.rbHintsFront = JSON.stringify(hints.front||[]);
      if (back)  back.dataset.rbHintsBack  = JSON.stringify(hints.back||[]);
      window.RB_STATE = window.RB_STATE || {};
      RB_STATE.hints = hints;
    }catch(e){ /* ignore */ }
  }
  function recalcFromInput(){
    var inp = document.getElementById('pflanzensuche');
    if (!inp) return;
    var p = byDisplay(inp.value);
    var hints = computeHints(p);
    setDataAttrs(hints);
    if (window.console && console.info){ console.info('[RB_HINTS] front/back/long:', hints); }
  }
  function bind(){
    var inp = document.getElementById('pflanzensuche');
    if (inp){
      inp.addEventListener('change', recalcFromInput);
      inp.addEventListener('blur', recalcFromInput);
      inp.addEventListener('keydown', function(ev){ if (ev.key==='Enter'){ setTimeout(recalcFromInput, 0);} });
    }
    var b1 = document.getElementById('btn-uebernehmen-name');     if (b1) b1.addEventListener('click', recalcFromInput);
    
    var tries=0, t=setInterval(function(){
      if (window.RB_DATA && RB_DATA.plants && RB_DATA.features){ clearInterval(t); recalcFromInput(); }
      else if (++tries>40){ clearInterval(t); }
    },150);
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', bind); } else { bind(); }
})();</script><script defer="True" id="rb-guard-patch-f4c">

(function(){
  // closePanel sicher ummanteln (null.style vermeiden)
  function wrapClosePanel(){
    var orig = window.closePanel;
    if (typeof orig !== 'function' || orig._rbWrapped) return;
    function safeClose(el){
      try{
        if (typeof el === 'string') el = document.querySelector(el);
        if (!el || !el.style) return;
        return orig.call(this, el);
      }catch(e){ /* ignore */ }
    }
    safeClose._rbWrapped = true;
    window.closePanel = safeClose;
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wrapClosePanel, {once:true});
  } else { wrapClosePanel(); }

  
  (function(){
    if (!window.RB_STRINGS || typeof RB_STRINGS.nickname_long !== 'string') return;
    var PREFIX = 'Hinweis: Name/Kosename ist sehr lang';
    var desired = RB_STRINGS.nickname_long;
    function applyIn(root){
      var ctx = (root && root.querySelectorAll) ? root : document;
      var nodes = ctx.querySelectorAll('*');
      var changed = false;
      for (var i=0;i<nodes.length;i++){
        var t = (nodes[i].textContent || '').trim();
        if (t.indexOf(PREFIX) === 0){ nodes[i].textContent = desired; changed = true; }
      }
      return changed;
    }
    applyIn(document);
    if (window.MutationObserver){
      var mo = new MutationObserver(function(muts){
        for (var i=0;i<muts.length;i++){ applyIn(muts[i].target); }
      });
      try{ mo.observe(document.body || document.documentElement, {childList:true, characterData:true, subtree:true}); }catch(e){}
    }
    var tries = 0, t = setInterval(function(){ if (applyIn(document) || ++tries > 40) clearInterval(t); }, 150);
  })();
})();</script><script defer="True" id="rb-clear-backhint-g4b">
// G4b: 'Karte leeren' schließt NUR den Rückseitensticker-Hinweis (.slot-hint) und senkt #karte-rueckseite wieder ab.
(function(){
  function closeBackHintOnly(){
    try{
      document.querySelectorAll('#karte-vorderseite .slot-hint').forEach(function(el){
        try{ el.remove(); }catch(e){}
      });
      var k = document.getElementById('karte-rueckseite');
      if (k){ k.classList.remove('hint-raise'); }
    }catch(e){}
  }
  function bind(){
    var btn = document.getElementById('btn-leeren');
    if (!btn) return;
    btn.addEventListener('click', function(){
      // nach existierenden Clear-Handlern
      setTimeout(closeBackHintOnly, 0);
    });
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', bind); } else { bind(); }
})();</script><script defer="True" id="rb-logfilter-g7">
// G7: Filtert nur unsere lauten console.info-Logs (RB_*), lässt warn/error unverändert.
// Keine Layout-/Funktionsänderung.
(function(){
  var origInfo = console.info ? console.info.bind(console) : null;
  console.info = function(){
    try{
      var msg = arguments[0];
      if (typeof msg === 'string' && /^\[RB_(DATA|HINTS|CSV|STATE)\]/.test(msg)) {
        // unterdrücken
        return;
      }
    }catch(e){}
    return origInfo ? origInfo.apply(console, arguments) : void 0;
  };
})();
</script><script defer="True" id="g13-strings-bind-headers">
// G13: UI-Labels/Buttons aus strings.csv setzen (nur wenn Schlüssel existieren). Keine Layout-/Logikänderung.
(function(){
  function setText(id, txt){
    var el = document.getElementById(id);
    if (el && typeof txt === 'string' && txt.trim()!==''){
      el.textContent = txt;
    }
  }
  function apply(){
    if (!window.RB_STRINGS) return;
    // Überschriften (nur wenn vorhanden)
    if (RB_STRINGS.section_sticker_title) setText('section-sticker-title', RB_STRINGS.section_sticker_title);
    if (RB_STRINGS.section_field6_title)  setText('section-field6-title',  RB_STRINGS.section_field6_title);
    if (RB_STRINGS.section_field7_title)  setText('section-field7-title',  RB_STRINGS.section_field7_title);
    // Buttons (optional – werden nur gesetzt, wenn die Keys existieren)
    if (RB_STRINGS.btn_all_stickers)      setText('btn-alle-sticker',      RB_STRINGS.btn_all_stickers);
    if (RB_STRINGS.btn_matching_stickers) setText('btn-passende-sticker',  RB_STRINGS.btn_matching_stickers);
    if (RB_STRINGS.btn_clear_card)        setText('btn-leeren',            RB_STRINGS.btn_clear_card);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

      apply();
      // Falls der Strings-Loader asynchron ist
      setTimeout(apply, 200);
      setTimeout(apply, 800);
    });
  } else {
    apply();
    setTimeout(apply, 200);
    setTimeout(apply, 800);
  }
})();
</script><script defer="True" id="g13b-strings-bind-more">
// G13b: Weitere UI-Labels/Buttons optional aus strings.csv (RB_STRINGS) setzen.
// Greift nur, wenn die Keys existieren. Keine Layout-/Funktionsänderung.
(function(){
  function setText(id, key){
    try{
      if (!window.RB_STRINGS) return;
      var val = RB_STRINGS[key];
      if (typeof val !== 'string' || !val.trim()) return;
      var el = document.getElementById(id);
      if (el) el.textContent = val;
    }catch(e){}
  }
  function apply(){
    setText('h-links',               'h_links');               // "Pflegehinweise für –"
    setText('h-rechts',              'h_rechts');              // "Hier bearbeitest du ..."
    setText('btn-uebernehmen-kosename','btn_uebernehmen_kosename');
    setText('btn-uebernehmen-name',  'btn_uebernehmen_name');
    setText('btn-zoom-100',          'btn_zoom_100');
    setText('btn-zoom-150',          'btn_zoom_150');
    setText('btn-toggle-frontback',  'btn_toggle_frontback');
    setText('spruchPopupApply',      'spruch_apply');
    setText('spruchPopupCancel',     'spruch_cancel');
    setText('btn-karte-fertig-ok',   'btn_karte_fertig_ok');
    setText('rb-confirm-cancel',     'confirm_cancel');
    setText('rb-confirm-ok',         'confirm_ok');
    setText('feld7-trigger',         'feld7_trigger');
    setText('feld7-label',           'feld7_label');
    setText('rb-dd-foot',            'rb_dd_foot');
    setText('feld7-dd',              'feld7_dd');
    // bereits existierende Keys (aus G11) greifen weiterhin separat
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

      // mehrfach aufrufen, falls RB_STRINGS asynchron geladen wird
      apply(); setTimeout(apply, 200); setTimeout(apply, 800);
    });
  } else {
    apply(); setTimeout(apply, 200); setTimeout(apply, 800);
  }
})();
</script>
<script id="feinarbeit-step27-palette-from-master-hook">
/* Einzelschritt: Palette aus Master-CSV (falls vorhanden) in :root setzen – ohne bestehende Logik zu brechen.
   - Beibehalt von step19 als Fallback
   - Überschreiben NUR wenn gültige Hexfarben aus der Master-Indexierung vorliegen
   - Nicht-invasiv: wartet auf bekannte Ready-Events, sonst no-op
*/
(function(){
  function toHex(v){
    if (typeof v !== 'string') return null;
    v = v.trim();
    if (/^#[0-9a-fA-F]{6}$/.test(v)) return v;
    // #RGB -> #RRGGBB
    if (/^#[0-9a-fA-F]{3}$/.test(v)) {
      return '#' + v.slice(1).split('').map(c=>c+c).join('');
    }
    return null;
  }
  function applyPalette(map){
    if (!map || typeof map !== 'object') return;
    const root = document.documentElement;
    Object.entries(map).forEach(([cat, hex])=>{
      const key = String(cat||'').toLowerCase().replace(/[^a-z-]/g, '');
      const color = toHex(hex);
      if (key && color) {
        root.style.setProperty('--cat-' + key, color);
      }
    });
  }
  function tryApply(){
    try {
      // Erwartete Struktur nach Master-Indexierung (wird in einem späteren Schritt befüllt):
      //   window.RB_DATA.master.categoryColors = { standort: "#69B07F", giessen: "#4D8DFF", ... }
      if (window.RB_DATA && window.RB_DATA.master && window.RB_DATA.master.categoryColors) {
        applyPalette(window.RB_DATA.master.categoryColors);
      }
    } catch(e){ /* still no-op */ }
  }
  // Sofortversuch nach DOM, falls Daten schon da sind
  if (document.readyState !== 'loading') { tryApply(); }
  else { document.addEventListener('DOMContentLoaded', tryApply, {once:true}); }
  // Spätere Ready-Events aus dem bestehenden Loader abfangen (namen flexibel, no-op wenn nicht vorhanden)
  window.addEventListener('RB_MASTER_READY', tryApply);
  window.addEventListener('RB_DATA_READY', tryApply);
  window.addEventListener('RB_INDEX_READY', tryApply);
})();
</script>
<script id="feinarbeit-step28-master-colors-loader">
/* Einzelschritt: Farben aus Mastertabelle laden und RB_DATA.master.categoryColors befüllen.
   - erwartet Datei: ./Mastertabelle_pflanzendaten.csv
   - Kategoriezeile: 1. Zelle "Kategorie" (case-insensitive)
   - Farbzeile: direkt darunter; 1. Zelle enthält "Farb" oder "color"
   - schreibt Hex-Validierte Farben in :root via vorhandenen Hook (step27)
   - Alias: 'templija' -> zusätzlich 'temperatur'
   - keine weiteren Seiteneffekte
*/
(function(){
  const PATH = (window.masterPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv");

  function parseCSVLine(line){
    const out = [];
    let i=0, cur="", inQ=false;
    while(i<line.length){
      const ch = line[i];
      if(inQ){
        if(ch === '"'){
          if(i+1<line.length && line[i+1] === '"'){ cur+='"'; i+=2; continue; }
          inQ=false; i++; continue;
        }
        cur+=ch; i++; continue;
      } else {
        if(ch === '"'){ inQ=true; i++; continue; }
        if(ch === ','){ out.push(cur); cur=""; i++; continue; }
        cur+=ch; i++; continue;
      }
    }
    out.push(cur);
    return out;
  }

  function toHex(v){
    if (typeof v !== 'string') return null;
    v = v.trim();
    if (/^#[0-9a-fA-F]{6}$/.test(v)) return v.toUpperCase();
    if (/^#[0-9a-fA-F]{3}$/.test(v)) return ('#' + v.slice(1).split('').map(c=>c+c).join('')).toUpperCase();
    return null;
  }

  function firstCell(row){ return (row && row[0] ? String(row[0]).trim().toLowerCase() : ""); }

  async function load(){
    try{
      const res = await fetch(PATH, {cache:"no-store"});
      if(!res.ok) return;
      const txt = await res.text();
      const lines = txt.replace(/\r\n?/g,"\n").split("\n").filter(l=>l.length>0);
      const rows = lines.map(parseCSVLine);

      // find Kategorie row
      let kRow = -1;
      for(let i=0;i<rows.length;i++){
        if(firstCell(rows[i]) === "kategorie"){ kRow = i; break; }
      }
      if(kRow < 0 || kRow+1 >= rows.length) return;

      // find Farb row (prefer the next row; fallback: any row whose first cell includes 'farb' or 'color')
      let cRow = kRow+1;
      const f0 = firstCell(rows[cRow]);
      if(!(f0.includes("farb") || f0.includes("color"))){
        cRow = -1;
        for(let i=kRow+1;i<Math.min(kRow+6, rows.length); i++){
          const v = firstCell(rows[i]);
          if(v.includes("farb") || v.includes("color")) { cRow = i; break; }
        }
        if(cRow < 0) return;
      }

      const cats = rows[kRow];
      const cols = rows[cRow];
      const map = {};

      const startCol = 1; // Spalte 0 ist Label
      for(let j=startCol; j<Math.max(cats.length, cols.length); j++){
        const catRaw = (cats[j]||"").trim().toLowerCase();
        const hexRaw = (cols[j]||"").trim();
        if(!catRaw) continue;
        const hex = toHex(hexRaw);
        if(!hex) continue;

        // normalize cat key: allow only a-z and dash
        const key = catRaw.replace(/[^a-z-]/g,"");
        if(!key) continue;

        map[key] = hex;
        // Alias: templija -> temperatur
        if(key === "templija"){ map["templija"] = hex; }
      }

      if(Object.keys(map).length === 0) return;

      window.RB_DATA = window.RB_DATA || {};
      window.RB_DATA.master = window.RB_DATA.master || {};
      window.RB_DATA.master.categoryColors = Object.assign({}, window.RB_DATA.master.categoryColors || {}, map);

      // notify hooks
      window.dispatchEvent(new Event("RB_MASTER_READY"));
    }catch(e){
      // no-op on error
    }
  }

  if (document.readyState !== 'loading') load();
  else document.addEventListener('DOMContentLoaded', load, {once:true});
})();
</script>
<style id="feinarbeit-step29-pill-colors-by-cat">
/* Einzelschritt: Pillenfarbe nach Kategorie – ohne Streifen, nur ::before-Füllung */
.rb-row[data-cat="standort"]   .rb-box-rect::before { background: var(--cat-standort); }
.rb-row[data-cat="giessen"]    .rb-box-rect::before { background: var(--cat-giessen); }
.rb-row[data-cat="duengen"]    .rb-box-rect::before { background: var(--cat-duengen); }
.rb-row[data-cat="boden"]      .rb-box-rect::before { background: var(--cat-boden); }
.rb-row[data-cat="templija"]   .rb-box-rect::before { background: var(--cat-templija); }
.rb-row[data-cat="sonstiges"]  .rb-box-rect::before { background: var(--cat-sonstiges); }
.rb-row[data-cat="wachstum"]   .rb-box-rect::before { background: var(--cat-wachstum); }

.rb-box-rect[data-cat="standort"]::before   { background: var(--cat-standort); }
.rb-box-rect[data-cat="giessen"]::before    { background: var(--cat-giessen); }
.rb-box-rect[data-cat="duengen"]::before    { background: var(--cat-duengen); }
.rb-box-rect[data-cat="boden"]::before      { background: var(--cat-boden); }
.rb-box-rect[data-cat="templija"]::before   { background: var(--cat-templija); }
.rb-box-rect[data-cat="sonstiges"]::before  { background: var(--cat-sonstiges); }
.rb-box-rect[data-cat="wachstum"]::before   { background: var(--cat-wachstum); }
</style>
<script id="feinarbeit-step30-data-cat-normalize-templija">
/* Robust & einfach: Wandelt DOM-weit data-cat='templija' → "templija" (auch bei späteren DOM-Änderungen). */
(function(){
  function convertOnce(root){
    const scope = root || document;
    const nodes = scope.querySelectorAll('.rb-row[data-cat="templija"]');
    nodes.forEach(n => n.setAttribute('data-cat','templija'));
    return nodes.length;
  }
  let observer = null;
  function startObserver(){
    if (observer) return;
    observer = new MutationObserver((mutations)=>{
      mutations.forEach(m=>{
        if (m.type === 'childList'){
          m.addedNodes && m.addedNodes.forEach(node=>{
            if (node.nodeType === 1){ convertOnce(node); }
          });
        } else if (m.type === 'attributes' && m.target && m.target.matches('.rb-row[data-cat="templija"]')){
          m.target.setAttribute('data-cat','templija');
        }
      });
    });
    observer.observe(document.body, {subtree:true, childList:true, attributes:true, attributeFilter:['data-cat']});
    setTimeout(()=>{ observer && observer.disconnect(); observer=null; }, 10000);
  }
  function run(){ convertOnce(document); startObserver(); }
  if (document.readyState !== 'loading') run();
  else document.addEventListener('DOMContentLoaded', run, {once:true});
  window.addEventListener('RB_MASTER_READY', run);
  window.addEventListener('RB_INDEX_READY', run);
  window.addEventListener('RB_DATA_READY', run);
})();
</script>
<script id="feinarbeit-step34-stickerfile-csv-override">
/* CSV-only override (late): stickerFileFor(label) liest Dateiname ausschließlich aus der Master-CSV.
   Map: Anzeigename (Zeile 0) -> Dateiname (Zeile 2). Keine Synonyme. */
(function(){
  const PATH = (window.masterPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv");
  const norm = s => String(s||"").toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/ß/g,'ss').replace(/[^a-z0-9]+/g,' ').replace(/\s+/g,' ').trim();

  function parseCSVLine(line){
    const out = []; let cur="", inQ=false;
    for (let i=0;i<line.length;i++){
      const ch=line[i];
      if(inQ){
        if(ch==='"'){ if(i+1<line.length && line[i+1]==='"'){cur+='"'; i++; continue;} inQ=false; continue; }
        cur+=ch; continue;
      } else {
        if(ch==='"'){ inQ=true; continue; }
        if(ch===','){ out.push(cur); cur=""; continue; }
        cur+=ch; continue;
      }
    }
    out.push(cur); return out;
  }

  async function buildName2File(){
    try{
      const res = await fetch(PATH, {cache:"no-store"});
      if(!res.ok) return {};
      const txt = await res.text();
      const lines = txt.replace(/\r\n?/g,"\n").split("\n").filter(l=>l.length>0);
      const rows = lines.map(parseCSVLine);
      const aRow = rows[0] || [], fRow = rows[2] || [];
      const map = Object.create(null);
      for(let j=1;j<Math.max(aRow.length, fRow.length); j++){
        const name = norm(aRow[j]);
        let file = String(fRow[j]||"").trim().toLowerCase();
        if (file && /\.svg(\?.*)?$/i.test(file)) {
          file = file.replace(/\.svg(\?.*)?$/i, '.png');
        }
        if(name && file) map[name] = file;
      }
      return map;
    }catch(e){ return {}; }
  }

  function install(name2file){
    // Define a non-writable CSV-only stickerFileFor
    const fn = function(label){
      const key = norm(label);
      return name2file[key] || "";
    };
    try{
      Object.defineProperty(window, 'stickerFileFor', { value: fn, writable: true, configurable: true });
    }catch(e){
      window.stickerFileFor = fn; // fallback
    }
    window.RB_DATA = window.RB_DATA || {};
    window.RB_DATA.master = window.RB_DATA.master || {};
    window.RB_DATA.master.name2file = name2file;
    // re-trigger downstream hooks (icons, data-cat assigner, colors)
    window.dispatchEvent(new Event("RB_MASTER_READY"));
    window.dispatchEvent(new Event("RB_DATA_READY"));
  }

  async function run(){
    const map = await buildName2File();
    install(map);
  }

  if (document.readyState !== 'loading') setTimeout(run, 0);
  else document.addEventListener('DOMContentLoaded', ()=>setTimeout(run,0), {once:true});
  // also after full load, to out-prioritize late scripts
  window.addEventListener('load', ()=>setTimeout(run,0), {once:true});
})();
</script>
<script id="feinarbeit-step31-assign-datacat-from-master">
/* CSV-only Assign – feste Zeilen (robust zu Deiner Tabelle):
   Zeile 0 = Anzeigename, Zeile 1 = ID/Nr (optional), Zeile 2 = Dateiname, Zeile 4 = Kategorie, Zeile 5 = Farbcode
   Priorität: ID -> Dateiname -> Titel (exakt) -> Titel (Substring eindeutig)
*/
(function(){
  const PATH = (window.masterPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv");
  const VALID = new Set(["standort","giessen","duengen","boden","templija","sonstiges","wachstum"]);
  const norm = s => String(s||"").toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
      .replace(/ß/g,'ss').replace(/[^a-z0-9]+/g,' ').replace(/\s+/g,' ').trim();
  const normId = (v) => {
    const m = String(v||"").match(/\d+/);
    if (!m) return "";
    const raw = m[0];
    const noLead = raw.replace(/^0+/,'');
    return noLead || "0";
  };
  function parseCSVLine(line){
    const out = []; let cur="", inQ=false;
    for (let i=0;i<line.length;i++){
      const ch=line[i];
      if(inQ){
        if(ch==='"'){ if(i+1<line.length && line[i+1]==='"'){cur+='"'; i++; continue;} inQ=false; continue; }
        cur+=ch; continue;
      } else {
        if(ch==='"'){ inQ=true; continue; }
        if(ch===','){ out.push(cur); cur=""; continue; }
        cur+=ch; continue;
      }
    }
    out.push(cur); return out;
  }

  async function buildMaps(){
    const res = await fetch(PATH, {cache:"no-store"});
    if(!res.ok) return null;
    const txt = await res.text();
    const rows = txt.replace(/\r\n?/g,"\n").split("\n").filter(Boolean).map(parseCSVLine);

    const N = rows[0] || [];  // Anzeigename
    const I = rows[1] || [];  // ID/Nr (optional)
    const F = rows[2] || [];  // Dateiname
    const K = rows[4] || [];  // Kategorie
    // const C = rows[5] || [];  // Farbcode (für spätere Schritte)

    const name2cat = Object.create(null), file2cat = Object.create(null), fileBase2cat = Object.create(null), id2cat = Object.create(null);
    const name2cat_nospace = Object.create(null);
    const names = [];

    const maxLen = Math.max(N.length, I.length, F.length, K.length);
    for (let j=1;j<maxLen; j++){
      const name = norm(N[j]);
      const file = String(F[j]||"").trim().toLowerCase();
      const id   = normId(I[j]);
      let   cat  = norm(K[j]).replace(/[^a-z-]/g,'');
      if (/^(templija|temper)/.test(cat)) cat = "templija";
      if (cat){
        if (name){ name2cat[name] = cat; name2cat_nospace[name.replace(/\s+/g,"")] = cat; names.push(name); }
        if (file){ file2cat[file] = cat; }
        if (id){ id2cat[id] = cat; }
      }
    }
    return {name2cat, file2cat, id2cat, names, name2cat_nospace: name2cat_nospace};
  }

  function nearestRow(el){ return el.closest('[class*="rb-row"]'); }
  function titleOf(box){
    const row = nearestRow(box);
    const pick = (root)=> root && (root.querySelector('.rb-title')
                 || root.querySelector('.rb-label')
                 || root.querySelector('.rb-text')
                 || root.querySelector('[data-title]')
                 || root.querySelector('[data-label]')
                 || root);
    const tEl = pick(row) || pick(box) || box;
    const raw = (tEl && (tEl.getAttribute && (tEl.getAttribute('data-title') || tEl.getAttribute('data-label') || tEl.getAttribute('aria-label'))) )
                || (tEl && tEl.textContent) || "";
    return norm(String(raw).replace(/[-_/]+/g,' '));
  }
  function filenameOf(box){
    const row = nearestRow(box) || box;
    const el = row.querySelector('.rb-icon img, .rb-icon source, img.rb-icon, img[src], source[src]');
    let src = el ? (el.currentSrc || el.src || el.getAttribute('src') || "") : "";
    if (!src){
      const useEl = row.querySelector('use');
      if (useEl){
        const href = useEl.getAttribute('href') || useEl.getAttribute('xlink:href') || (useEl.href && useEl.href.baseVal) || "";
        if (href && href.charAt(0) === '#') src = href.slice(1) + ".svg";
      }
    }
    if (!src){
      const wrap = row.querySelector('.rb-icon, [data-filename]');
      src = (wrap && wrap.getAttribute('data-filename')) || "";
    }
    const m = src && src.toLowerCase().match(/[\w\-]+\.(svg|png)$/i);
    return m ? m[0] : "";
  }
  function idFromDOM(box){
    const row = nearestRow(box);
    let id = (row && row.getAttribute && row.getAttribute('data-id')) || (box.getAttribute && box.getAttribute('data-id')) || "";
    if (!id){
      const wrap = (row && row.querySelector && (row.querySelector('.rb-icon,[data-id]'))) || null;
      if (wrap){ id = wrap.getAttribute('data-id') || ""; }
    }
    id = normId(id);
    if (id) return id;
    const fn = filenameOf(box);
    const fromFile = fn && fn.match(/(\d+)/) ? fn.match(/(\d+)/)[1] : "";
    if (fromFile) return normId(fromFile);
    const t = titleOf(box);
    const m = t.match(/^(?:nr|no|nummer)\s*(\d+)/) || t.match(/^(\d+)/);
    if (m && m[1]) return normId(m[1]);
    return "";
  }

  function setCat(box, cat){
    if (!cat || !VALID.has(cat)) return false;
    box.setAttribute('data-cat', cat);
    const row = nearestRow(box);
    if (row) row.setAttribute('data-cat', cat);
    return true;
  }

  function applyMaps(maps, scope){
    const root = scope || document;
    const boxes = root.querySelectorAll('.rb-box-rect');
    boxes.forEach(box=>{
      const cur = (box.getAttribute('data-cat')||"").trim().toLowerCase();
      if (VALID.has(cur)) return;

      const id = idFromDOM(box);
      if (id && maps.id2cat[id]){ setCat(box, maps.id2cat[id]); return; }

      const file = filenameOf(box);
      if (file && maps.file2cat[file]){ setCat(box, maps.file2cat[file]); return; }
      // Basename-Match (svg/png egal)
      if (file){
        const b = file.toLowerCase().replace(/\.(svg|png)$/,'');
        if (maps.fileBase2cat && maps.fileBase2cat[b]){ setCat(box, maps.fileBase2cat[b]); return; }
      }

      const t = titleOf(box);
      const tNS = t.replace(/\s+/g,"");
      if (t && maps.name2cat[t]){ setCat(box, maps.name2cat[t]); return; }
      if (tNS && maps.name2cat_nospace && maps.name2cat_nospace[tNS]){ setCat(box, maps.name2cat_nospace[tNS]); return; }
// NEW: CSV-Dateiname direkt aus Titel via stickerFileFor (CSV-only) → dann file2cat
try{
  if (typeof window.stickerFileFor === 'function'){
    const fn = window.stickerFileFor(t);
    if (fn && maps.file2cat[fn]){ setCat(box, maps.file2cat[fn]); return; }
  }
}catch(_e){}

      if (t){
        const hits = maps.names.filter(n => t.includes(n));
        if (hits.length>=1){
          // Nimm den längsten Kandidaten (spezifischster Anzeigename)
          const sorted = hits.slice().sort((a,b)=> b.length - a.length);
          const top = sorted[0];
          // Falls es mehrere gleich lange Top-Kandidaten gibt, abbrechen (keine Fehlzuordnung)
          const maxLen = top.length;
          const ties = sorted.filter(x => x.length===maxLen);
          if (ties.length===1){ setCat(box, maps.name2cat[top]); return; }
        }
      }
    });
  }

  function startObserver(maps){
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        if (m.addedNodes) m.addedNodes.forEach(n=>{ if (n.nodeType===1) applyMaps(maps, n); });
      });
    });
    mo.observe(document.body, {childList:true, subtree:true});
    setTimeout(()=>mo.disconnect(), 30000);
  }

  async function run(){
    const maps = await buildMaps();
    if(!maps) return;
    applyMaps(maps, document);
    window.addEventListener('load', ()=>applyMaps(maps, document), {once:true});
    startObserver(maps);
    window.dispatchEvent(new Event("RB_MASTER_READY"));
  }

  if (document.readyState!=='loading') run();
  else document.addEventListener('DOMContentLoaded', run, {once:true});
})();
</script>
<script id="cleanup-step4a-stickerfile-override">
(function(){
  // Safe CSV-first override: do not modify original; just prefer Master-CSV map if present.
  const prevStickerFileFor = window.stickerFileFor && typeof window.stickerFileFor === 'function'
    ? window.stickerFileFor
    : function(){ return ""; };

  const norm = s => String(s||"").toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/ß/g,'ss').replace(/[^a-z0-9]+/g,' ')
    .replace(/\s+/g,' ').trim();

  function csvStickerFileFor(label){
    const key = norm(label);
    const map = (window.RB_DATA && window.RB_DATA.master && window.RB_DATA.master.name2file)
      ? window.RB_DATA.master.name2file
      : null;
    if (map && key in map) return map[key] || "";
    // Fallback to previous behavior until CSV map is ready
    try { return prevStickerFileFor(label); } catch(e){ return ""; }
  }

  try{
    Object.defineProperty(window, 'stickerFileFor', { value: csvStickerFileFor, writable: false, configurable: true });
  }catch(e){
    window.stickerFileFor = csvStickerFileFor;
  }

  // If the CSV map becomes ready later, re-dispatch so dependent code can refresh
  window.addEventListener('RB_MASTER_READY', function(){ /* consumers may re-evaluate as needed */ });
})();
</script>
<script id="cleanup-step5-catcolors-from-csv">
(function(){
  const PATH = (window.masterPath || "https://raw.githubusercontent.com/hamannsibylle-cmd/konfigurator/refs/heads/main/Mastertabelle_pflanzendaten.csv");
  const VARS = ["standort","giessen","duengen","boden","templija","sonstiges","wachstum"];
  const norm = s => String(s||"").toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g,'')
    .replace(/ß/g,'ss').replace(/[^a-z0-9#]+/g,' ')
    .replace(/\s+/g,' ').trim();

  function parseCSVLine(line){
    const out=[]; let cur="", inQ=false;
    for(let i=0;i<line.length;i++){
      const ch=line[i];
      if(inQ){
        if(ch==='"'){ if(i+1<line.length && line[i+1]==='"'){cur+='"'; i++; continue;} inQ=false; continue; }
        cur+=ch; continue;
      }else{
        if(ch==='"'){ inQ=true; continue; }
        if(ch===','){ out.push(cur); cur=""; continue; }
        cur+=ch; continue;
      }
    }
    out.push(cur); return out;
  }

  function validHex(col){
    if(!col) return "";
    col = String(col).trim();
    if(!col) return "";
    if(col[0] !== "#" ){ col = "#" + col; }
    // #RGB, #RRGGBB, #RRGGBBAA zulassen
    if(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(col)) return col;
    return "";
  }

  async function loadAndApply(){
    try{
      const res = await fetch(PATH, {cache:"no-store"});
      if(!res.ok) return;
      const txt = await res.text();
      const rows = txt.replace(/\r\n?/g,"\n").split("\n").filter(Boolean).map(parseCSVLine);

      const K = rows[4] || []; // Kategorie
      const C = rows[5] || []; // Farbcode
      const seen = Object.create(null);

      for(let j=1;j<Math.max(K.length, C.length); j++){
        let cat = norm(K[j]).replace(/[^a-z]/g,'');
        if (/^(templija|temper)/.test(cat)) cat = "templija";
        const col = validHex(C[j]||"");
        if(!cat || !col) continue;
        if(!VARS.includes(cat)) continue;
        if(seen[cat]) continue; // erstes nicht-leeres Vorkommen verwenden
        seen[cat] = col;
      }

      const root = document.documentElement;
      Object.keys(seen).forEach(cat => {
        root.style.setProperty(`--cat-${cat}`, seen[cat]);
      });
      // optional: Repaint triggern
      window.dispatchEvent(new Event("RB_PALETTE_READY"));
    }catch(e){/* still & safe */}
  }

  if (document.readyState !== 'loading') loadAndApply();
  else document.addEventListener('DOMContentLoaded', loadAndApply, {once:true});
})();
</script>
<script id="cleanup-step6-schema-constants">
(function(){
  // NICHTS umstellen, nur dokumentieren & zentral bereitstellen.
  window.RB_CSV_SCHEMA = Object.freeze({
    rows: Object.freeze({
      anzeigename: 0,
      id:          1,
      dateiname:   2,
      wasserzeichen: 3,
      kategorie:   4,
      farbcode:    5
    }),
    categories: Object.freeze(["standort","giessen","duengen","boden","templija","sonstiges","wachstum"])
  });
  // Optional: kurze Konsoleninfo zur Orientierung
  if (!window.__RB_SCHEMA_INFO_SHOWN__) {
    window.__RB_SCHEMA_INFO_SHOWN__ = true;
    window.__DEBUG__ && console.info("RB_CSV_SCHEMA gesetzt:", window.RB_CSV_SCHEMA);
  }
})();
</script>
<script id="cleanup-step11-runtime-compat-templija">
(function(){
  const T_OLD = "temperatur";
  const T_NEW = "templija";

  function fixNode(n){
    if (!n || n.nodeType !== 1) return;
    // data-cat direkt am Element
    const cat = n.getAttribute && n.getAttribute("data-cat");
    if (cat && cat.toLowerCase() === T_OLD) n.setAttribute("data-cat", T_NEW);

    // gängige Ziele: .rb-box-rect + Row-Eltern
    if (n.matches && n.matches('.rb-box-rect, [class*="rb-row"]')){
      const c = n.getAttribute("data-cat");
      if (c && c.toLowerCase() === T_OLD) n.setAttribute("data-cat", T_NEW);
    }

    // Kinder prüfen
    if (n.querySelectorAll){
      n.querySelectorAll('[data-cat]').forEach(el=>{
        const v = el.getAttribute("data-cat");
        if (v && v.toLowerCase() === T_OLD) el.setAttribute("data-cat", T_NEW);
      });
    }
  }

  function fixAll(root){
    (root.querySelectorAll ? root.querySelectorAll('[data-cat]') : []).forEach(el=>{
      const v = el.getAttribute("data-cat");
      if (v && v.toLowerCase() === T_OLD) el.setAttribute("data-cat", T_NEW);
    });
  }

  function start(){
    try{ fixAll(document); }catch(_){}
    // Beobachte nachträgliche Änderungen für 30s
    const mo = new MutationObserver(muts=>{
      muts.forEach(m=>{
        if (m.addedNodes) m.addedNodes.forEach(n=> fixNode(n));
        if (m.type === "attributes" && m.attributeName === "data-cat") fixNode(m.target);
      });
    });
    try{
      mo.observe(document.documentElement, {subtree:true, childList:true, attributes:true, attributeFilter:["data-cat"]});
      setTimeout(()=>mo.disconnect(), 30000);
    }catch(_){/* still */}
  }

  if (document.readyState !== "loading") start();
  else document.addEventListener("DOMContentLoaded", start, {once:true});
})();
</script>
<script id="s5-kose-hint-strict">(function(){ /* s5-kose-hint-strict disabled – logic moved to rb-kose-hint-js / rb-plant-hint-js */ })();</script>
<script id="s5b-kose-hint-only-strings">(function(){ /* s5b-kose-hint-only-strings disabled – logic moved to rb-kose-hint-js / rb-plant-hint-js */ })();</script>
<script id="rb-disable-browser-autofill">
(function(){
  function disableAttrs(inp){
    try{
      if (!inp) return;
      inp.setAttribute('autocomplete','off');
      inp.setAttribute('autocapitalize','none');
      inp.setAttribute('autocorrect','off');
      inp.setAttribute('spellcheck','false');
      // Heuristik brechen: einmalig wechselnden Namen setzen
      if (!inp.__rbNameSet){
        inp.setAttribute('name', 'nostore_' + Date.now());
        inp.__rbNameSet = true;
      }
    }catch(_){}
  }

  function applyNow(){
    disableAttrs(document.getElementById('pflanzensuche'));
    disableAttrs(document.getElementById('kosenameInput'));
    // Fallback: alle Inputs in der Steuerleiste absichern
    var bar = document.querySelector('.steuerleiste') || document;
    bar.querySelectorAll('input[type="text"],input:not([type])').forEach(disableAttrs);
    // Form-Container
    var form = document.querySelector('form');
    if (form) form.setAttribute('autocomplete','off');
  }

  document.addEventListener('DOMContentLoaded', applyNow);

  var bar = document.querySelector('.steuerleiste') || document.body;
  if (bar && window.MutationObserver){
    var mo = new MutationObserver(function(muts){
      muts.forEach(function(m){
        m.addedNodes && m.addedNodes.forEach(function(n){
          if (n && n.querySelectorAll){
            n.querySelectorAll('input').forEach(disableAttrs);
          } else if (n && n.tagName === 'INPUT'){
            disableAttrs(n);
          }
        });
      });
    });
    mo.observe(bar, {childList:true, subtree:true});
  }
})();
</script>
<script id="rb-textdrop-guard-16c">
(function(){
  if (!window.__rbDragCaptureBound){
    window.addEventListener('dragstart', function(ev){
      try{
        var t = ev && ev.target;
        var txt = "";
        if (t){
          if (t.getAttribute) txt = t.getAttribute('data-text') || "";
          if (!txt && t.textContent) txt = t.textContent.trim();
        }
        if (txt) window.__rbLastDragText = txt;
      }catch(_){}
    }, true);
    window.__rbDragCaptureBound = true;
  }
  function isTextFieldTarget(ev){
    try{
      var t = ev && ev.target;
      if (!t || !t.closest) return false;
      return !!t.closest('#feld17,#feld18,#feld19,#feld20,#feld21,#feld22,#feld23,#feld24,#feld25');
    }catch(_){ return false; }
  }
  if (!window.__rbDropGuardBound){
    window.addEventListener('drop', function(ev){
      try{
        if (!isTextFieldTarget(ev)) return;
        if (ev && ev.dataTransfer){
          try{ ev.dataTransfer.clearData(); }catch(_){}
          try{ ev.dataTransfer.setData('text/plain',''); }catch(_){}
        }
      }catch(_){}
    }, true);
    window.__rbDropGuardBound = true;
  }
  (function(){
    var orig = window.empfangeText;/* STEP17E_MARK: window.empfangeText = function(...) – Kandidat, noch nicht geändert */

    window.empfangeText = function(event, feldId){
      try{
        if (event && event.preventDefault) event.preventDefault();
        var txt = "";
        if (event && event.dataTransfer){
          var dt = event.dataTransfer;
          try { txt = dt.getData('text/plain'); } catch(_){}
          if (!txt) { try { txt = dt.getData('text'); } catch(_){ } }
          if (!txt) { try { 
            var html = dt.getData('text/html');
            if (html) { txt = html.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim(); }
          } catch(_){ } }
        }
        if (!txt && window.__rbLastDragText) txt = window.__rbLastDragText;
        if (!txt && typeof orig === 'function') return orig(event, feldId);
        if (!txt) return;
        var el = document.getElementById(feldId);
        if (!el) return;
        while (el.firstChild) el.removeChild(el.firstChild);
        var box = document.createElement('div');
        box.className = 'droptext';
        box.textContent = (txt||'').trim();
        el.appendChild(box);
      }catch(_){}
    };
  })();
})();
</script>
<script id="rb-textdrop-bypass-16f">
(function(){
  function closestFieldId(el){
    while (el && el.nodeType === 1){
      if (el.id && /^feld(1[7-9]|2[0-5])$/.test(el.id)) return el.id;
      el = el.parentElement;
    }
    return null;
  }
  function setFieldText(fId, text){
    var el = document.getElementById(fId);
    if (!el) return;
    while (el.firstChild) el.removeChild(el.firstChild);
    var box = document.createElement('div');
    box.className = 'droptext';
    box.textContent = (text||'').trim();
    el.appendChild(box);
  }
  function getFieldText(fId){
    var el = document.getElementById(fId);
    if (!el) return "";
    var box = el.querySelector('.droptext');
    return box ? (box.textContent||"").trim() : "";
  }
  function extractTextFromDT(dt){
    if (!dt) return "";
    var tryTypes = ['text/plain','text','text/uri-list','text/html'];
    var txt = "";
    for (var i=0; i<tryTypes.length && !txt; i++){
      try { txt = dt.getData(tryTypes[i]) || ""; } catch(_){}
    }
    if (!txt && dt.types && dt.types.length){
      for (var j=0; j<dt.types.length && !txt; j++){
        var t = dt.types[j];
        try { var v = dt.getData(t); if (v) txt = v; } catch(_){}
      }
    }
    if (txt){
      // if it's HTML, make text
      if (/<[a-z][\s\S]*>/i.test(txt)){
        txt = txt.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
      }
      return String(txt).trim();
    }
    return "";
  }
  // Fallback: remember drag text
  if (!window.__rbDragCaptureBound){
    window.addEventListener('dragstart', function(ev){
      try{
        var t = ev && ev.target;
        var txt = "";
        if (t){
          if (t.getAttribute) txt = t.getAttribute('data-text') || "";
          if (!txt && t.textContent) txt = t.textContent.trim();
        }
        if (txt) window.__rbLastDragText = txt;
      }catch(_){}
    }, true);
    window.__rbDragCaptureBound = true;
  }

  if (!window.__rbDropBypassBound){
    window.addEventListener('drop', function(ev){
      try{
        var destId = closestFieldId(ev.target);
        
    // STEP19A: Feld 17–25 via feldspezifischem Handler – globalen Bypass hier überspringen
    try{
      if (/^feld(1[7-9]|2[0-5])$/i.test(destId)) { return; }
    }catch(_){}
    if (!destId) return; // only our fields
        var dt = ev && ev.dataTransfer ? ev.dataTransfer : null;
        var payload = extractTextFromDT(dt);
        // detect source field id anywhere in payload
        var m = payload && payload.match(/\bfeld(1[7-9]|2[0-5])\b/i);
        if (m && m[0]){
          var srcId = m[0].toLowerCase();
          // normalize to lower-case ids present in DOM
          var el = document.getElementById(srcId) || document.getElementById(srcId.toUpperCase());
          if (srcId === destId) { ev.preventDefault(); ev.stopPropagation(); if (ev.stopImmediatePropagation) ev.stopImmediatePropagation(); return false; }
          // swap texts
          var srcTxt = getFieldText(srcId);
          var dstTxt = getFieldText(destId);
          setFieldText(destId, srcTxt);
          setFieldText(srcId, dstTxt);
          ev.preventDefault();
          if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
          ev.stopPropagation();
          return false;
        } else {
          // treat as normal text drop
          var txt = payload || window.__rbLastDragText || "";
          if (!txt) return; // let others handle
          setFieldText(destId, txt);
          
          // -- RB usage update for text drops from dropdown/free --
          try{
            var slot = document.getElementById(destId);
            // alten Label-Zähler zurücknehmen
            var oldLab = (slot && slot.dataset && (slot.dataset.rbLabel || slot.dataset.rbOrigin)) ? (slot.dataset.rbLabel || slot.dataset.rbOrigin) : "";
            if (oldLab){
              var usage = window.__rbUsage || (window.__rbUsage = {});
              usage[oldLab] = Math.max(0, (usage[oldLab]||0) - 1);
              try{
                var rows = document.querySelectorAll('#rb-boxes .rb-row');
                for (var i=0;i<rows.length;i++){
                  var t = rows[i].querySelector('.rb-box-titel');
                  if (t && (t.textContent||'').trim().toLowerCase() === oldLab){
                    var box = rows[i].querySelector('.rb-box');
                    if (box){
                      if ((usage[oldLab]||0) > 0) box.classList.add('rb-used');
                      else box.classList.remove('rb-used');
                    }
                  }
                }
              }catch(_){}
            }
            // neuen Label aus letzter Text-Label-Quelle bestimmen
            var newLab = (typeof currentLabel !== 'undefined' && currentLabel) ? currentLabel : ((window.currentLabel || window.__rbLastTextLabel || '').toLowerCase());
            if (slot && slot.dataset){
              slot.dataset.rbType = 'text';
              if (newLab){
                slot.dataset.rbLabel = newLab;
                slot.dataset.rbOrigin = newLab;
              }else{
                delete slot.dataset.rbLabel;
                delete slot.dataset.rbOrigin;
              }
            }
            if (newLab){
              var usage2 = window.__rbUsage || (window.__rbUsage = {});
              usage2[newLab] = (usage2[newLab]||0) + 1;
              try{
                var rows2 = document.querySelectorAll('#rb-boxes .rb-row');
                for (var j=0;j<rows2.length;j++){
                  var t2 = rows2[j].querySelector('.rb-box-titel');
                  if (t2 && (t2.textContent||'').trim().toLowerCase() === newLab){
                    var box2 = rows2[j].querySelector('.rb-box');
                    if (box2){
                      if ((usage2[newLab]||0) > 0) box2.classList.add('rb-used');
                      else box2.classList.remove('rb-used');
                    }
                  }
                }
              }catch(_){}
            }
          }catch(_){}
          // -- /RB usage update --
    ev.preventDefault();
          if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
          ev.stopPropagation();
          return false;
        }
      }catch(_){}
    }, true); // capturing
    window.__rbDropBypassBound = true;
  }

  if (!window.__rbOverBypassBound){
    window.addEventListener('dragover', function(ev){
      try{
        var id = closestFieldId(ev.target);
        if (!id) return;
        ev.preventDefault();
      }catch(_){}
    }, true);
    window.__rbOverBypassBound = true;
  }
})();
</script>
<script id="rb-currentLabel-18e">
(function(){
  if (window.__rbCurrentLabelBound) return;
  window.addEventListener('dragstart', function(ev){
    try{
      var t = ev.target || ev.srcElement;
      var label = "";
      // 1) Wenn Element selbst ein data-label hat
      if (t && t.dataset && t.dataset.label){
        label = String(t.dataset.label||"").trim().toLowerCase();
      }
      // 2) Sonst: in der Nähe den roten Kasten ermitteln
      if (!label){
        var row = t && t.closest ? t.closest('.rb-row') : null;
        var lab = row && row.querySelector ? row.querySelector('.rb-box-titel') : null;
        if (lab) label = String((lab.textContent||"")).trim().toLowerCase();
      }
      // 3) Fallback: freier Text-Bereich
      if (!label){
        var free = t && t.closest ? t.closest('#rb-dd-free') : null;
        if (free) label = "freitext";
      }
      window.currentLabel = label || "";
    }catch(_){ window.currentLabel = ""; }
  }, true); // capturing
  window.__rbCurrentLabelBound = true;
})();
</script>
<script id="rb-text-usage-17to25-18f">
(function(){
  if (window.__rbTextUsageBound18f) return;
  function normalizeLabel(s){
    return String(s||"").trim().toLowerCase();
  }
  function updateBoxColor(label, usage){
    try{
      var rows = document.querySelectorAll('#rb-boxes .rb-row');
      for (var i=0;i<rows.length;i++){
        var t = rows[i].querySelector('.rb-box-titel');
        if (!t) continue;
        var lab = normalizeLabel(t.textContent||"");
        if (lab === label){
          var box = rows[i].querySelector('.rb-box');
          if (box){
            if ((usage[label]||0) > 0) box.classList.add('rb-used');
            else box.classList.remove('rb-used');
          }
        }
      }
    }catch(_){}
  }
  function setFieldTextDirect(el, txt){
    if (!el) return;
    while (el.firstChild) el.removeChild(el.firstChild);
    var box = document.createElement('div');
    box.className = 'droptext';
    box.textContent = String(txt||"").trim();
    el.appendChild(box);
  }
  for (var i=17;i<=25;i++){
    (function(i){
      var feld = document.getElementById('feld'+i);
      if (!feld) return;
      if (!feld.getAttribute('draggable')) feld.setAttribute('draggable','true');
      if (feld.__rbTextUsageDrop18f) return;
      feld.addEventListener('drop', function(e){
        try{
          var txt = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
          if (!txt) return;
          if (/^feld\d{1,2}$/i.test(txt)) return;
          if (/sticker\//i.test(txt)) return;
          e.preventDefault();
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          e.stopPropagation();
          try{
            if (feld.dataset && feld.dataset.rbOrigin){
              var oldLab = normalizeLabel(feld.dataset.rbOrigin);
              var usage = window.__rbUsage || (window.__rbUsage = {});
              usage[oldLab] = Math.max(0, (usage[oldLab]||0) - 1);
              updateBoxColor(oldLab, usage);
              delete feld.dataset.rbOrigin;
              delete feld.dataset.rbLabel;
            }
          }catch(_){}
          setFieldTextDirect(feld, txt);
          var label = normalizeLabel(window.currentLabel || "");
          if (label){
            var usage2 = window.__rbUsage || (window.__rbUsage = {});
            usage2[label] = (usage2[label]||0) + 1;
            updateBoxColor(label, usage2);
            if (feld.dataset){
              feld.dataset.rbType = 'text';
              feld.dataset.rbOrigin = label;
              feld.dataset.rbLabel = label;
            }
          }
          return false;
        }catch(_){}
      }, true);
      feld.__rbTextUsageDrop18f = true;
    })(i);
  }
  window.__rbTextUsageBound18f = true;
})();
</script>
<script id="rb-currentLabel-click-18f4">
(function(){
  if (window.__rbCurrentLabelClickBound) return;
  function norm(s){ return String(s||"").trim().toLowerCase(); }
  // Merke die aktuell geöffnete/geklickte rote Box als Label-Quelle
  document.addEventListener('click', function(e){
    try{
      var rect = e.target && e.target.closest ? e.target.closest('.rb-box-rect') : null;
      if (rect){
        var row = rect.closest('.rb-row');
        var tit = row && row.querySelector ? row.querySelector('.rb-box-titel') : null;
        window.currentLabel = tit ? norm(tit.textContent) : "";
      }
    }catch(_){}
  }, true); // capturing wie in Referenz
  window.__rbCurrentLabelClickBound = true;
})();
</script>
<script id="rb-currentLabel-18f5">
(function(){
  if (window.__rbCurrentLabelRobustBound) return;
  function norm(s){ return String(s||"").trim().toLowerCase(); }
  function findLabelFrom(el){
    try{
      if (!el) return "";
      // 1) direkte data-label Quelle
      if (el.dataset && el.dataset.label) return norm(el.dataset.label);
      // 2) im Umfeld: nächste .rb-row, darin Titel (klassenrobust)
      var row = el.closest ? el.closest('.rb-row') : null;
      if (row){
        var tit = row.querySelector("[class*='box-titel']");
        if (tit && tit.textContent) return norm(tit.textContent);
      }
      // 3) Fallback: Element, das wie ein Dropdown-Container aussieht
      var cont = el.closest ? el.closest("[id^='rb-dd'], .rb-dd, .rb-box, [class*='box']") : null;
      if (cont){
        var t2 = cont.querySelector("[class*='box-titel']");
        if (t2 && t2.textContent) return norm(t2.textContent);
      }
    }catch(_){}
    return "";
  }
  function setter(ev){
    try{
      var t = ev.target || ev.srcElement;
      var lab = findLabelFrom(t);
      if (lab) window.currentLabel = lab;
    }catch(_){}
  }
  // Klick erfasst „Box öffnen/wechseln“
  document.addEventListener('click', setter, true);
  // Dragstart erfasst direkten Start aus Dropdown-Item
  document.addEventListener('dragstart', setter, true);
  window.__rbCurrentLabelRobustBound = true;
})();
</script>
<script id="rb-17to25-field-drop-19a">
// Feldspezifischer Drop-Handler 17–25 – 1:1 aus Vergleich (capturing)
(function(){
  if (window.__rbFieldDrop17to25Bound) return;
  for (var i=17;i<=25;i++){
    (function(i){
      var feld = document.getElementById('feld'+i);
      if (!feld) return;

      // Feld selbst draggable machen (für Müll)
      if (!feld.getAttribute('draggable')) feld.setAttribute('draggable','true');
      if (!feld.__dragBound){
        feld.addEventListener('dragstart', function(ev){
          try { ev.dataTransfer.setData('text/plain', 'feld'+i); }catch(_){}
        });
        feld.__dragBound = true;
      }

      feld.addEventListener('drop', function(e){
        try{
          var txt = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
          if (!txt) return; // kein Text, ggf. Sticker
          // Wenn es ein Sticker wäre, enthält payload i.d.R. "..." – dann ignorieren (lassen wir den Sticker-Handler laufen)
          if (/sticker\//i.test(txt)) return;

          // Wir wollen die Standard-Handler nicht doppelt feuern lassen
          e.preventDefault();
          e.stopPropagation();
          try{ e.stopImmediatePropagation(); }catch(_){}

          // Alten Ursprung abmelden (falls Überschreiben)
          if (feld.dataset && feld.dataset.rbOrigin){
            dec(feld.dataset.rbOrigin);
            delete feld.dataset.rbOrigin;
          }
          // Neuen Ursprung registrieren
          if (currentLabel){
            inc(currentLabel);
            if (feld.dataset) feld.dataset.rbOrigin = currentLabel;
          }

          }catch(_){}
      }, true);
    })(i);
  }

  // Mülleimer: Text-Felder löschen + Zähler zurück
  function bindTrash(){
    var bin = document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
    if (!bin || bin.__rbBound) return;
    bin.addEventListener('dragover', function(ev){ ev.preventDefault(); });
    bin.addEventListener('drop', function(ev){
      ev.preventDefault();
      var payload = '';
      try{ payload = ev.dataTransfer.getData('text/plain') || ''; }catch(_){}
      var m = payload.match(/^feld(\d{1,2})$/);
      if (m){
        var id = payload;
        var num = parseInt(m[1],10);
        if (num>=17 && num<=25){
          var f = document.getElementById(id);
          if (f){
            if (f.dataset && f.dataset.rbOrigin){ dec(f.dataset.rbOrigin); delete f.dataset.rbOrigin; }
            f.innerHTML = '';
          }
        }
      }
      // Sticker-Löschlogik (falls vorhanden) bleibt unberührt, da wir nur Feld-IDs behandeln
    });
    bin.__rbBound = true;
  }
  bindTrash();
  // Falls die Toolbar neu gerendert würde
  document.addEventListener('DOMContentLoaded', bindTrash);

  // "Karte leeren" setzt alles zurück
  (function(){
    var btn = document.getElementById('btn-leeren');
    if (!btn || btn.__rbUsageClearBound) return;
    btn.addEventListener('click', function(){
      // Zähler nullen + Farben zurück
      Object.keys(usage).forEach(function(k){ usage[k]=0; updateColor(k); });
      // Herkunftsmarker von Feldern entfernen
      for (var i=17;i<=25;i++){
        var f = document.getElementById('feld'+i);
        if (f && f.dataset) delete f.dataset.rbOrigin;
      }
    });
    btn.__rbUsageClearBound = true;
  })();
})();

// --- END {sc.get('id')} ---

// --- BEGIN rb-sticker-usage ---

(function(){
  'use strict';
  // --- Helpers --------------------------------------------------------------
  function rbNorm(s){
    try{ if (typeof window.norm === 'function') return window.norm(s); }catch(_){}
    return String(s||'').trim().toLowerCase();
  }
  // gemeinsamer Zähler (Teilen mit Text-Tracker)
  var usage = window.__rbUsage || (window.__rbUsage = {});

  function findBoxElByLabel(labelNorm){
    var rows = document.querySelectorAll('#rb-boxes .rb-row');
    for (var i=0;i<rows.length;i++){
      var t = rows[i].querySelector('.rb-box-titel');
      if (t && rbNorm(t.textContent) === labelNorm){
        return rows[i].querySelector('.rb-box');
      }
    }
    return null;
  }
  function updateColor(labelNorm){
    var box = findBoxElByLabel(labelNorm);
    if (!box) return;
    var count = usage[labelNorm] || 0;
    if (count > 0) box.classList.add('rb-used');
    else box.classList.remove('rb-used');
  }
  function inc(labelNorm){
    if (!labelNorm) return;
    usage[labelNorm] = (usage[labelNorm] || 0) + 1;
    updateColor(labelNorm);
  }
  function dec(labelNorm){
    if (!labelNorm) return;
    usage[labelNorm] = Math.max(0, (usage[labelNorm] || 0) - 1);
    updateColor(labelNorm);
  }

  // --- Quelle bei Sticker-Drag ermitteln -----------------------------------
  var currentLabelSticker = null;
  (function bindStickerDragSource(){
    var scope = document.getElementById('rb-scope');
    if (!scope || scope.__rbStickerDragBound) return;
    scope.addEventListener('dragstart', function(ev){
      try{
        var img = ev.target;
        if (!(img && img.closest && img.closest('.rb-icon'))) return; // nur Icon-Drag aus weißem Quadrat
        var row = img.closest('.rb-row');
        var t = row && row.querySelector('.rb-box-titel');
        currentLabelSticker = rbNorm(t ? (t.textContent || '') : '');
      }catch(_){ currentLabelSticker = null; }
    }, true);
    scope.__rbStickerDragBound = true;
  })();

  // --- Sticker platzieren -> Zähler pflegen --------------------------------
  (function wrapEmpfangeSticker(){
    if (typeof window.empfangeSticker !== 'function' || window.__rbWrapStickerUsage) return;
    var _orig = window.empfangeSticker;
    window.empfangeSticker = function(event, feldId){
      var slot = document.getElementById(feldId);
      var old = (slot && slot.dataset) ? (slot.dataset.rbOriginSticker || '') : '';

      var res = _orig.apply(this, arguments);

      try{
        var label = currentLabelSticker ? rbNorm(currentLabelSticker) : '';
        if (slot){
          if (old && old !== label){ dec(old); }
          // Wenn alter und neuer Ursprung gleich sind, nichts ändern
          if (label){
            inc(label);
            slot.dataset.rbOriginSticker = label;
          }else{
            // Falls kein Label erkannt, alter Ursprung löschen, aber nicht zählen
            if (slot && slot.dataset) delete slot.dataset.rbOriginSticker;
          }
        }
      }catch(_){}
      currentLabelSticker = null;
      return res;
    };
    window.__rbWrapStickerUsage = true;
  })();

  // --- Sticker-Slots draggable für Mülleimer --------------------------------
  function makeSlotDraggable(slot){
    if (!slot) return;
    var img = slot.querySelector('img');
    if(!img || img.__rbDragBound) return;
    img.setAttribute('draggable','true');
    img.addEventListener('dragstart', function(ev){
      try{
        ev.dataTransfer.setData('text/plain', slot.id);
        ev.dataTransfer.effectAllowed = 'move';
      }catch(_){}
    });
    img.__rbDragBound = true;
  }
  (function bindStickerSlots(){
    var ids = [2,3,4,5,7,8,9,10,11,12,13,14,15,16].map(function(n){ return 'feld'+n; });
    ids.forEach(function(id){
      var slot = document.getElementById(id);
      if (!slot) return;
      makeSlotDraggable(slot);
      var obs = new MutationObserver(function(){ makeSlotDraggable(slot); });
      obs.observe(slot, {childList:true});
    });
  });
  window.__rbFieldDrop17to25Bound = true;
})();
</script>
<script id="rb-block-slot-drop-19c">
(function(){
  if (window.__rbBlockSlotDropBound19c) return;
  var left = document.getElementById('rb-boxes');
  if (left){
    // Nur links blocken: Drops, die aus Feldern 17–25 stammen
    left.addEventListener('drop', function(e){
      try{
        var txt = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
        if (/^feld(1[7-9]|2[0-5])$/i.test(txt)){
          e.preventDefault();
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          e.stopPropagation();
          return false;
        }
      }catch(_){}
    }, true); // capturing, damit nichts anderes greift
  }
  window.__rbBlockSlotDropBound19c = true;
})();
</script>
<script id="rb-block-slot-dragover-19d">
(function(){
  if (window.__rbBlockSlotDragOverBound19d) return;

  function isSlot17to25(el){
    try{
      if (!el || !el.closest) return false;
      var fld = el.closest("[id^='feld']");
      if (!fld || !fld.id) return false;
      return /^feld(1[7-9]|2[0-5])$/i.test(fld.id);
    }catch(_){ return false; }
  }

  // Merke, ob der Drag aus Feld 17–25 stammt
  document.addEventListener('dragstart', function(e){
    try{
      var t = e.target || e.srcElement;
      window.__rbDragFromSlot17to25 = !!isSlot17to25(t);
    }catch(_){ window.__rbDragFromSlot17to25 = false; }
  }, true);

  document.addEventListener('dragend', function(){
    window.__rbDragFromSlot17to25 = false;
  }, true);

  // Links: visuelles Highlight bei Slot-Drags unterdrücken
  var left = document.getElementById('rb-boxes');
  if (left){
    ['dragenter','dragover'].forEach(function(type){
      left.addEventListener(type, function(e){
        try{
          if (window.__rbDragFromSlot17to25){
            e.preventDefault();
            if (e.stopImmediatePropagation) e.stopImmediatePropagation();
            e.stopPropagation();
            // Möglichen Focus-Rand entfernen
            if (document.activeElement && left.contains(document.activeElement)){
              try{ document.activeElement.blur(); }catch(_){}
            }
            return false;
          }
        }catch(_){}
      }, true); // capturing
    });
  }

  window.__rbBlockSlotDragOverBound19d = true;
})();
</script>
<script id="S08-neutralize-droptext">
(function(){
  'use strict';
  function kill(e){ try{ e.preventDefault(); e.stopImmediatePropagation(); }catch(_){} }
  function clean(){
    for (var i=17;i<=25;i++){
      var el = document.getElementById('feld'+i);
      if(!el) continue;
      try{
        // Remove any legacy .droptext nodes
        el.querySelectorAll('.droptext').forEach(function(n){ try{ n.remove(); }catch(_){}});
        // Block legacy drop handlers without replacing nodes (safer)
        el.addEventListener('dragover', kill, true);
        el.addEventListener('drop', kill, true);
      }catch(_){}
    }
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', clean); } else { clean(); }
})();
</script>
<script id="abschluss-logic-js">
(function(){
  'use strict';
  var $  = function(s, c){ return (c||document).querySelector(s); };
  var $$ = function(s, c){ return Array.from((c||document).querySelectorAll(s)); };

  function stripInteractivity(node){
    if(!node) return;
    $$('*', node).forEach(function(n){
      try{
        for (var i=n.attributes.length-1;i>=0;i--){
          var a = n.attributes[i]; if(!a) continue;
          if(/^on/i.test(a.name)) n.removeAttribute(a.name);
          if(a.name==='draggable' || a.name==='contenteditable' || a.name==='ondrop' || a.name==='ondragover'){
            n.removeAttribute(a.name);
          }
        }
        if (n.tagName==='INPUT' || n.tagName==='SELECT' || n.tagName==='TEXTAREA'){
          n.setAttribute('disabled','disabled');
        }
      }catch(_){}
    });
  }
  function removeEditorFrames(node){
    if(!node) return;
    var sels = ['.rahmen-overlay','.editor-rahmen','.bearbeitungs-rahmen','[data-editor-only]','[data-role="editor-only"]'];
    sels.forEach(function(sel){ try{ node.querySelectorAll(sel).forEach(function(n){ n.remove(); }); }catch(_){}});
  }

  window.renderAbschluss = function(){
    var wrap = document.querySelector('#abschluss-card .wrap');
    if(!wrap) return;
    var frontSrc = document.getElementById('karte-vorderseite');
    var backSrc  = document.getElementById('karte-rueckseite');
    if(!frontSrc || !backSrc) return;
    var front = frontSrc.cloneNode(true);
    var back  = backSrc.cloneNode(true);
    stripInteractivity(front); stripInteractivity(back);
    removeEditorFrames(front); removeEditorFrames(back);
    front.classList.add('side','front-side'); back.classList.add('side','back-side');
    wrap.innerHTML = ''; wrap.appendChild(front); wrap.appendChild(back);
    document.getElementById('abschluss-card').classList.remove('show-back');
  };

  window.setAbschlussZoom = function(level){
    var stage = document.getElementById('abschluss-stage');
    if(!stage) return;
    stage.classList.remove('zoom-100','zoom-150');
    stage.classList.add(level==='150' ? 'zoom-150' : 'zoom-100');
  };

  window.flipAbschluss = function(){
    var host = document.getElementById('abschluss-card');
    if(host) host.classList.toggle('show-back');
  };
})();</script><script id="abschluss-open-binder">
(function(){
  window.Warenkorb = window.Warenkorb || [];

  function getSelectedOption(){
    var el = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
    return el ? el.value : null;
  }
  function getPlantName(){
    // Priorität: genau das Element aus deinem Screenshot
    var el = document.querySelector('#feld1NameAnzeige');
    if (el){
      var v = (('value' in el) ? el.value : (el.textContent || el.innerText || '')).trim();
      if (v) return v;
    }
    // Weitere Kandidaten (Fallbacks)
    var pri = [
      '#feld1-name','#feld1','#name','#kartenname',
      '#karte-vorderseite [data-field="1"]',
      '#karte-vorderseite [data-name]',
      '#karte-vorderseite .feld-1',
      '#karte-vorderseite .name'
    ];
    for (var i=0;i<pri.length;i++){
      try{
        var e = document.querySelector(pri[i]);
        if(!e) continue;
        var val = (('value' in e) ? e.value : (e.textContent || e.innerText || '')).trim();
        if(val) return val;
      }catch(_){}
    }
    // Letzter Fallback: erster sichtbarer Textinput links
    var cols = document.querySelector('div.columns');
    var left = cols ? (Array.from(cols.children).filter(function(n){return n.tagName==='DIV';})[0] || cols) : document;
    var inputs = Array.from(left.querySelectorAll('input[type=\"text\"], input:not([type]), textarea'));
    for (var j=0;j<inputs.length;j++){
      var e2 = inputs[j];
      try{
        if (!e2 || !e2.offsetParent) continue;
        var vv = (e2.value||'').trim();
        if (vv && vv.length>=2) return vv;
      }catch(_){}
    }
    return 'Karte';
  }

  function addToCart(){
    var msg = document.getElementById('abschluss-cart-msg');
    if (msg){ msg.className=''; msg.textContent=''; }
    var opt = getSelectedOption();
    if (!opt){
      if (msg){ msg.className='err'; msg.textContent='Bitte eine Ausführung wählen.'; }
      return;
    }
    var qtyEl = document.getElementById('abschluss-qty');
    var qty = parseInt(qtyEl && qtyEl.value ? qtyEl.value : '1', 10);
    if (!(qty > 0)){ qty = 1; if (qtyEl) qtyEl.value = '1'; }

    var frontSrc = document.getElementById('karte-vorderseite');
    var backSrc  = document.getElementById('karte-rueckseite');
    var frontHTML = frontSrc ? frontSrc.outerHTML : '';
    var backHTML  = backSrc  ? backSrc.outerHTML  : '';

    var labelMap = {
      'laminat_oben':'loch oben',
      'laminat_unten':'überstand unten',
      'kein_laminat':'kein laminatüberstand',
      'steckspitze':'steckspitze'
    };
    var optionLabel = labelMap[opt] || opt;
    var pname = getPlantName();

    var item = {
      id: 'itm_'+Date.now(),
      time: new Date().toISOString(),
      qty: qty,
      option: opt,
      name: pname,
      frontHTML: frontHTML,
      backHTML: backHTML
    };
try {
  // Delegate to cart kernel if available
  var kernelAdd = window.__ppkCartKernelAdd || (window.__ppkCart && window.__ppkCart.add);
  var displayName = pname + ' (' + optionLabel + ')';
  var kernelItem = { id: item.id, name: displayName, price: 0, qty: qty, meta: { option: opt, time: item.time, frontHTML: frontHTML, backHTML: backHTML } };
  if (typeof kernelAdd === 'function') kernelAdd(kernelItem);
} catch(_) {}
// Keep legacy array in sync (optional)
window.Warenkorb.push(item);
var pnameMsg=(function(){var cnt=0;try{cnt=(window.getCart&&window.getCart().length)||(window.Warenkorb&&window.Warenkorb.length)||0;}catch(_){ } return qty+'× '+pname+' ('+optionLabel+') – Posten: '+cnt;})();
if (msg){ msg.className='ok'; msg.textContent = pnameMsg; }
try{ console.log('[Warenkorb]', item); }catch(_){ }
}

  function openAbschluss(){
    try{
      if (typeof renderAbschluss === 'function') { renderAbschluss(); }
      var cols = document.querySelector('div.columns');
      var panel = document.getElementById('abschluss-panel');
      if (cols)  cols.style.display = 'none';
      if (panel) panel.style.display = 'block';
      if (panel) panel.scrollIntoView({behavior:'smooth', block:'start'});
    }catch(_){}
  }
  function backToEdit(){
    try{
      var cols = document.querySelector('div.columns');
      var panel = document.getElementById('abschluss-panel');
      if (panel) panel.style.display = 'none';
      if (cols)  cols.style.display = '';
      var k = document.getElementById('kartenbereich') || document.getElementById('karte-vorderseite');
      if (k) k.scrollIntoView({behavior:'smooth', block:'start'});
    }catch(_){}
  }
  function ensureDefaultOption(){
  var r = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
  if(!r){ var first = document.querySelector('input[name="abschluss-ausfuehrung"]'); if(first) first.checked = true; }
}
function bind(){
    var openBtn = document.getElementById('btn-open-abschluss');
    if (openBtn && !openBtn._b){ openBtn.addEventListener('click', openAbschluss, true); openBtn._b=true; }
    var b100 = document.getElementById('btn-abschluss-zoom-100');
    var b150 = document.getElementById('btn-abschluss-zoom-150');
    var flip = document.getElementById('btn-abschluss-flip');
    if (b100 && !b100._b){ b100.addEventListener('click', function(e){ e.preventDefault(); setAbschlussZoom('100'); }, true); b100._b=true; }
    if (b150 && !b150._b){ b150.addEventListener('click', function(e){ e.preventDefault(); setAbschlussZoom('150'); }, true); b150._b=true; }
    if (flip && !flip._b){ flip.addEventListener('click', function(e){ e.preventDefault(); flipAbschluss(); }, true); flip._b=true; }
    var back = document.getElementById('btn-abschluss-back');
    if (back && !back._b){ back.addEventListener('click', backToEdit, true); back._b=true; }
    var add = document.getElementById('btn-abschluss-addcart');
    if (add && !add._b){ add.addEventListener('click', function(e){ e.preventDefault(); addToCart(); }, true); add._b=true; }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }
 ensureDefaultOption(); bind(); });
  } else {
    ensureDefaultOption(); bind();
  }
  window.addToCart = window.addToCart || addToCart;
})();</script><script id="abschluss-trigger-rebind">
(function(){
  function fallbackOpen(){
    try{
      if (typeof renderAbschluss === 'function') { renderAbschluss(); }
      var cols = document.querySelector('div.columns');
      var panel = document.getElementById('abschluss-panel');
      if (cols)  cols.style.display = 'none';
      if (panel) panel.style.display = 'block';
      if (panel) panel.scrollIntoView({behavior:'smooth', block:'start'});
    }catch(_){}
  }
  function bind(){
    var b = document.getElementById('btn-open-abschluss');
    if (!b || b._rbBound) return;
    b.addEventListener('click', function(e){
      e.preventDefault();
      if (typeof openAbschluss === 'function') { openAbschluss(); }
      else { fallbackOpen(); }
    }, true);
    b._rbBound = true;
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }
})();</script><script id="abschluss-cart-next-fix">
(function(){
  // Keep a single cart array
  window.Warenkorb = window.Warenkorb || [];

  function getSelectedOption(){
    var el = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
    return el ? el.value : null;
  }
  function getOptionLabel(val){
    var map = {'laminat_oben':'loch oben','laminat_unten':'überstand unten','kein_laminat':'kein laminatüberstand','steckspitze':'steckspitze'};
    return map[val] || (val || '');
  }
  function getPlantName(){
    var el = document.querySelector('#feld1NameAnzeige');
    if (el){
      var v = (('value' in el) ? el.value : (el.textContent || el.innerText || '')).trim();
      if (v) return v;
    }
    return 'Karte';
  }
  function renderList(){
    var box = document.getElementById('abschluss-cart-list');
    if (!box) return;
    if (!window.Warenkorb.length){ box.innerHTML=''; return; }
    var html = '<ul style="margin:8px 0 0 0; padding-left:18px">';
    for (var i=0;i<Warenkorb.length;i++){
      var it = Warenkorb[i];
      html += '<li>'+ it.qty +'× '+ (it.name||'Karte') +' ('+ getOptionLabel(it.option) +')</li>';
    }
    html += '</ul>';
    box.innerHTML = html;
  }
  // Public addToCart used by onclick
  if (typeof window.addToCart !== 'function'){
    window.addToCart = function(){
      var msg = document.getElementById('abschluss-cart-msg');
      if (msg){ msg.className=''; msg.textContent=''; }
      var opt = getSelectedOption();
      if (!opt){
        if (msg){ msg.className='err'; msg.textContent='Bitte eine Ausführung wählen.'; }
        return;
      }
      var qtyEl = document.getElementById('abschluss-qty');
      var qty = parseInt(qtyEl && qtyEl.value ? qtyEl.value : '1', 10);
      if (!(qty > 0)){ qty = 1; if (qtyEl) qtyEl.value = '1'; }
      var frontSrc = document.getElementById('karte-vorderseite');
      var backSrc  = document.getElementById('karte-rueckseite');
      var item = {
        id: 'itm_'+Date.now(),
        time: new Date().toISOString(),
        qty: qty,
        option: opt,
        name: getPlantName(),
        frontHTML: frontSrc ? frontSrc.outerHTML : '',
        backHTML:  backSrc  ? backSrc.outerHTML  : ''
      };
      window.Warenkorb.push(item);
      if (msg){ msg.className='ok'; msg.textContent = qty+'× '+item.name+' ('+getOptionLabel(opt)+') – Posten: '+window.Warenkorb.length; }
      renderList();
    };
  }

  // "Nächste Karte": zurück zur Bearbeitung, ohne Datenverlust, Fokus nach oben
  if (typeof window.goNextCard !== 'function'){
    window.goNextCard = function(){
      // nur Umschalten zurück; tatsächliches Reset folgt als eigener Schritt
      var cols = document.querySelector('div.columns');
      var panel = document.getElementById('abschluss-panel');
      if (panel) panel.style.display = 'none';
      if (cols)  cols.style.display = '';
      var k = document.getElementById('kartenbereich') || document.getElementById('karte-vorderseite');
      if (k) k.scrollIntoView({behavior:'smooth', block:'start'});
    };
  }

  // "Bestellung aufgeben": einfache Anzeige der Posten unter der Meldung
  if (typeof window.showOrder !== 'function'){
    window.showOrder = function(){
      renderList();
      var box = document.getElementById('abschluss-cart-list');
      if (box) box.scrollIntoView({behavior:'smooth', block:'start'});
    };
  }

  // Ensure one radio is selected by default
  (function ensureDefaultOption(){
    var r = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
    if (!r){ var first = document.querySelector('input[name="abschluss-ausfuehrung"]'); if (first) first.checked = true; }
  })();

  // Render list on load if items exist
  renderList();
})();</script><script id="abschluss-cart-next-reset-v2">
(function(){
  // --- helpers ---
  function $(sel){ return document.querySelector(sel); }
  function text(el){
    if(!el) return "";
    if ("value" in el) return (el.value||"").trim();
    return (el.textContent||el.innerText||"").trim();
  }
  function ensureDefaultOption(){
    var chk = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
    if(!chk){
      var first = document.querySelector('input[name="abschluss-ausfuehrung"]');
      if(first) first.checked = true;
    }
  }
  function getOptionValue(){
    var el = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
    return el ? el.value : null;
  }
  function getOptionLabel(val){
    var map = {
      "laminat_oben":"loch oben",
      "laminat_unten":"überstand unten",
      "kein_laminat":"kein laminatüberstand",
      "steckspitze":"steckspitze"
    };
    return map[val] || (val||"");
  }
  function getPlantName(){
    // Priorität: exakt dein Feld 1 Anzeigeknoten
    var el = document.querySelector('#feld1NameAnzeige');
    var v = text(el);
    if(v) return v;
    return "Karte";
  }
  
  function clearStickerOverlays(){
    // Leert nur Overlay-/Sticker-Layer innerhalb der Kartenbereiche (keine SVG/Koordinatenänderung)
    var hosts = [
      document.getElementById('karte-vorderseite'),
      document.getElementById('karte-rueckseite')
    ].filter(Boolean);
    var sels = [
      '.karte-overlay','.overlay','.sticker-slots','.stickers',
      '[data-layer="overlay"]','[data-layer="stickers"]','[id$="_overlay"]','[id*="overlay"]','[id*="sticker"]'
    ];
    hosts.forEach(function(host){
      sels.forEach(function(sel){
        try{
          host.querySelectorAll(sel).forEach(function(layer){
            // Nur dynamischen Inhalt leeren
            while(layer.firstChild){ layer.removeChild(layer.firstChild); }
          });
        }catch(_){}
      });
    });
  }
  function clearLeftSelections(){
    // Alle Checkboxen/Optionen in der linken Spalte zurücksetzen
    var cols = document.querySelector('div.columns');
    var left = cols ? (Array.from(cols.children).filter(function(n){return n.tagName==='DIV';})[0] || cols) : document;
    // Uncheck checkboxes/radios (nur Editorbereich, nicht Abschluss)
    left.querySelectorAll('input[type="checkbox"], input[type="radio"]').forEach(function(inp){
      try{ inp.checked = false; }catch(_){}
    });
    // Entferne evtl. Zustandsklassen
    left.querySelectorAll('.selected,.aktiv,.active').forEach(function(n){
      try{ n.classList.remove('selected','aktiv','active'); }catch(_){}
    });
  }

  function renderList(){
    var box = $('#abschluss-cart-list');
    if(!box) return;
    if(!Array.isArray(window.Warenkorb) || !window.Warenkorb.length){ box.innerHTML=""; return; }
    var out = '<ul style="margin:8px 0 0 0; padding-left:18px">';
    for(var i=0;i<window.Warenkorb.length;i++){
      var it = window.Warenkorb[i];
      out += '<li>'+ it.qty +'× '+ (it.name||'Karte') +' ('+ getOptionLabel(it.option) +')</li>';
    }
    out += '</ul>';
    box.innerHTML = out;
  }

  // --- public API ---
  window.Warenkorb = window.Warenkorb || [];
  // Laden evtl. vorhandener Warenkorb-Daten (Persistenz)
  try{
    var _saved = localStorage.getItem('warenkorb');
    if (_saved){ 
      var arr = JSON.parse(_saved); 
      if (Array.isArray(arr)) window.Warenkorb = arr; 
    }
  }catch(_){}

  var __adding = false;
  window.addToCart = function(){
    if(__adding) return; __adding = true; setTimeout(function(){ __adding = false; }, 350);
    ensureDefaultOption();
    var msg = $('#abschluss-cart-msg');
    if (msg){ msg.className=''; msg.textContent=''; }
    var opt = getOptionValue();
    if(!opt){
      if (msg){ msg.className='err'; msg.textContent='Bitte eine Ausführung wählen.'; }
      return;
    }
    var qtyEl = $('#abschluss-qty');
    var qty = parseInt(qtyEl && qtyEl.value ? qtyEl.value : '1', 10);
    if(!(qty>0)){ qty = 1; if(qtyEl) qtyEl.value = '1'; }

    var frontSrc = document.getElementById('karte-vorderseite');
    var backSrc  = document.getElementById('karte-rueckseite');

    var item = {
      id: 'itm_'+Date.now(),
      time: new Date().toISOString(),
      qty: qty,
      option: opt,
      name: getPlantName(),
      frontHTML: frontSrc ? frontSrc.outerHTML : '',
      backHTML:  backSrc  ? backSrc.outerHTML  : ''
    };
    /*__DEDUPE__*/
    var mergedQty = null;
    for (var i=0;i<window.Warenkorb.length;i++){
      var it = window.Warenkorb[i];
      if ((it.name||'') === item.name && (it.option||'') === item.option){
        it.qty += qty; mergedQty = it.qty; item = it; break;
      }
    }
    if (mergedQty === null){ window.Warenkorb.push(item); }
    try{ localStorage.setItem('warenkorb', JSON.stringify(window.Warenkorb)); }catch(_){ }
    if (msg){
  msg.className='ok';
  var posQty = item && item.qty ? item.qty : qty;
  msg.textContent = posQty+'× '+item.name+' ('+getOptionLabel(item.option)+') – Posten: '+window.Warenkorb.length;
}
    renderList();
  };

  
  function clearSearchFields(){
    var sels = [
      '#pflanzensuche','#pflanzensuchfeld','#pflanzenSuche','#suchfeld','#suche','#search',
      'input[type="search"]','input[placeholder*="such"]','input[name*="such"]'
    ];
    var cleared = false;
    for (var i=0;i<sels.length;i++){
      try{
        var el = document.querySelector(sels[i]);
        if(el){
          if ('value' in el) el.value = '';
          if (el.removeAttribute) el.removeAttribute('data-value');
          cleared = true;
        }
      }catch(_){}
    }
    return cleared;
  }
  function clearLeftTextFields(){
    var cols = document.querySelector('div.columns');
    var left = cols ? (Array.from(cols.children).filter(function(n){return n.tagName==='DIV';})[0] || cols) : document;
    var nodes = Array.from(left.querySelectorAll('input[type="text"], input:not([type]), textarea'));
    nodes.forEach(function(el){
      try{
        if (el && el.offsetParent !== null){ el.value = ''; }
      }catch(_){}
    });
  }

  window.resetEditorForNext = function(){
    // Nur die ausdrücklich freigegebenen Felder leeren (Einzelschritt, sicher)
    var nameEl = document.querySelector('#feld1NameAnzeige');
    var spruchEl = document.querySelector('#spruchAnzeige');
    var smileyEl = document.querySelector('#symbolAnzeige');
    if(nameEl){ if("value" in nameEl) nameEl.value=""; nameEl.textContent=""; nameEl.removeAttribute('data-value'); }
    if(spruchEl){ if("value" in spruchEl) spruchEl.value=""; spruchEl.textContent=""; spruchEl.removeAttribute('data-value'); }
    if(smileyEl){ if("value" in smileyEl) smileyEl.value=""; smileyEl.textContent=""; smileyEl.removeAttribute('data-value'); }
  };

  window.goNextCard = function(){
    try{ window.resetEditorForNext(); }catch(_){}
    // Zurück zur Bearbeitung
    var cols = document.querySelector('div.columns');
    var panel = document.getElementById('abschluss-panel');
    if (panel) panel.style.display = 'none';
    if (cols)  cols.style.display = '';
    var k = document.getElementById('kartenbereich') || document.getElementById('karte-vorderseite');
    if (k) k.scrollIntoView({behavior:'smooth', block:'start'});
  };

  window.showOrder = function(){
    renderList();
    var box = document.getElementById('abschluss-cart-list');
    if (box) box.scrollIntoView({behavior:'smooth', block:'start'});
  };

  // --- binder ---
  function bind(){
    ensureDefaultOption();
var bNext = document.getElementById('btn-abschluss-next');
    if(bNext && !bNext._b){ bNext.addEventListener('click', function(e){ e.preventDefault(); goNextCard(); }, true); bNext._b=true; }
    var bCheckout = document.getElementById('btn-abschluss-checkout');
    if(bCheckout && !bCheckout._b){ bCheckout.addEventListener('click', function(e){ e.preventDefault(); showOrder(); }, true); bCheckout._b=true; }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind);
  } else {
    bind();
  }

  // Initiale Liste (falls schon Items vorhanden)
  renderList();
})();</script>
<script id="next-card-startlayout-override">
(function(){
  'use strict';

  function $(sel, root){ return (root||document).querySelector(sel); }
  function $all(sel, root){ return Array.from((root||document).querySelectorAll(sel)); }

  function clearNode(el){
    if(!el) return;
    while(el.firstChild){ el.removeChild(el.firstChild); }
    if ('value' in el) try{ el.value = ''; }catch(_){}
    try{ el.textContent = ''; }catch(_){}
    try{ el.removeAttribute('data-value'); }catch(_){}
  }

  function clearLeftPanel(){
    try{
      const cols = document.querySelector('div.columns');
      const left = cols ? (Array.from(cols.children).filter(n=>n.tagName==='DIV')[0] || cols) : document;
      // text inputs & textareas
      $all('input[type="text"], input:not([type]), textarea', left)
        .filter(el => el.offsetParent !== null)
        .forEach(el => { try{ el.value=''; }catch(_){} });
      // checkboxes / radios
      $all('input[type="checkbox"], input[type="radio"]', left)
        .forEach(el => { try{ el.checked = false; }catch(_){} });
      // selected/active classes
      $all('.selected,.aktiv,.active', left)
        .forEach(n => { try{ n.classList.remove('selected','aktiv','active'); }catch(_){} });
    }catch(_){}
  }

  function clearSearch(){
    try{
      const sels = [
        '#pflanzensuche','#pflanzensuchfeld','#pflanzenSuche','#suchfeld','#suche','#search',
        'input[type="search"]','input[placeholder*="such"]','input[name*="such"]'
      ];
      for (const s of sels){
        const el = document.querySelector(s);
        if (el){
          if ('value' in el) el.value = '';
          el.removeAttribute && el.removeAttribute('data-value');
        }
      }
      const toast = document.getElementById('nohit-toast'); if (toast){ toast.style.display='none'; toast.textContent=''; }
      const nameSpan = document.getElementById('rb-plantname'); if (nameSpan){ nameSpan.textContent='–'; }
    }catch(_){}
  }

  function clearStickerLayers(){
    const hosts = ['karte-vorderseite','karte-rueckseite']
      .map(id => document.getElementById(id))
      .filter(Boolean);
    const sels = [
      '.karte-overlay','.overlay','.sticker-slots','.stickers',
      '[data-layer="overlay"]','[data-layer="stickers"]','[id$="_overlay"]','[id*="overlay"]','[id*="sticker"]'
    ];
    for (const host of hosts){
      for (const sel of sels){
        try{
          host.querySelectorAll(sel).forEach(layer => {
            while(layer.firstChild){ layer.removeChild(layer.firstChild); }
          });
        }catch(_){}
      }
    }
  }

  function clearSlots(){
    // Sticker-Slots (Front 2–5, Back 8–16)
    const ranges = [[2,5],[8,16],[17,25]];
    for(const [a,b] of ranges){
      for(let i=a;i<=b;i++){
        const el = document.getElementById('feld'+i);
        if(!el) continue;
        // remove .droptext and any children
        try{
          el.querySelectorAll('.droptext').forEach(n=>n.remove());
        }catch(_){}
        clearNode(el);
      }
    }
    // explizite Anzeigen-Knoten
    clearNode(document.getElementById('feld1NameAnzeige'));
    clearNode(document.getElementById('spruchAnzeige'));
    clearNode(document.getElementById('symbolAnzeige'));
  }

  function clearHints(){
    try{ $all('.slot-hint').forEach(n=>n.remove()); }catch(_){}
    try{
      $('#hint-layer') && clearNode($('#hint-layer'));
      $all('.hint-raise').forEach(n=>n.classList.remove('hint-raise'));
    }catch(_){}
  }

  function resetPreviewState(){
    try{
      // Zoom auf 100%
      const root = document.documentElement;
      const body = document.body;
      root.style.setProperty('--zoom', 1);
      body.classList.remove('zoom-150');
      body.classList.add('zoom-100');
      // Vorderseite oben
      const kb = document.getElementById('kartenbereich');
      if (kb){
        kb.classList.add('front-top');
        kb.classList.remove('back-top','tight');
      }
      // Rückseiten-Overlap neutralisieren
      const back = document.getElementById('karte-rueckseite');
      if (back) back.style.marginLeft = '';
    }catch(_){}
    // Abschluss-spezifische UI zurück
    try{
      const stage = document.getElementById('abschluss-stage');
      if (stage){
        stage.classList.remove('zoom-150'); stage.classList.add('zoom-100');
      }
      const card = document.getElementById('abschluss-card');
      if (card) card.classList.remove('show-back');
    }catch(_){}
  }

  function resetToStartLayout(){
    // Reihenfolge: visuelle Hinweise -> Inhalte -> linke Spalte -> Suche -> Sticker-Layer
    clearHints();
    clearSlots();
    clearLeftPanel();
    clearSearch();
    clearStickerLayers();
  }

  // Override goNextCard to *always* reset to start layout before returning to the editor
  window.goNextCard = function(){
    try{ resetToStartLayout(); }catch(_){}
    try{
      const cols = document.querySelector('div.columns');
      const panel = document.getElementById('abschluss-panel');
      if (panel) panel.style.display = 'none';
      if (cols)  cols.style.display = '';
      resetPreviewState();
      const k = document.getElementById('kartenbereich') || document.getElementById('karte-vorderseite');
      if (k) k.scrollIntoView({behavior:'smooth', block:'start'});
      // ggf. Layout neu rechnen
      if (typeof window.updateOverlap === 'function') { try{ window.updateOverlap(); }catch(_){ } }
    }catch(_){}
  };

  // ensure the button calls our override (existing listener calls goNextCard dynamically)
  // nothing else needed; but if a handler wrote a stale reference, bind an extra safety listener
  (function ensureBtn(){
    const bNext = document.getElementById('btn-abschluss-next');
    if(!bNext || bNext.__rbStartResetBound) return;
    bNext.addEventListener('click', function(ev){
      // passive safety: let our override handle it
      // do not preventDefault here to not double-handle if other code expects default suppression
    }, true);
    bNext.__rbStartResetBound = true;
  })();

})();
</script>
<script id="ppk-cart-kernel-v3">
(() => {
  'use strict';
  const STORAGE_KEY_V2 = 'ppk_cart_v2';
  const STORAGE_KEY_V1 = 'ppk_cart_v1';
  const CLICK_DEDUP_MS = 350;

  let lastAdd = { id: null, t: 0 };

  const state = { items: loadCart() };

  function safeParse(json, fallback){ try { return JSON.parse(json); } catch(_) { return fallback; } }
  function loadCart(){
    let items = safeParse(localStorage.getItem(STORAGE_KEY_V2), null);
    if (!Array.isArray(items)){
      const legacy = safeParse(localStorage.getItem(STORAGE_KEY_V1), []);
      items = Array.isArray(legacy) ? legacy : [];
      try { localStorage.setItem(STORAGE_KEY_V2, JSON.stringify(items)); } catch(_){}
    }
    return items;
  }
  function saveCart(){
    try { localStorage.setItem(STORAGE_KEY_V2, JSON.stringify(state.items)); } catch(_){}
    updateBadge();
    document.dispatchEvent(new CustomEvent('ppk:cart:updated', { detail: { items: getCart(), total: getTotal() } }));
    renderCartList();
  }
  function coerceItem(item){
    if (!item || (!item.id && !item.name)) return null;
    const id = String(item.id || item.name || ('item-' + Math.random().toString(36).slice(2)));
    const qty = Math.max(1, Number(item.qty || 1) || 1);
    const price = Number(item.price || 0) || 0;
    const name = item.name ? String(item.name) : id;
    const meta = (item.meta && typeof item.meta === 'object') ? item.meta : {};
    return { id, name, price, qty, meta };
  }
  
  // --- Limit helpers: based on baseName (case-insensitive) ---
  function normalizeNameForLimit(it){
    try{
      let base = (it && it.meta && it.meta.baseName) ? String(it.meta.baseName) : '';
      if (!base && it && it.name) {
        base = String(it.name).replace(/\s*\(.*?\)\s*$/, ''); // strip " (option)"
      }
      return base.trim().toLowerCase();
    }catch(_){ return ''; }
  }
  function uniqueNameCount(items){
    const s = new Set();
    try {
      for (const it of (items||[])) {
        const key = normalizeNameForLimit(it);
        if (key) s.add(key);
      }
    } catch(_) {}
    return s.size;
  }
function buildItemFromPage(){
    // Legacy no-arg fallback: derive data from the Abschluss-Panel
    try{
      const r = document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
      const opt = r ? r.value : 'standard';
      const qtyEl = document.getElementById('abschluss-qty');
      const qty = Math.max(1, parseInt(qtyEl && qtyEl.value ? qtyEl.value : '1', 10) || 1);
      // Plant name
      let pname = '';
      const nameSel = ['#feld1NameAnzeige', '#rb-plantname', '[data-field="1"]', '#karte-vorderseite .feld-1', '#karte-vorderseite .name'];
      for (const s of nameSel){
        const el = document.querySelector(s);
        if (!el) continue;
        const val = (('value' in el) ? el.value : (el.textContent || el.innerText || '')).trim();
        if (val){ pname = val; break; }
      }
      if (!pname) pname = 'Karte';
      const labelMap = { 'laminat_oben':'loch oben', 'laminat_unten':'überstand unten', 'kein_laminat':'kein laminatüberstand', 'steckspitze':'steckspitze' };
      const optionLabel = labelMap[opt] || opt;
      // Optional snapshots (if present)
      const frontSrc = document.getElementById('karte-vorderseite');
      const backSrc  = document.getElementById('karte-rueckseite');
      const frontHTML = frontSrc ? frontSrc.outerHTML : '';
      const backHTML  = backSrc  ? backSrc.outerHTML  : '';
      return {
        id: 'itm_'+Date.now(),
        name: pname + ' (' + optionLabel + ')',
        price: 0,
        qty,
        meta: { option: opt, time: new Date().toISOString(), frontHTML, backHTML }
      };
    }catch(_){ return null; }
  }
  function addToCart(rawItem, opts){
    // Accept legacy no-arg usage
    if (typeof rawItem === 'undefined' || rawItem === null){
      rawItem = buildItemFromPage();
      // Update message area for legacy UI
      try{
        const msg = document.getElementById('abschluss-cart-msg');
        if (msg){
          if (rawItem){ msg.className='ok'; msg.textContent = rawItem.qty + '× ' + rawItem.name; }
          else { msg.className='err'; msg.textContent = 'Artikel konnte nicht ermittelt werden.'; }
        }
      }catch(_){}
      if (!rawItem) return;
    }
    const item = coerceItem(rawItem);
    if (!item) { console.warn('addToCart: invalid item', rawItem); return; }
    
    // Enforce: max 10 distinct names (by baseName). Same name can have higher qty.
    try {
      const key = normalizeNameForLimit(item);
      const exists = state.items.some(x => normalizeNameForLimit(x) === key);
      if (!exists) {
        const cnt = uniqueNameCount(state.items);
        if (cnt >= 10) {
          const msg = document.getElementById('abschluss-cart-msg');
          if (msg){ msg.className='err'; msg.textContent = 'Maximal 10 verschiedene Karten im Warenkorb. Bitte zuerst eine Bestellung abschließen oder eine Karte entfernen.'; }
          return;
        }
      }
    } catch(_){}
const now = Date.now();
    if (lastAdd.id === item.id && (now - lastAdd.t) < CLICK_DEDUP_MS) return;
    lastAdd = { id: item.id, t: now };
    const i = state.items.findIndex(x => x.id === item.id);
    if (i >= 0){
      state.items[i].qty = Math.max(1, Number(state.items[i].qty || 1) + Number(item.qty || 1));
      if (item.name && !state.items[i].name) state.items[i].name = item.name;
      if (item.price) state.items[i].price = Number(item.price);
      if (item.meta && Object.keys(item.meta).length){
        state.items[i].meta = Object.assign({}, state.items[i].meta || {}, item.meta);
      }
    } else {
      state.items.push(item);
    }
    saveCart();
  }
  function removeFromCart(id){
    if (!id) return;
    state.items = state.items.filter(x => x.id !== id);
    saveCart();
  }
  function setQty(id, qty){
    qty = Math.max(0, Number(qty) || 0);
    const it = state.items.find(x => x.id === id);
    if (!it) return;
    if (qty === 0){ removeFromCart(id); }
    else { it.qty = qty; saveCart(); }
  }
  function clearCart(){ state.items = []; saveCart(); }
  function getCart(){ return state.items.map(i => ({...i})); }
  function getTotal(){ const sum = state.items.reduce((n, i) => n + (Number(i.price || 0) * Number(i.qty || 1)), 0); return Math.round(sum * 100) / 100; }
  function updateBadge(){
    const count = state.items.reduce((n, i) => n + Number(i.qty || 1), 0);
    const el = document.getElementById('cartCount') || document.querySelector('[data-cart-count]');
    if (el) el.textContent = String(count);
  }
  function renderCartList(){
    const host = document.getElementById('abschluss-cart-list');
    if (!host) return;
    const ul = document.createElement('ul');
    ul.style.listStyle = 'none';
    ul.style.paddingLeft = '0';
    for (const it of state.items){
      const li = document.createElement('li');
      li.style.display = 'grid';
      li.style.gridTemplateColumns = '1fr auto auto auto auto';
      li.style.alignItems = 'center';
      li.style.gap = '8px';
      li.style.padding = '6px 0';
      li.dataset.id = it.id;
      const name = document.createElement('span');
      name.textContent = `${escapeHtml(it.name)} ×`;
      const qty = document.createElement('input');
      qty.type = 'number'; qty.min = '1'; qty.step = '1';
      qty.value = String(it.qty||1); qty.setAttribute('data-set-qty',''); qty.dataset.id = it.id;
      qty.style.width = '64px';
      const preview = document.createElement('button');
      preview.textContent = 'Ansehen';
      preview.setAttribute('data-view-cart-item',''); preview.dataset.id = it.id;
      const edit = document.createElement('button');
      edit.textContent = 'Bearbeiten';
      edit.setAttribute('data-edit-cart-item',''); edit.dataset.id = it.id;
      const rem = document.createElement('button');
      rem.textContent = 'Entfernen'; rem.setAttribute('data-remove-from-cart',''); rem.dataset.id = it.id;
      const price = document.createElement('strong');
      price.style.justifySelf = 'end';
      price.textContent = formatPrice((it.price||0) * (it.qty||1));
      li.appendChild(name); li.appendChild(qty); li.appendChild(preview); li.appendChild(edit); li.appendChild(rem); li.appendChild(price);
      ul.appendChild(li);
    }
    host.replaceChildren(ul);
    const totalEl = document.getElementById('cartTotal');
    if (totalEl) totalEl.textContent = formatPrice(getTotal());
  }
  function formatPrice(v){ if (isNaN(v)) return '—'; return new Intl.NumberFormat(undefined, { style: 'currency', currency: 'EUR' }).format(Number(v)); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  // Delegation for data-* controls
  document.addEventListener('click', (e) => {
    const addBtn = e.target.closest('[data-add-to-cart]');
    if (addBtn){
      e.preventDefault();
      let item = null;
      const payload = addBtn.getAttribute('data-cart-payload');
      if (payload){ item = safeParse(payload, null); }
      if (!item){
        item = {
          id: addBtn.dataset.id || addBtn.id || ('item-' + Math.random().toString(36).slice(2)),
          name: addBtn.dataset.name || addBtn.textContent.trim(),
          price: Number(addBtn.dataset.price) || 0,
          qty: Number(addBtn.dataset.qty) || 1,
        };
      }
      addToCart(item);
      return;
    }
    const remBtn = e.target.closest('[data-remove-from-cart]');
    if (remBtn){ e.preventDefault(); const id = remBtn.dataset.id || remBtn.getAttribute('data-remove-from-cart'); if (id) removeFromCart(id); return; }
    const clrBtn = e.target.closest('[data-clear-cart]');
    if (clrBtn){ e.preventDefault(); clearCart(); return; }
  }, true);
  document.addEventListener('change', (e) => {
    const qtyInput = e.target.closest('[data-set-qty]');
    if (qtyInput){ const id = qtyInput.dataset.id; const qty = qtyInput.value; if (id) setQty(id, qty); }
  }, true);

  // Expose kernel safely
  window.__ppkCartKernelAdd = addToCart;
  window.__ppkCart = { add: addToCart, remove: removeFromCart, clear: clearCart, setQty, get: getCart, total: getTotal };

  // Legacy-compatible globals
  window.addToCart = addToCart;
  window.removeFromCart = removeFromCart;
  window.getCart = getCart;
  window.clearCart = clearCart;
  window.setCartQty = setQty;
  window.getCartTotal = getTotal;
  window.getCartItems = getCart;

  document.addEventListener('DOMContentLoaded', () => { updateBadge(); renderCartList(); });
})();
</script>
<script id="cart-ui-extras">
(function(){
  'use strict';
  // Open cart from top toolbar
  document.addEventListener('click', function(e){
    const btn = e.target.closest('#btn-open-cart, #btn-open-cart-top');
    if (!btn) return;
    e.preventDefault();
    try{
      if (typeof window.renderAbschluss === 'function') window.renderAbschluss();
      const cols = document.querySelector('div.columns');
      const panel = document.getElementById('abschluss-panel');
      if (cols)  cols.style.display = 'none';
      if (panel) panel.style.display = 'block';
      const target = document.getElementById('cartList') || document.getElementById('abschluss-cart-list') || panel;
      if (target) target.scrollIntoView({behavior:'smooth', block:'start'});
    }catch(_){}
  }, true);

  // Copy cart link (URL with hash) for later restore
  function cartToHash(){
    try{
      const items = (window.getCart && window.getCart()) || [];
      const payload = { v: 1, items };
      const s = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
      return '#cart=' + s;
    }catch(_){ return ''; }
  }
  function applyCartFromHash(){
    try{
      const h = location.hash || '';
      const m = h.match(/^#cart=([A-Za-z0-9+/=]+)$/);
      if (!m) return false;
      const json = decodeURIComponent(escape(atob(m[1])));
      const payload = JSON.parse(json);
      if (!payload || !Array.isArray(payload.items)) return false;
      // Replace current cart
      if (window.clearCart) window.clearCart();
      if (window.__ppkCartKernelAdd){
        for (const item of payload.items){ window.__ppkCartKernelAdd(item); }
      } else if (window.addToCart){
        for (const item of payload.items){ window.addToCart(item); }
      }
      return true;
    }catch(_){ return false; }
  }
  document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

    // Try to restore from hash once
    applyCartFromHash();
    // Bind copy link button
        const copyBtn = document.getElementById('btn-cart-copylink');
    if (copyBtn && !copyBtn._b){
      copyBtn.addEventListener('click', function(e){
        e.preventDefault();
        const hash = cartToHash();
        const url  = location.origin + location.pathname + hash;

        function showCartMsg(){
          try{
            const m = document.getElementById('abschluss-cart-msg');
            if (m){
              m.dataset.name = 'ok';
              m.textContent  = 'Bestelllink kopiert.';
            }
          }catch(_){}
        }

        function fallbackCopy(text){
          try{
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.setAttribute('readonly','readonly');
            ta.style.position = 'fixed';
            ta.style.opacity  = '0';
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
          }catch(_){}
        }

        if (navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(url).then(()=>{
            showCartMsg();
          }).catch(()=>{
            fallbackCopy(url);
            showCartMsg();
          });
        } else {
          fallbackCopy(url);
          showCartMsg();
        }
      }, true);
      copyBtn._b = true;
    }

    }
    const clr = document.getElementById('btn-cart-clear');
    if (clr && !clr._b){
      clr.addEventListener('click', function(){ try{ window.clearCart && window.clearCart(); }catch(_){} }, true);
      clr._b = true;
    }
  });
})();
</script>
<script id="flip-fallback-robust">
(function(){
  'use strict';
  function toggleFrontBackForce(){
    var kb = document.getElementById('kartenbereich');
    if (!kb) return;
    var frontOnTop = kb.classList.contains('front-top');
    // If neither present, assume front on top as baseline.
    if (!frontOnTop && !kb.classList.contains('back-top')) frontOnTop = true;
    frontOnTop = !frontOnTop;
    kb.classList.toggle('front-top', frontOnTop);
    kb.classList.toggle('back-top', !frontOnTop);
    // housekeeping
    try{
      document.getElementById('karte-vorderseite')?.classList.remove('hint-raise');
      document.getElementById('karte-rueckseite')?.classList.remove('hint-raise');
      document.querySelectorAll('#karte-vorderseite .slot-hint').forEach(function(n){ n.remove(); });
    }catch(_){}
  }
  // Expose globally for debugging
  window.toggleFrontBackForce = toggleFrontBackForce;
  // Ensure both buttons trigger flip, even if original bindings are gone
  document.addEventListener('click', function(e){
    var btn1 = e.target.closest('#btn-toggle-frontback');
    if (btn1){
      e.preventDefault();
      toggleFrontBackForce();
      return;
    }
    var btn2 = e.target.closest('#btn-abschluss-flip');
    if (btn2){
      e.preventDefault();
      if (typeof window.flipAbschluss === 'function') {
        try { window.flipAbschluss(); return; } catch(_){}
      }
      // Fallback: try to flip via class on abschluss-card directly
      var card = document.getElementById('abschluss-card');
      if (card) card.classList.toggle('show-back');
    }
  }, true);
})();
</script>
<script id="cart-item-viewer">
(function(){
  'use strict';
  function stripScripts(html){
    try{
      const tmp = document.createElement('div');
      tmp.innerHTML = html || '';
      // Remove scripts
      tmp.querySelectorAll('script').forEach(s => s.remove());
      // Deactivate interactivity but KEEP elements (slots/text)
      tmp.querySelectorAll('*').forEach(n => {
        try{
          n.removeAttribute && n.removeAttribute('draggable');
          n.removeAttribute && n.removeAttribute('contenteditable');
          for (const attr of Array.from(n.attributes)){
            if (/^on/i.test(attr.name)) n.removeAttribute(attr.name);
          }
          if (n.style){ n.style.pointerEvents = 'none'; n.style.userSelect = 'none'; }
        }catch(_){}
      });
      return tmp;
    }catch(_){
      const div = document.createElement('div');
      return div;
    }
  }
  function renderSnapshot(frontHTML, backHTML){
    const stage = document.getElementById('abschluss-stage');
    const card  = document.getElementById('abschluss-card');
    if (!stage || !card) return;
    const wrap = card.querySelector('.wrap') || card;
    const front = stripScripts(frontHTML);
    const back  = stripScripts(backHTML);
    const f = (front && front.firstElementChild) ? front.firstElementChild : document.createElement('div');
    const b = (back  && back.firstElementChild)  ? back.firstElementChild  : document.createElement('div');
    f.classList.add('side','front-side'); b.classList.add('side','back-side');
    wrap.innerHTML = ''; wrap.appendChild(f); wrap.appendChild(b);
    card.classList.remove('show-back');
    try{
      wrap.querySelectorAll('*').forEach(n => { n.style.pointerEvents = 'none'; n.style.userSelect='none'; });
    }catch(_){}
    // open panel if hidden
    try{
      const cols = document.querySelector('div.columns');
      const panel = document.getElementById('abschluss-panel');
      if (cols)  cols.style.display = 'none';
      if (panel) panel.style.display = 'block';
    }catch(_){}
    stage.scrollIntoView({behavior:'smooth', block:'start'});
  }
  function viewCartItemById(id){
    try{
      const items = (window.getCart && window.getCart()) || [];
      const it = items.find(x => x && String(x.id) === String(id));
      if (!it){ return; }
      const meta = it.meta || {};
      if (meta.frontHTML || meta.backHTML){
        renderSnapshot(meta.frontHTML||'', meta.backHTML||'');
        return;
      }
      if (typeof window.renderAbschluss === 'function') window.renderAbschluss();
    }catch(_){}
  }
  document.addEventListener('click', function(e){
    const btn = e.target.closest('[data-view-cart-item]');
    if (!btn) return;
    e.preventDefault();
    const id = btn.dataset.id || btn.getAttribute('data-view-cart-item');
    if (!id) return;
    viewCartItemById(id);
  }, true);
})();
</script>
<script id="cart-export-import">
(function(){
  'use strict';

  function getCartSafe(){
    try { return (window.getCart && window.getCart()) || []; } catch(_){ return []; }
  }
  function distinctNameCount(items){
    const set = new Set();
    try {
      for (const it of (items||[])){
        const base = (it && it.meta && it.meta.baseName) ? String(it.meta.baseName) : String(it.name||'').replace(/\s*\(.*?\)\s*$/, '');
        if (base.trim()) set.add(base.trim().toLowerCase());
      }
    } catch(_){}
    return set.size;
  }
  function distinctNamesText(items){
    const n = distinctNameCount(items);
    return n===1 ? '1 verschiedene Karte' : `${n} verschiedene Karten`;
  }

  // --- EXPORT ---
  function exportCart(){
    const items = getCartSafe();
    const payload = {
      schemaVersion: 1,
      createdAt: new Date().toISOString(),
      itemCount: items.length,
      distinctNames: distinctNameCount(items),
      items
    };
    const data = JSON.stringify(payload, null, 2);
    const blob = new Blob([data], {type:'application/json'});
    const ts = new Date();
    const pad = n => String(n).padStart(2, '0');
    const fname = `warenkorb_${ts.getFullYear()}${pad(ts.getMonth()+1)}${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}.json`;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = fname;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 100);
    try{
      const msg = document.getElementById('abschluss-cart-msg');
      if (msg){ msg.className='ok'; msg.textContent = `Warenkorb exportiert (${items.length} Positionen, ${distinctNamesText(items)}).`; }
    }catch(_){}
  }

  // --- IMPORT ---
  function importCartFromFile(file){
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(){
      try{
        const json = JSON.parse(String(reader.result||'{}'));
        const items = Array.isArray(json.items) ? json.items : [];
        // Replace current cart
        try { window.clearCart && window.clearCart(); } catch(_){}
        let added = 0, blocked = 0;
        for (const it of items){
          const before = getCartSafe();
          const dnBefore = distinctNameCount(before);
          const base = (it && it.meta && it.meta.baseName) ? String(it.meta.baseName) : String(it.name||'').replace(/\s*\(.*?\)\s*$/, '');
          const exists = before.some(x => {
            const xb = (x && x.meta && x.meta.baseName) ? String(x.meta.baseName) : String(x.name||'').replace(/\s*\(.*?\)\s*$/, '');
            return xb.trim().toLowerCase() === base.trim().toLowerCase();
          });
          if (!exists && dnBefore >= 10){ blocked++; continue; }
          try {
            if (window.__ppkCartKernelAdd) window.__ppkCartKernelAdd(it);
            else if (window.addToCart) window.addToCart(it);
            added++;
          }catch(_){}
        }
        try{
          const msg = document.getElementById('abschluss-cart-msg');
          if (msg){
            if (blocked>0){
              msg.className='err';
              msg.textContent = `Warenkorb importiert: ${added} Positionen übernommen, ${blocked} wegen Limit (max. 10 verschiedene Karten) übersprungen.`;
            } else {
              msg.className='ok';
              msg.textContent = `Warenkorb importiert: ${added} Positionen (${distinctNamesText(getCartSafe())}).`;
            }
          }
        }catch(_){}
      }catch(err){
        try{
          const msg = document.getElementById('abschluss-cart-msg');
          if (msg){ msg.className='err'; msg.textContent = 'Import fehlgeschlagen: ungültige Datei.'; }
        }catch(_){}
      }
    };
    reader.readAsText(file);
  }

  // Bind buttons
  document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

    const btnExp = document.getElementById('btn-cart-export');
    if (btnExp && !btnExp._b){
      btnExp.addEventListener('click', function(e){ e.preventDefault(); exportCart(); }, true);
      btnExp._b = true;
    }
    const btnImp = document.getElementById('btn-cart-import');
    const inp = document.getElementById('cart-import-file');
    if (btnImp && inp && !btnImp._b){
      btnImp.addEventListener('click', function(e){ e.preventDefault(); inp.click(); }, true);
      btnImp._b = true;
    }
    if (inp && !inp._b){
      inp.addEventListener('change', function(){ importCartFromFile(inp.files && inp.files[0]); inp.value=''; }, true);
      inp._b = true;
    }
  });
})();
</script>
<script id="cart-edit-restore">
(function(){
  'use strict';
  function sanitizeNode(root){
    try{
      root.querySelectorAll('script').forEach(s=>s.remove());
      root.querySelectorAll('*').forEach(n=>{
        try{
          for (const a of Array.from(n.attributes||[])){ if (/^on/i.test(a.name)) n.removeAttribute(a.name); }
          n.removeAttribute && n.removeAttribute('draggable');
          n.removeAttribute && n.removeAttribute('contenteditable');
        }catch(_){}
      });
    }catch(_){}
    return root;
  }
  function parseHTML(html){ const div=document.createElement('div'); div.innerHTML=html||''; return sanitizeNode(div); }
  function pick(srcF, srcB, id, i){
    let el = null;
    // Try exact id on front/back
    if (srcF) el = srcF.querySelector('#'+id);
    if (!el && srcB) el = srcB.querySelector('#'+id);
    // Fallback: zero-padded variant (feld06, feld07, ...)
    if (!el && typeof i==='number'){
      const alt = 'feld' + String(i).padStart(2,'0');
      if (srcF) el = srcF.querySelector('#'+alt);
      if (!el && srcB) el = srcB.querySelector('#'+alt);
    }
    // Fallback: data-slot attribute
    if (!el && typeof i==='number'){
      if (srcF) el = srcF.querySelector('[data-slot="'+i+'"]');
      if (!el && srcB) el = srcB.querySelector('[data-slot="'+i+'"]');
    }
    return el || null;
  }
  function replaceInnerHTMLSafe(dst, src){
    if (!dst || !src) return;
    try{
      try{ dst.querySelectorAll('.droptext,.slot-hint').forEach(n=>n.remove()); }catch(_){}
      const tmp=document.createElement('div'); tmp.innerHTML=src.innerHTML||''; sanitizeNode(tmp);
      dst.innerHTML = tmp.innerHTML;
    }catch(_){}
  }
  function restoreToEditor(it){
    try{
      const meta=it.meta||{};
      const srcF=parseHTML(meta.frontHTML||'');
      const srcB=parseHTML(meta.backHTML||'');
      try{
        const cols=document.querySelector('div.columns'); const panel=document.getElementById('abschluss-panel');
        if (cols) cols.style.display=''; if (panel) panel.style.display='none';
      }catch(_){}
      try{ const kb=document.getElementById('kartenbereich'); if (kb){ kb.classList.add('front-top'); kb.classList.remove('back-top'); } }catch(_){}
      try{ const opt=meta.option; if (opt){ const r=document.querySelector('input[name=\"abschluss-ausfuehrung\"][value=\"'+opt+'\"]'); if (r){ r.checked=true; r.dispatchEvent(new Event('change',{bubbles:true})); } } }catch(_){}
      const ranges=[[2,7],[8,16],[17,25]];
      for (const [a,b] of ranges){ for (let i=a;i<=b;i++){ const id='feld'+i; const dst=document.getElementById(id); const src=pick(srcF,srcB,id,i); if (dst && src) replaceInnerHTMLSafe(dst,src); } }
      
      // Feld 6 (Spruch) explizit aus dem gespeicherten HTML zurückholen
      try{
        const spruchSrc = pick(srcF, srcB, 'spruchAnzeige', 6);
        const spruchDst = document.getElementById('spruchAnzeige');
        if (spruchSrc && spruchDst){
          replaceInnerHTMLSafe(spruchDst, spruchSrc);
        }
      }catch(_){}

      // Feld 7 (Symbol) explizit aus dem gespeicherten HTML zurückholen
      try{
        const symSrc = pick(srcF, srcB, 'symbolAnzeige', 7);
        const symDst = document.getElementById('symbolAnzeige');
        if (symSrc && symDst){
          replaceInnerHTMLSafe(symDst, symSrc);
        }
      }catch(_){}
try{
        const nameSrc=pick(srcF,srcB,'feld1NameAnzeige'); const nameDst=document.getElementById('feld1NameAnzeige')||document.getElementById('rb-plantname');
        if (nameDst){ if (nameSrc){ nameDst.textContent=(nameSrc.textContent||'').trim(); } else if (meta.baseName){ nameDst.textContent=String(meta.baseName); } }
      }catch(_){}
      try{ if (typeof window.updateAll==='function') window.updateAll(); }catch(_){}
      try{ const k=document.getElementById('kartenbereich')||document.getElementById('karte-vorderseite'); if (k) k.scrollIntoView({behavior:'smooth',block:'start'}); }catch(_){}
      try{ const hint=document.getElementById('abschluss-cart-msg'); if (hint){ hint.className='ok'; hint.textContent='Karte zur Bearbeitung geladen – Änderungen im Editor übernehmen Sie unten mit „Ausgewählte Karte aktualisieren“.'; } }catch(_){}
    }catch(err){
      try{ const hint=document.getElementById('abschluss-cart-msg'); if (hint){ hint.className='err'; hint.textContent='Fehler: Karte konnte nicht geladen werden.'; } }catch(_){}
    }
  }
  function findItemById(id){ try{ const items=(window.getCart&&window.getCart())||[]; return items.find(x=>x&&String(x.id)===String(id))||null; }catch(_){ return null; } }
  document.addEventListener('click', function(e){
    const btn=e.target.closest('[data-edit-cart-item]'); if (!btn) return;
    e.preventDefault();
    const id=btn.dataset.id||btn.getAttribute('data-edit-cart-item'); const it=findItemById(id); if (it){
      // Remember selection for update button
      try{ window.__ppkCartEditId=String(id); sessionStorage.setItem('ppkEditId', String(id)); }catch(_){ window.__ppkCartEditId=String(id); }
      try{ const upd=document.getElementById('btn-cart-apply-update'); if (upd){ upd.disabled=false; upd.removeAttribute('title'); } }catch(_){}
      restoreToEditor(it);
    }
  }, true);
})();
</script>
<script id="cart-explicit-update">
(function(){
  'use strict';
  function getCartSafe(){ try{ return (window.getCart&&window.getCart())||[]; }catch(_){ return []; } }
  function getEditId(){ try{ return window.__ppkCartEditId || sessionStorage.getItem('ppkEditId') || ''; }catch(_){ return window.__ppkCartEditId||''; } }
  function clearEditId(){ try{ delete window.__ppkCartEditId; sessionStorage.removeItem('ppkEditId'); }catch(_){ delete window.__ppkCartEditId; } }
  function computeBaseName(it){
    try{
      if (it && it.meta && it.meta.baseName) return String(it.meta.baseName).trim();
      if (it && it.name) return String(it.name).replace(/\s*\(.*?\)\s*$/, '').trim();
    }catch(_){}
    return '';
  }
  function distinctNameCountExcluding(id){
    const set=new Set();
    for (const it of getCartSafe()){
      if (!it || String(it.id)===String(id)) continue;
      const base=computeBaseName(it);
      if (base) set.add(base.toLowerCase());
    }
    return set.size;
  }
  function nameExistsExcluding(id, base){
    base=String(base||'').trim().toLowerCase();
    return getCartSafe().some(it=>it && String(it.id)!==String(id) && computeBaseName(it).toLowerCase()===base);
  }
  function msg(type, t){
    try{ const m=document.getElementById('abschluss-cart-msg'); if (m){ m.className=(type==='err'?'err':'ok'); m.textContent=t; }}catch(_){}
  }
  function snapshotHTML(root){
    try{
      var clone = root.cloneNode(true);
      // inputs
      clone.querySelectorAll('input').forEach(function(inp){
        try{ inp.setAttribute('value', inp.value); }catch(_){}
      });
      // textarea
      clone.querySelectorAll('textarea').forEach(function(ta){
        try{ ta.textContent = ta.value; }catch(_){}
      });
      // select
      clone.querySelectorAll('select').forEach(function(sel){
        try{
          sel.querySelectorAll('option').forEach(function(opt){
            if (opt.selected) opt.setAttribute('selected','');
            else opt.removeAttribute('selected');
          });
        }catch(_){}
      });
      return clone.outerHTML;
    }catch(_){ return root ? root.outerHTML : ''; }
  }
  function captureItemFromEditor(editId, keepQty){
    try{
      const r=document.querySelector('input[name="abschluss-ausfuehrung"]:checked');
      const opt=r ? r.value : 'standard';
      const labelMap={ 'laminat_oben':'loch oben','laminat_unten':'überstand unten','kein_laminat':'kein laminatüberstand','steckspitze':'steckspitze' };
      const optionLabel=labelMap[opt]||opt;
      const old=getCartSafe().find(x=>x && String(x.id)===String(editId));
      const qty=(keepQty&&old)?Number(old.qty||1):1;
      let pname=''; const sels=['#feld1NameAnzeige','#rb-plantname','[data-field="1"]','#karte-vorderseite .feld-1','#karte-vorderseite .name'];
      for (const s of sels){ const el=document.querySelector(s); if (!el) continue; const v=('value' in el)?el.value:(el.textContent||el.innerText||''); if (v && v.trim()){ pname=v.trim(); break; } }
      if (!pname) pname='Karte';
      const f=document.getElementById('karte-vorderseite'); const b=document.getElementById('karte-rueckseite');
      const frontHTML=f?snapshotHTML(f):''; const backHTML=b?snapshotHTML(b):'';
      const displayName=pname+' ('+optionLabel+')';
      return { id:editId, name:displayName, price:0, qty:qty, meta:{ option:opt, baseName:pname, time:new Date().toISOString(), frontHTML, backHTML } };
    }catch(_){ return null; }
  }

  document.addEventListener('click', function(e){
    const btn = e.target.closest('#btn-cart-apply-update');
    if (!btn) return;
    e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    const id = getEditId();
    if (!id){ msg('err','Keine Karte im Bearbeitungsmodus. Wählen Sie im Warenkorb „Bearbeiten“.'); return; }
    const items = getCartSafe();
    const current = items.find(x=>x && String(x.id)===String(id));
    if (!current){ msg('err','Warenkorb-Position nicht gefunden.'); return; }
    const updated = captureItemFromEditor(id, true);
    if (!updated){ msg('err','Fehler beim Erfassen der Änderungen.'); return; }
    const baseNew = computeBaseName(updated).toLowerCase();
    const baseOld = computeBaseName(current).toLowerCase();
    const exists = nameExistsExcluding(id, baseNew);
    const countEx = distinctNameCountExcluding(id);
    if (baseNew!==baseOld && !exists && countEx>=10){
      msg('err','Maximal 10 verschiedene Karten im Warenkorb. Bitte zuerst eine Bestellung abschließen oder eine Karte entfernen.');
      return;
    }
    try{ window.removeFromCart && window.removeFromCart(id); }catch(_){}
    try{ if (window.__ppkCartKernelAdd) window.__ppkCartKernelAdd(updated); else if (window.addToCart) window.addToCart(updated); }catch(_){}
    msg('ok','Karte aktualisiert.');
    clearEditId();
    try{ const upd=document.getElementById('btn-cart-apply-update'); if (upd){ upd.disabled=true; upd.title='Wählen Sie zuerst im Warenkorb „Bearbeiten“.'; } }catch(_){}
    try{ if (typeof window.renderCartList==='function') window.renderCartList(); }catch(_){}
    try{ const stage=document.getElementById('abschluss-stage'); if (stage) stage.scrollIntoView({behavior:'smooth', block:'start'}); }catch(_){}
  }, true);
})();
</script>

<script id="move_apply_update_button">
// Einzelschritt: "Ausgewählte Karte aktualisieren" direkt unter die grüne Meldung setzen
(function(){
  function place(){
    var msg = document.getElementById('abschluss-cart-msg');
    var btn = document.getElementById('btn-cart-apply-update');
    if (msg && btn && btn.previousElementSibling !== msg){
      try{ msg.insertAdjacentElement('afterend', btn); }catch(e){}
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', place, {once:true});
  }else{
    place();
  }
  // Sicherheit: falls Komponenten später neu rendern
  setTimeout(place, 100);
  document.addEventListener('ppk:cart:rendered', place);
})();</script><script id="no_ruler_toggle_js">
(function(){
  function addNoRuler(){ document.documentElement.classList.add('no-ruler'); }
  function removeNoRulerLater(){ setTimeout(function(){ document.documentElement.classList.remove('no-ruler'); }, 1500); }

  function arm(el){
    if(!el) return;
    ['pointerdown','click','keydown'].forEach(function(ev){
      el.addEventListener(ev, function(e){
        if (ev==='keydown' && !(e.key==='Enter' || e.key===' ')) return;
        addNoRuler(); removeNoRulerLater();
      });
    });
  }

  // 1) Sicher bekannt: "Ausgewählte Karte aktualisieren"
  arm(document.getElementById('btn-cart-apply-update'));

  // 2) Häufige Aktionen: In den Warenkorb / Bestellung aufgeben / Nächste Karte
  Array.from(document.querySelectorAll('button, input[type="button"], a')).forEach(function(b){
    var t = (b.textContent || b.value || '').trim();
    if (/^(In den Warenkorb|Bestellung aufgeben|Nächste Karte)$/i.test(t)){
      arm(b);
    }
  });

  // Fallback: bei Formular-Submit in Cart rechts ebenfalls kurz ausblenden
  Array.from(document.querySelectorAll('form')).forEach(function(f){
    f.addEventListener('submit', function(){ addNoRuler(); removeNoRulerLater(); });
  });
})();
</script><script id="abschluss_strip_ruler_js">
// [Einzelschritt] Im Abschlussbereich den grünen Rahmen (Ruler) konsequent entfernen
(function(){
  const SELECTOR = '#abschluss-ruler, .abschluss-ruler, .ruler, [data-role="ruler"]';
  function strip(root){
    if(!root) return;
    try{
      root.querySelectorAll(SELECTOR).forEach(function(el){
        try{ el.remove(); }catch(_){ el.style.display='none'; el.style.opacity='0'; }
      });
    }catch(_){}
  }
  function observe(root){
    if(!root) return;
    const mo = new MutationObserver(function(muts){
      for(const m of muts){
        for(const n of m.addedNodes || []){
          if(n && n.nodeType===1){
            try{
              if (n.matches && n.matches(SELECTOR)) { try{ n.remove(); }catch(_){ n.style.display='none'; n.style.opacity='0'; } }
              else if (n.querySelector){ strip(n); }
            }catch(_){}
          }
        }
      }
    });
    mo.observe(root, {subtree:true, childList:true});
  }

  const panel = document.getElementById('abschluss-panel') || document.querySelector('#abschluss, .abschluss, #abschlussbereich');
  const stage = document.getElementById('abschluss-stage');
  [panel, stage].forEach(function(scope){
    strip(scope);
    observe(scope);
  });

  // Fallback: bei bekannten App-Events erneut säubern
  document.addEventListener('ppk:abschluss:open', function(){ strip(panel||document); });
  document.addEventListener('ppk:cart:rendered', function(){ strip(panel||document); });

  // Initialer Sicherheitslauf nach Render
  setTimeout(function(){ strip(panel||document); }, 100);
})();</script><script id="use_users_lineal_js">
(function(){
  function mmToPx(mm){ return mm * (96/25.4); } // CSS px/mm-Referenz

  function cloneUserLineal(){
    var src   = document.getElementById('lineal') || document.querySelector('.lineal');
    var frame = document.getElementById('abschluss-card-frame');
    var card  = document.getElementById('abschluss-card');
    var paper = document.getElementById('gate-undercard'); // weißes Papier
    var stage = document.getElementById('abschluss-stage');
    if (!src || !frame || !card || !stage) return;

    var clone = document.getElementById('abschluss-lineal-clone');
    if (!clone){
      clone = src.cloneNode(true);
      clone.id = 'abschluss-lineal-clone';
      clone.style.pointerEvents = 'none';
      clone.style.position = 'absolute';
      clone.style.zIndex = '30';
      frame.appendChild(clone);
    }

    var is100 = stage.classList.contains('zoom-100');
    clone.style.display = is100 ? 'block' : 'none';
    if (!is100) return;

    var fr = frame.getBoundingClientRect();
    var cr = card.getBoundingClientRect();
    var pr = (paper ? paper.getBoundingClientRect() : cr);

    // Basisabstand 12px + 2mm zum äußeren Papierrand
    var gapPx = 12 + mmToPx(2);

    // Erweiterung des Papiers nach links: 5mm (muss von der Position abgezogen werden)
    var extLeftPx = mmToPx(5);

    // Am Papier ausrichten (Top & Höhe = Papierhöhe)
    clone.style.top    = (pr.top - fr.top) + 'px';
    clone.style.height = pr.height + 'px';
    clone.style.width  = 'auto';

    // Breite des Klons nach Rendern bestimmen
    var w = clone.getBoundingClientRect().width || 16;

    // Links: äußerer Papierrand (pr.left - extLeftPx) minus Abstand und Linealbreite
    clone.style.left = (pr.left - fr.left - extLeftPx - w - gapPx) + 'px';
  }

  window.addEventListener('load', function(){ setTimeout(cloneUserLineal, 60); });
  window.addEventListener('resize', function(){ setTimeout(cloneUserLineal, 30); });
  document.addEventListener('click', function(e){
    var el = e.target && e.target.closest ? e.target.closest('[data-zoom],button,a,[role="button"]') : null;
    if (!el) return;
    var t = (el.textContent || el.value || '').trim();
    if (/^\d{2,3}%$/.test(t) || (el.getAttribute('data-zoom'))){
      setTimeout(cloneUserLineal, 80);
    }
  }, true);

  try{
    var stage = document.getElementById('abschluss-stage');
    new MutationObserver(function(){ cloneUserLineal(); }).observe(stage, {attributes:true, attributeFilter:['class','style']});
  }catch(_){}

  setTimeout(cloneUserLineal, 120);
})();</script><script id="side-actions-js">
document.addEventListener('DOMContentLoaded', () => {
  // Finde das grüne Panel
  const panel = document.querySelector('.abschluss-paper');
  if (!panel) return;

  // Erzeuge einen Flex-Wrapper NUR um dieses Panel (reversibel)
  if (!panel.parentElement.classList.contains('abf-wrap-flex')){
    const wrap = document.createElement('div');
    wrap.className = 'abf-wrap-flex';
    panel.parentElement.insertBefore(wrap, panel);
    wrap.appendChild(panel);

    // Rechte Spalte für die zwei Buttons
    const side = document.createElement('div');
    side.className = 'abf-side-actions';
    wrap.appendChild(side);

    // Buttons anhand der sichtbaren Beschriftung suchen – NICHTS anderes bewegen
    const sel = 'button, [role="button"], input[type="button"], input[type="submit"]';
    const text = el => (el?.textContent || el?.value || '').replace(/\s+/g,' ').trim();
    const find = re => Array.from(document.querySelectorAll(sel)).find(b => re.test(text(b)));

    const btnWarenkorb = find(/in den\s+warenkorb/i);
    const btnNext      = find(/nächste\s+karte/i);

    if (btnWarenkorb) side.appendChild(btnWarenkorb);
    if (btnNext)      side.appendChild(btnNext);
  }
});
</script>
<script id="triple-align-js">
document.addEventListener('DOMContentLoaded', () => {
  const grid  = document.querySelector('#abschluss-grid');
  const cardF = document.querySelector('#abschluss-card-frame');
  const panel = document.querySelector('.abschluss-paper');
  const side  = document.querySelector('.abf-side-actions');
  if (!grid || !cardF || !panel || !side) return;

  const btnWarenkorb = Array.from(side.querySelectorAll('button, [role="button"], input[type="button"], input[type="submit"]'))
    .find(b => /in den\s+warenkorb/i.test((b.textContent || b.value || '').trim()));

  function px(val){
    const n = parseFloat(val || '0');
    return isNaN(n) ? 0 : n;
  }

  function align(){
    const g = grid.getBoundingClientRect();
    const cardTop  = cardF.getBoundingClientRect().top - g.top;

    // 1) Grünes Panel an Kartenkante ausrichten
    const panelRect = panel.getBoundingClientRect();
    const panelTop  = panelRect.top - g.top;
    const curPM     = window.getComputedStyle(panel).marginTop;
    const newPM     = Math.max(0, Math.round(px(curPM) + (cardTop - panelTop)));
    panel.style.marginTop = newPM + 'px';

    // 2) Side-Actions (damit die Oberkante des 1. Buttons «In den Warenkorb» gleich ist)
    const sideRect = side.getBoundingClientRect();
    const sideTop  = sideRect.top - g.top;
    const curSM    = window.getComputedStyle(side).marginTop;
    const newSM    = Math.max(0, Math.round(px(curSM) + (cardTop - sideTop)));
    side.style.marginTop = newSM + 'px';
  }

  align();
  if ('ResizeObserver' in window){
    const ro = new ResizeObserver(align);
    ro.observe(cardF);
    ro.observe(panel);
    ro.observe(side);
  }
  window.addEventListener('resize', align);
});
</script>
<script id="btn-yellow-only-js">
document.addEventListener('DOMContentLoaded', () => {
  const q = 'button,[role="button"],input[type="button"],input[type="submit"]';
  const text = el => (el?.textContent || el?.value || '').replace(/\s+/g,' ').trim();
  const targets = [
    /warenkorb-link\s+kopieren/i,
    /warenkorb\s+leeren/i,
    /exportieren/i,
    /importieren/i
  ];

  document.querySelectorAll(q).forEach(btn => {
    const label = text(btn);
    // Entferne evtl. alte Akzentklassen
    btn.classList.remove('btn-accent-left');
    // Setze Gelb nur auf die vier Zielbuttons
    if (targets.some(re => re.test(label))) {
      btn.classList.add('btn-yellow');
    }
  });
});
</script>
<script id="btn-yellow-unified-js">
document.addEventListener('DOMContentLoaded', () => {
  const q = 'button,[role="button"],input[type="button"],input[type="submit"]';
  const text = el => (el?.textContent || el?.value || '').replace(/\s+/g,' ').trim();
  // Hyphen-insensitive Match für "Warenkorb‑Link kopieren"
  const H = "[\\s\\-\\u2010-\\u2015]*";
  const reCopy   = new RegExp("warenkorb" + H + "link\\s+kopieren", "i");
  const reClear  = /warenkorb\s+leeren/i;
  const reExport = /exportieren/i;
  const reImport = /importieren/i;

  document.querySelectorAll(q).forEach(btn => {
    const label = text(btn);
    if (reCopy.test(label) || reClear.test(label) || reExport.test(label) || reImport.test(label)){
      btn.classList.add('btn-yellow');
    }
  });
});
</script>
<script id="cta-floater-unified-js">
document.addEventListener('DOMContentLoaded', () => {
  const OFFSET_PX = Math.round(5 * (96/25.4)); // +5mm
  const grid = document.querySelector('#abschluss-grid');
  const card = document.querySelector('#abschluss-card-frame');
  if (!grid || !card) return;

  // Find Import/Export reference WITHOUT moving them
  const q = 'button,[role="button"],input[type="button"],input[type="submit"]';
  const text = el => (el?.textContent || el?.value || '').replace(/\s+/g,' ').trim();
  const find = re => Array.from(document.querySelectorAll(q)).find(b => re.test(text(b)));
  const refBtn = find(/exportieren/i) || find(/importieren/i);
  if (!refBtn) return;

  // Find CTA ("Bestellung aufgeben") and ensure primary class
  const cta = find(/bestellung\s+aufgeben/i);
  if (!cta) return;
  cta.classList.add('btn-primary-green'); // für Gewichtung/Look

  // Create floater container once
  let floater = document.getElementById('order-floater');
  if (!floater){
    floater = document.createElement('div');
    floater.id = 'order-floater';
    const holder = document.createElement('div');
    holder.className = 'holder';
    floater.appendChild(holder);
    grid.appendChild(floater);
  }
  const holder = floater.querySelector('.holder');
  if (cta.parentElement !== holder) holder.appendChild(cta);

  function place(){
    const gridRect = grid.getBoundingClientRect();
    const cardRect = card.getBoundingClientRect();
    const refRect  = refBtn.getBoundingClientRect();
    const ctaRect  = cta.getBoundingClientRect();

    const left = cardRect.left - gridRect.left;
    const top  = (refRect.top - gridRect.top) + (refRect.height - ctaRect.height)/2 + OFFSET_PX;

    floater.style.left   = Math.round(left) + 'px';
    floater.style.top    = Math.round(top)  + 'px';
    floater.style.width  = Math.round(cardRect.width) + 'px';
    floater.style.height = Math.ceil(ctaRect.height) + 'px';
  }

  // Initial + reactive placement
  place();
  window.addEventListener('resize', place);
  if ('ResizeObserver' in window){
    const ro = new ResizeObserver(place);
    ro.observe(card);
    ro.observe(refBtn);
  }
});
</script>
<script id="cart-label-case-fix">
document.addEventListener('DOMContentLoaded', () => {
  const root = document.querySelector('#abschluss-cart-list') || document;
  // Mapping: wrong/legacy -> corrected (German nouns capitalized)
  const fixes = [
    {re:/\((\s*)kein\s+laminatüberstand(\s*)\)/gi, to:'(kein Laminatüberstand)'},
    {re:/\((\s*)überstand\s+unten(\s*)\)/gi,       to:'(Überstand unten)'},
    {re:/\((\s*)loch\s+oben(\s*)\)/gi,             to:'(Loch oben)'},
    {re:/\((\s*)steckspitze(\s*)\)/gi,             to:'(Steckspitze)'},
  ];

  function fixNode(el){
    const t = el.textContent;
    if (!t) return;
    let u = t;
    fixes.forEach(f => { u = u.replace(f.re, f.to); });
    if (u !== t) el.textContent = u;
  }

  // Fix immediate children that hold the blue labels (likely text nodes within elements)
  root.querySelectorAll('*').forEach(el => {
    // Only touch elements that don't contain inputs (avoid buttons)
    if (!el.querySelector('input,button,select,textarea')) fixNode(el);
  });
});
</script>
<script id="stickers-to-png-adapter">
(function(){
  const SVG_EXT = /\.svg(\?.*)?$/i;
  const PNG_FIX = (url) => url ? url.replace(/(?:_symbol)?\.svg(\?.*)?$/i, '_symbol.png') : url;

  const inStickerScope = (el) => {
    if (!el) return false;
    if (el.closest && el.closest('.karte-overlay')) return true;
    const p = el.parentElement;
    const pid = (p && p.id || '').toLowerCase();
    if (pid.startsWith('karte_') && pid.endsWith('_overlay')) return true;
    return false;
  };

  const convertEl = (el) => {
    if (!el || !inStickerScope(el)) return;
    const srcAttr = el.getAttribute('src');
    if ((el.tagName === 'IMG' || el.tagName === 'OBJECT') && srcAttr && SVG_EXT.test(srcAttr)){
      el.setAttribute('src', PNG_FIX(srcAttr));
    }
    const ds = el.getAttribute('data-src');
    if (el.tagName === 'IMG' && ds && SVG_EXT.test(ds)){
      el.setAttribute('data-src', PNG_FIX(ds));
    }
    const style = el.getAttribute('style')||'';
    if (style && /background-image\s*:\s*url\(([^)]+)\)/i.test(style)){
      const newStyle = style.replace(/(background-image\s*:\s*url\()([^)]+)(\))/i, (m, a, url, c) => {
        const unq = url.replace(/^['"]|['"]$/g, '');
        const fixed = SVG_EXT.test(unq) ? PNG_FIX(unq) : unq;
        const quoted = (url.startsWith('"')||url.startsWith("'")) ? url[0] + fixed + url[url.length-1] : fixed;
        return a + quoted + c;
      });
      if (newStyle !== style) el.setAttribute('style', newStyle);
    }
  };

  const scan = (root=document) => {
    const nodes = root.querySelectorAll('.karte-overlay img, .karte-overlay object, .karte-overlay [style*="background-image"]');
    nodes.forEach(convertEl);
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => scan());
  } else {
    scan();
  }

  if ('MutationObserver' in window){
    const mo = new MutationObserver((mut) => {
      mut.forEach(rec => {
        rec.addedNodes && rec.addedNodes.forEach(node => {
          if (node.nodeType === 1) {
            if (node.matches && node.matches('.karte-overlay, .karte-overlay *')) convertEl(node);
            if (node.querySelectorAll) scan(node);
          }
        });
      });
    });
    mo.observe(document.documentElement, {subtree:true, childList:true});
  }
})();
</script>
<script id="ui-icons-nonsymbol-png">
(function(){
  const SYM_RE = /_symbol\.png(\?.*)?$/i;
  const toPlain = (url) => url ? url.replace(SYM_RE, '.png') : url;

  // UI-Icons erkennen (gelbe Boxen / Abschlussbereich), aber NICHT die Karten-Overlays
  function isUiIcon(el){
    if (!el) return false;
    if (el.closest && el.closest('.karte-overlay')) return false; // Kartensticker ausschließen
    // Typische Container/Namen im Abschlussbereich und Service-Buttons
    if (el.closest && (el.closest('#abschluss-sidebar') || el.closest('#abschluss-actions') || el.closest('.abschluss-actions') || el.closest('.rbc-actions') || el.closest('.sp-actions'))) return true;
    const cls = (el.getAttribute('class')||'').toLowerCase();
    const id  = (el.id||'').toLowerCase();
    if (/\b(btn|button|service|gelb|yellow)\b/.test(cls)) return true;
    if (/abschluss|actions/.test(id)) return true;
    return false;
  }

  function convert(el){
    if (!isUiIcon(el)) return;
    // img/object src & data-src
    ['src','data-src'].forEach(attr => {
      const v = el.getAttribute && el.getAttribute(attr);
      if (v && SYM_RE.test(v)) el.setAttribute(attr, toPlain(v));
    });
    // inline background-image
    const style = el.getAttribute && el.getAttribute('style') || '';
    if (style && /background-image\s*:\s*url\(([^)]+)\)/i.test(style)){
      const newStyle = style.replace(/(background-image\s*:\s*url\()([^)]+)(\))/i, (m, a, url, c) => {
        const unq = url.replace(/^['"]|['"]$/g, '');
        const fixed = SYM_RE.test(unq) ? toPlain(unq) : unq;
        const quoted = (url.startsWith('"')||url.startsWith("'")) ? url[0] + fixed + url[url.length-1] : fixed;
        return a + quoted + c;
      });
      if (newStyle !== style) el.setAttribute('style', newStyle);
    }
  }

  function scan(root){
    const nodes = root.querySelectorAll ? root.querySelectorAll('img,object,[style*="background-image"]') : [];
    nodes.forEach(convert);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', () => scan(document));
  } else {
    scan(document);
  }

  if ('MutationObserver' in window){
    const mo = new MutationObserver(muts => {
      muts.forEach(rec => {
        if (!rec.addedNodes) return;
        rec.addedNodes.forEach(node => {
          if (node.nodeType !== 1) return;
          convert(node);
          if (node.querySelectorAll) scan(node);
        });
      });
    });
    mo.observe(document.documentElement, {subtree:true, childList:true});
  }
})();
</script>
<!-- Bestellvorgang1: Single-Checkout Bridge (FIX) -->
<script id="bestellvorgang1-single-bridge-fix">
(function(){
  'use strict';
  function findBtn(){
    return document.querySelector('#bestellung-aufgeben, [data-action="checkout"]')
      || Array.from(document.querySelectorAll('button,a')).find(b => (b.textContent||'').trim().toLowerCase() === 'bestellung aufgeben');
  }
  function cartCount(){
    try{ if(window.cart && Array.isArray(window.cart.items)) return window.cart.items.length; }catch(e){}
    const n = document.querySelectorAll('[data-card], .card-editor, .konfig-karte').length;
    return n || 1;
  }
  function norm(n){
    n = parseInt(n,10) || 1;
    if([1,3,5].includes(n)) return n;
    if(n <= 1) return 1;
    if(n <= 3) return 3;
    return 5;
  }
  function getCode(){
    try{
      const c = (window.currentVoucherCode || window.checkoutCode || '').toString().trim();
      if(c) return c;
      const inp = document.querySelector('#gutscheinCode, #voucherCode, input[name="redeemCode"]');
      if(inp && inp.value) return inp.value.trim();
    }catch(e){}
    return '';
  }
  const btn = findBtn();
  if(!btn || btn.__singleBridgeFix) return;
  btn.__singleBridgeFix = true;
  btn.addEventListener('click', function(){
    const count = norm(cartCount());
    const code  = getCode();
    // IMPORTANT: open the fixed single checkout page
    const url = 'etsy_checkout_SINGLE_FIX.html'
      + '?from=konfigurator'
      + '&count=' + encodeURIComponent(count)
      + (code ? '&code=' + encodeURIComponent(code) : '');
    window.open(url, '_blank', 'noopener');
  }, {passive:true});
})();
</script><script id="zoom-100-on-finish">
(function(){
  'use strict';
  // Robust: mehrere Wege versuchen, Zoom auf 100% zu setzen
  function ensureZoom100(){
    try{
      // 1) Offizielle API-Funktion(en), falls vorhanden
      if (typeof window.setZoom === 'function'){ try{ window.setZoom(1); return; }catch(_){} }
      if (typeof window.zoomTo === 'function'){ try{ window.zoomTo(1); return; }catch(_){} }
      if (typeof window.updateZoom === 'function'){ try{ window.updateZoom(1); return; }catch(_){} }
      // 2) Klick auf "Zoom 100%"-Button, wenn es ihn gibt
      var btn = Array.from(document.querySelectorAll('button, a')).find(function(el){
        var t = (el.textContent||'').trim().toLowerCase();
        return t === 'zoom 100%' || t === 'zoom 100' || /zoom\s*100/.test(t);
      });
      if (btn){ btn.click(); return; }
      // 3) CSS-Variable --zoom setzen (Fallback)
      try{ document.documentElement.style.setProperty('--zoom','1'); }catch(_){}
      try{
        var root = document.getElementById('kartenbereich') || document.body;
        if (root && root.style) root.style.setProperty('--zoom','1');
      }catch(_){}
    }catch(_){}
  }
  window.__ensureZoom100 = ensureZoom100;

  // a) Wenn die alte Toggle-Funktion "Abschluss" aufruft, vorher Zoom resetten
  ['zeigeAbschluss','showAbschluss'].forEach(function(name){
    var prev = window[name];
    window[name] = function(){
      try{ ensureZoom100(); }catch(_){}
      if (typeof prev === 'function'){ try{ return prev.apply(this, arguments); }catch(_){ } }
    };
  });

  // b) Delegation: Klick auf "Karte fertig" → Zoom 100 + Scroll (Scroll-Wrapper kümmert sich um Scroll)
  document.addEventListener('click', function(e){
    var t = e.target && e.target.closest && e.target.closest('[data-action="karte-fertig"], .karte-fertig, [id*="karte-fertig"], button, a');
    if (!t) return;
    var label = (t.textContent||'').trim().toLowerCase();
    if (/^karte\s+fertig$/.test(label)){
      try{ ensureZoom100(); }catch(_){}
    }
  }, true);
})();
</script>
<script id="two-page-config-urls">
window.SHOP_URL = window.SHOP_URL || "http://localhost:8000/shop.html";
</script>
<script id="two-page-config-bridge">
(function(){
  'use strict';
  const ch = new BroadcastChannel('pfk-link');
  const dot = document.getElementById('simDot');
  const toast = document.getElementById('simToast');
  let shopAlive = false;
  function showToast(msg){
    toast.textContent = msg;
    toast.style.display = 'block';
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.style.display='none', 1800);
  }
  function setAlive(alive){ shopAlive = !!alive; dot.classList.toggle('ok', shopAlive); }
  let lastPong = 0;
  setInterval(function(){ if (Date.now() - lastPong > 4000) setAlive(false); }, 1000);

  ch.onmessage = function(ev){
    const m = ev.data||{};
    if (m.type === 'pong'){ lastPong = Date.now(); setAlive(true); }
    if (m.type === 'editItem'){ try{ location.hash = '#editor'; }catch(_){ } showToast('Shop möchte bearbeiten: '+(m.item && m.item.title || '—')); }
    if (m.type === 'shopReady'){ setAlive(true); showToast('Shop verbunden'); }
  };
  document.getElementById('btnPingShop').addEventListener('click', function(){ ch.postMessage({type:'ping', from:'config'}); });

  function txt(sel){
    const el = document.querySelector(sel);
    return (el && (el.value || el.textContent || '')).trim() || '';
  }
  function collectConfig(){
    let title = txt('#feld1NameAnzeige') || txt('#pflanzensuche input') || txt('input[placeholder*="Name" i]') || 'Unbenannte Karte';
    const spruch = txt('#spruchSelect option:checked') || txt('#spruchAnzeige') || '';
    const smiley = txt('#smileySelect option:checked') || '';
    const menge = parseInt(txt('#menge') || txt('input[name="menge"]') || '1', 10) || 1;
    const id = 'it_' + Date.now().toString(36);
    return { id, title, spruch, smiley, menge, ts: Date.now() };
  }
  document.getElementById('btnSendToShop').addEventListener('click', function(){
    const item = collectConfig();
    try{ ch.postMessage({type:'addItem', item, from:'config'}); }catch(_){}
    showToast('Zum Shop gesendet: '+item.title);
    try{ location.hash = '#abschluss'; }catch(_){}
  });

  // Intake aus localStorage (wenn Shop separat geöffnet hat, gleicher Origin)
  try{
    const raw = localStorage.getItem('pfk_edit');
    if (raw){
      const obj = JSON.parse(raw);
      if (obj && obj.ts && (Date.now()-obj.ts) < 15000){
        try{ location.hash = '#editor'; }catch(_){}
        window.__DEBUG__ && console.log('[PFK] Edit vom Shop übernommen:', obj.item);
      }
      localStorage.removeItem('pfk_edit');
    }
  }catch(_){}

  setTimeout(()=>ch.postMessage({type:'configReady'}), 300);
})();
</script>
<!-- ENV GUARD: blendet Simulationsleisten & Test-Buttons aus (Standard) -->
<script id="env-guard">
(function(){
  'use strict';
  // Dev-Modus nur mit ?sim=1 oder localStorage('pfk_dev') === '1'
  var DEV = /(?:\?|&)sim=1(?:&|$)/.test(location.search) || (localStorage.getItem('pfk_dev') === '1');

  function removeAll(sel){
    try{ document.querySelectorAll(sel).forEach(function(el){ el.remove(); }); }catch(_){}
  }
  function hideByText(rx){
    try{
      Array.from(document.querySelectorAll('button, a')).forEach(function(el){
        var t = (el.textContent||'').trim();
        if (rx.test(t)) el.style.display = 'none';
      });
    }catch(_){}
  }

  if (!DEV){
    // Simulationsleisten & -container entfernen
    removeAll('#simBar, #simToast, #shopSimBar, #simCart, .sim-only');
    // "Test beenden"-Button ausblenden (egal wo er liegt)
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

      hideByText(/^\s*test\s*beenden\s*$/i);
      // häufige IDs/Klassen ebenfalls hart abfangen
      removeAll('#test-beenden, .test-beenden');
    }, {once:true});
  }

  // Shortcut: Ctrl+Alt+D schaltet DEV-Flag dauerhaft um
  window.addEventListener('keydown', function(ev){
    try{
      if (ev.ctrlKey && ev.altKey && (ev.key||'').toLowerCase() === 'd'){
        var next = (localStorage.getItem('pfk_dev') === '1') ? '0' : '1';
        localStorage.setItem('pfk_dev', next);
        location.reload();
      }
    }catch(_){}
  });
})();
</script>
<style id="scroll-nav-style">
  #kartenbereich, #abschluss-panel { display:block !important; visibility:visible !important; opacity:1 !important; }
  #abschluss-panel { margin-top:48px; }
  html { scroll-behavior: smooth; }
  .scroll-anchor { scroll-margin-top: 80px; }
</style>
<script id="scroll-nav-script">
(function(){
  'use strict';
  var EDITOR_ID = 'kartenbereich';
  var ABSCHLUSS_ID = 'abschluss-panel';
  function byId(id){ return document.getElementById(id); }
  function scrollToId(id){
    var el = byId(id); if(!el) return;
    try{ if(!el.classList.contains('scroll-anchor')) el.classList.add('scroll-anchor'); }catch(_){}
    try{ el.scrollIntoView({behavior:'smooth', block:'start'}); }catch(_){ location.hash = '#'+id; }
  }
  function wrapScroll(name, targetId){
    var prev = window[name];
    window[name] = function(){
      try{ scrollToId(targetId); }catch(_){}
      if (typeof prev === 'function'){ try{ prev.apply(this, arguments); }catch(_){ } }
    };
  }
  wrapScroll('zeigeAbschluss', ABSCHLUSS_ID);
  wrapScroll('showAbschluss', ABSCHLUSS_ID);
  wrapScroll('zeigeEditor', EDITOR_ID);
  wrapScroll('showEditor', EDITOR_ID);
  document.addEventListener('click', function(e){
    var t = e.target;
    if (!t) return;
    var goA = t.closest && (t.closest('[data-goto="abschluss"]') || t.closest('[href="#abschluss"]'));
    var goE = t.closest && (t.closest('[data-goto="editor"]')    || t.closest('[href="#editor"]'));
    if (goA){ e.preventDefault(); scrollToId(ABSCHLUSS_ID); }
    if (goE){ e.preventDefault(); scrollToId(EDITOR_ID); }
  }, true);
  document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

    if (location.hash === '#abschluss'){ setTimeout(function(){ scrollToId(ABSCHLUSS_ID); }, 100); }
    else if (location.hash === '#editor'){ setTimeout(function(){ scrollToId(EDITOR_ID); }, 100); }
  }, {once:true});
})();
</script>
<!-- PPK Gate für Wix entfernt -->
<!-- order-modal-script für Wix entfernt -->
<script id="next-card-guard">
(function(){
  function normText(s){ return (s||"").toLowerCase().replace(/\s+/g," ").trim(); }
  function byText(selector, needle){
    needle = normText(needle);
    return Array.from(document.querySelectorAll(selector))
      .find(el => normText(el.textContent||"").includes(needle));
  }
  function findNextBtn(){
    return byText('button, a', 'nächste karte') ||
           byText('button, a', 'naechste karte') ||
           byText('button, a', 'weiter');
  }
  function findApplyBtn(){
    return byText('button, a', 'pflanzennamen übernehmen') ||
           byText('button, a', 'übernehmen') ||
           byText('button, a', 'ok');
  }
  function parseRestFromUI(){
    // lese eine Restzahl aus dem UI (z. B. "Rest: 0", "noch 2", "verfügbar: 1")
    var leafs = Array.from(document.querySelectorAll('body *')).filter(n => n.childElementCount===0);
    for (var n of leafs){
      var t = (n.textContent||"").trim();
      var m = /(rest|übrig|verfügbar|karten)\D{0,12}(\d+)/i.exec(t);
      if (m) return parseInt(m[2],10);
    }
    var el = document.querySelector('[data-rest]');
    if (el){
      var v = parseInt(el.getAttribute('data-rest'),10);
      if (!isNaN(v)) return v;
    }
    return null;
  }
  function wire(){
    var next = findNextBtn();
    var apply = findApplyBtn();
    if (!next) return;
    if (next.dataset.guardWired === '1') return;
    next.dataset.guardWired = '1';

    next.addEventListener('click', function(ev){
      try { if (apply) apply.click(); } catch(e){}
      setTimeout(function(){
        var isBuyer = /(^|[?&])mode=buyer(\b|&|$)/i.test(location.search);
        var rest = parseRestFromUI();
        if (isBuyer && rest !== null && rest <= 0){
          if (ev && ev.preventDefault) ev.preventDefault();
          alert('Dein Kontingent ist aufgebraucht. Bitte erst eine Karte entfernen oder zur Kasse gehen.');
          return false;
        }
      }, 0);
    }, true);
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', wire);
  } else {
    wire();
  }
})();
</script>
<!-- Auto-Selector für Steuerleiste/Toolbar -->
<script id="ppk-editor-selector">
(function(){
  if (window.PPK_EDITOR_SELECTOR) return;
  var candidates = [
    '#steuerleiste', '.steuerleiste',
    '#toolbar', '.toolbar',
    '#editor-toolbar', '.editor-toolbar',
    '.control-bar', '.controls',
    '#topbar', '.topbar'
  ];
  for (var i=0;i<candidates.length;i++){
    try{
      var el = document.querySelector(candidates[i]);
      if (el){
        window.PPK_EDITOR_SELECTOR = candidates[i];
        break;
      }
    }catch(e){}
  }
})();
</script>
<script id="ppk-scroll-config">
  window.PPK_EDITOR_SELECTOR = '.steuerleiste';
  window.PPK_SCROLL_CONTAINER = '.frame';
  window.PPK_SCROLL_OFFSET = 90;
</script>
<script id="auto-apply-next-card-v9">
(function(){
  function $(sel){ return document.querySelector(sel); }
  function $all(sel){ return Array.from(document.querySelectorAll(sel)); }
  function norm(s){ return (s||"").toLowerCase().replace(/\s+/g,' ').trim(); }
  function byText(selector, needle){
    needle = norm(needle);
    return $all(selector).find(el => norm(el.textContent).includes(needle));
  }
  function isScrollable(el){
    if(!el) return false;
    const s = getComputedStyle(el);
    const oy = s.overflowY;
    return (oy === 'auto' || oy === 'scroll') && el.scrollHeight > el.clientHeight;
  }
  function findScrollContainer(fallbackEl){
    try{
      if (window.PPK_SCROLL_CONTAINER){
        var c = document.querySelector(window.PPK_SCROLL_CONTAINER);
        if (c) return c;
      }
    }catch(e){}
    // fallback: parent scroll container of fallbackEl
    for (let p = fallbackEl && fallbackEl.parentElement; p; p = p.parentElement){
      if (isScrollable(p)) return p;
    }
    return null;
  }
  function findEditorAnchor(){
    try{
      if (window.PPK_EDITOR_SELECTOR){
        var t = document.querySelector(window.PPK_EDITOR_SELECTOR);
        if (t) return t;
      }
    }catch(e){}
    // fallback: toolbar/steuerleiste heurisik
    return byText('div,section,header,nav', 'steuerleiste') ||
           document.querySelector('.toolbar, #toolbar, .topbar, #topbar') ||
           document.body;
  }
  function scrollToAnchor(){
    var target = findEditorAnchor();
    var scroller = findScrollContainer(target) || window;
    var offset = (window.PPK_SCROLL_OFFSET || 90);
    try{
      if (scroller === window){
        var top = target.getBoundingClientRect().top + window.pageYOffset - offset;
        window.scrollTo({ top, behavior:'smooth' });
      } else {
        var r1 = target.getBoundingClientRect();
        var r2 = scroller.getBoundingClientRect();
        var relTop = (r1.top - r2.top) + scroller.scrollTop - (window.PPK_SCROLL_OFFSET || 50);
        scroller.scrollTo({ top: relTop, behavior:'smooth' });
      }
    }catch(e){}
  }

  function attach(){
    var next = $('#btn-abschluss-next') || byText('button, a', 'nächste karte') || byText('button, a', 'weiter');
    var apply = $('#btn-uebernehmen-name') || byText('button, a', 'pflanzennamen übernehmen') || byText('button, a', 'übernehmen') || byText('button, a', 'ok');
    if (!next) return;
    if (next.dataset.v9Wired==='1') return;
    next.dataset.v9Wired='1';

    next.addEventListener('click', function(ev){
      // avoid recursion when we re-trigger
      if (next.dataset.v9Reentry === '1') { next.dataset.v9Reentry = ''; return; }

      // Block default NOW so wir übernehmen vor dem eigentlichen Next
      ev.preventDefault();
      ev.stopImmediatePropagation();

      // 1) Versuche den OK-Button des Dialogs sofort oder sobald er erscheint
      var okClicked = false, kill = null;
      function tryOk(){
        var ok = $('#rb-confirm-ok');
        if (ok){
          try{ ok.click(); okClicked = true; }catch(e){}
          if (kill){ kill(); kill=null; }
        }
      }
      tryOk();
      var mo = new MutationObserver(muts => {
        for(const m of muts){
          if (m.addedNodes && m.addedNodes.length) tryOk();
        }
      });
      mo.observe(document.body, { childList:true, subtree:true });
      kill = function(){ try{ mo.disconnect(); }catch(e){} };

      // 2) Nach kurzem Tick, falls kein Dialog war: Übernehmen klicken
      setTimeout(function(){
        if (!okClicked && apply){ try{ apply.click(); }catch(e){} }
        if (kill) kill();

        // 3) Re-Trigger des "Nächste Karte" Klicks, jetzt darf er laufen
        next.dataset.v9Reentry = '1';
        try { next.click(); } catch(e){ next.dataset.v9Reentry=''; }

        // 4) Scrollen zum Anker
        setTimeout(scrollToAnchor, 60);
        setTimeout(scrollToAnchor, 250);
      }, 200);
    }, true);
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', attach);
  else attach();
})();
</script>
<!-- Style: Käufer-Banner auf 980px zentrieren wie Steuerleiste -->
<script id="ppk-style-buyer-banner">
(function(){
  function norm(s){ return (s||"").replace(/\s+/g,' ').trim().toLowerCase(); }
  function styleBanner(){
    var needles = [
      "kaufmodus – menge wird automatisch gegen deine bestellung geprüft",
      "kaufmodus - menge wird automatisch gegen deine bestellung geprüft"
    ];
    var leafs = Array.from(document.body.querySelectorAll('*')).filter(function(n){ return n.childElementCount===0; });
    for (var i=0;i<leafs.length;i++){
      var n = leafs[i];
      var t = norm(n.textContent||"");
      if (!t) continue;
      for (var j=0;j<needles.length;j++){
        var needle = needles[j];
        if (t.indexOf(needle)!==-1){
          var el = n.parentElement || n;
          try{
            el.style.maxWidth = '980px';
            el.style.width = '980px';
            el.style.marginLeft = 'auto';
            el.style.marginRight = 'auto';
            el.style.boxSizing = 'border-box';
          }catch(e){}
          return;
        }
      }
    }
  }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', styleBanner);
  else styleBanner();
})();
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    if (typeof MODE === 'undefined' || MODE !== 'test') return;
    if (typeof TEST_LIMIT === 'undefined') return;

    function num(v){ v = parseInt(v, 10); return Number.isFinite(v) && v>0 ? v : 0; }

    function totalCardsInCart(){
      // Primary: app kernel
      var items = (typeof window.getCart==='function') ? window.getCart() :
                  (Array.isArray(window.Warenkorb) ? window.Warenkorb : []);
      var total = 0;
      if (Array.isArray(items) && items.length){
        for (var i=0;i<items.length;i++){
          var it = items[i]||{};
          var q = it.qty || it.quantity || (it.meta && it.meta.qty) || 1;
          total += num(q) || 1;
        }
        return total;
      }
      // Fallback: read from DOM (cart table)
      var rows = document.querySelectorAll('.cart-item, .warenkorb-item, [data-cart-row]');
      if (rows.length){
        total = 0;
        rows.forEach(function(r){
          var inp = r.querySelector('input[type="number"], input[name*="qty"], .qty');
          total += num(inp ? (inp.value || inp.getAttribute('value')) : 1) || 1;
        });
        return total;
      }
      return 0;
    }

    function apply(){
      var used = totalCardsInCart();
      var rest = Math.max(0, TEST_LIMIT - used);
      if (typeof setRemaining === 'function') setRemaining(rest);
      var disabled = (rest === 0);
      var btns = document.querySelectorAll('#btn-next-card, .btn-next-card, #btn-new-card, .btn-new-card');
      for (var i=0;i<btns.length;i++){
        btns[i].disabled = disabled;
        btns[i].setAttribute('aria-disabled', String(disabled));
      }
      window.PPK_CAN_START_NEW_CARD = !disabled;
    }

    function focusEditor(){
      var target = document.querySelector('#editor, .editor, #karten-editor, .kartenbereich, .card-workspace, #workspace');
      if (!target) return;
      try { target.scrollIntoView({behavior:'smooth', block:'center'}); } catch(_){
        var y = target.getBoundingClientRect().top + window.pageYOffset - 80;
        window.scrollTo(0, y);
      }
      // Fokus auf das erste sinnvolle Eingabefeld
      setTimeout(function(){
        var inp = target.querySelector('input, textarea, [contenteditable="true"]');
        if (inp && typeof inp.focus==='function') inp.focus();
      }, 300);
    }

    // Hook: wenn "Nächste Karte" geklickt wird und Start erlaubt ist, scrolle zuverlässig zum Editor
    document.addEventListener('click', function(ev){
      var el = ev.target;
      if (!el) return;
      if (el.closest && el.closest('#btn-next-card, .btn-next-card')){
        // nur wenn nicht deaktiviert
        if (el.disabled || el.getAttribute('aria-disabled') === 'true') return;
        // kurze Verzögerung, damit die App ihre neue Karte initialisiert
        setTimeout(focusEditor, 100);
      }
    }, true);

    apply();
    document.addEventListener('ppk:cart:updated', apply);
  }catch(e){ /* silent */ }
});
</script>
<script>
(function(){
  // Robust Editor-Focus nach "Nächste Karte": beobachte DOM-Änderungen im Editorbereich
  var PPK = window.PPK || (window.PPK = {});
  PPK.scrollTries = 0;
  PPK.pendingScroll = false;
  PPK._observer = null;

  function editorRoot(){
    return document.querySelector('#editor, .editor, #karten-editor, .kartenbereich, .card-workspace, #workspace');
  }

  function focusEditorNow(){
    var target = editorRoot();
    if (!target) return false;
    try { target.scrollIntoView({behavior:'smooth', block:'center'}); }
    catch(_){
      var y = target.getBoundingClientRect().top + window.pageYOffset - 80;
      window.scrollTo(0, y);
    }
    var inp = target.querySelector('input, textarea, [contenteditable="true"]');
    if (inp && typeof inp.focus==='function') inp.focus();
    return true;
  }

  function startObserver(){
    if (PPK._observer) return;
    var root = editorRoot();
    if (!root) return;
    PPK._observer = new MutationObserver(function(muts){
      if (!PPK.pendingScroll) return;
      // Sobald Kindknoten geändert wurden, versuchen zu fokussieren
      var ok = focusEditorNow();
      if (ok){
        PPK.pendingScroll = false;
        PPK.scrollTries = 0;
      }
    });
    PPK._observer.observe(root, {childList:true, subtree:true});
  }

  function scheduleRetries(){
    // mehrfach mit Backoff probieren, falls Init asynchron ist
    var delays = [80, 160, 320, 600, 1200];
    delays.forEach(function(ms){
      setTimeout(function(){
        if (!PPK.pendingScroll) return;
        PPK.scrollTries++;
        if (focusEditorNow()){
          PPK.pendingScroll = false;
          PPK.scrollTries = 0;
        }
      }, ms);
    });
  }

  document.addEventListener('click', function(ev){
    var el = ev.target;
    if (!el) return;
    if (el.closest && el.closest('#btn-next-card, .btn-next-card')){
      if (el.disabled || el.getAttribute('aria-disabled') === 'true') return;
      PPK.pendingScroll = true;
      startObserver();
      scheduleRetries();
    }
  }, true);

  // Fallback: wenn App eigene Events feuert
  window.addEventListener('ppk:card:initialized', function(){
    if (!PPK.pendingScroll) return;
    if (focusEditorNow()){
      PPK.pendingScroll = false;
      PPK.scrollTries = 0;
    }
  });
})();
</script>
<script>
(function(){
  // Extend robust scroll to also react after "Karte fertig"
  try{
    var PPK = window.PPK || (window.PPK = {});
    function scheduleEditorFocus(){
      PPK.pendingScroll = true;
      // same retry schedule as for Next
      var delays = [80, 160, 320, 600, 1200];
      delays.forEach(function(ms){
        setTimeout(function(){
          if (!PPK.pendingScroll) return;
          var target = document.querySelector('#editor, .editor, #karten-editor, .kartenbereich, .card-workspace, #workspace');
          if (!target) return;
          try { target.scrollIntoView({behavior:'smooth', block:'center'}); }
          catch(_){
            var y = target.getBoundingClientRect().top + window.pageYOffset - 80;
            window.scrollTo(0, y);
          }
          var inp = target.querySelector('input, textarea, [contenteditable="true"]');
          if (inp && typeof inp.focus==='function') inp.focus();
          // keep pending until we see content changes or cart update
        }, ms);
      });
    }

    // Treat finish clicks as intent to start next editing cycle
    document.addEventListener('click', function(ev){
      var el = ev.target;
      if (!el) return;
      var finishBtn = el.closest && el.closest('#btn-finish-card, .btn-finish-card, button[data-action="finish"], button[name="karte-fertig"], .karte-fertig');
      if (finishBtn){
        scheduleEditorFocus();
      }
    }, true);

    // After cart update (card saved), also try to focus editor
    document.addEventListener('ppk:cart:updated', function(){
      if (!PPK.pendingScroll) return;
      // small delay to allow new-card init
      setTimeout(function(){
        var target = document.querySelector('#editor, .editor, #karten-editor, .kartenbereich, .card-workspace, #workspace');
        if (!target) return;
        try { target.scrollIntoView({behavior:'smooth', block:'center'}); }
        catch(_){
          var y = target.getBoundingClientRect().top + window.pageYOffset - 80;
          window.scrollTo(0, y);
        }
        var inp = target.querySelector('input, textarea, [contenteditable="true"]');
        if (inp && typeof inp.focus==='function') inp.focus();
        // keep pending true until next-card init observer (from previous script) clears it
      }, 120);
    });
  }catch(e){ /* no-op */ }
})();
</script>
<script>
(function(){
  // Editor-Anker: Button "Karte leeren" ist in deinem Editor-Bereich immer vorhanden
  function findEditorContainer(){
    // Suche Button mit Text "Karte leeren"
    var btns = Array.from(document.querySelectorAll('button, .btn, [role="button"]'));
    var clearBtn = btns.find(function(b){
      var t = (b.textContent||'').trim().toLowerCase();
      return t === 'karte leeren' || t.indexOf('karte leeren') !== -1;
    });
    if (clearBtn){
      var host = clearBtn;
      // gehe einige Ebenen hoch bis zum nächstgrößeren Abschnitt
      for (var i=0;i<5 && host && host.parentElement;i++){
        host = host.parentElement;
        if (host.classList && (host.classList.contains('editor') || host.classList.contains('kartenbereich') || host.id === 'editor' || host.id === 'karten-editor')){
          break;
        }
      }
      return host || null;
    }
    // Fallback: bisherige Zoom-100%-Suche
    var zoomBtn = btns.find(b => ((b.textContent||'').trim().toLowerCase() === '100%') || ((b.textContent||'').toLowerCase().indexOf('zoom 100%') !== -1));
    if (zoomBtn){
      var host2 = zoomBtn;
      for (var j=0;j<4 && host2 && host2.parentElement;j++){ host2 = host2.parentElement; }
      return host2 || null;
    }
    // Letzter Fallback: bekannte Selektoren
    return document.querySelector('#editor, .editor, #karten-editor, .kartenbereich, .card-workspace, #workspace');
  }

  function scrollToEditor(){
    var target = findEditorContainer();
    if (!target) return false;
    try { target.scrollIntoView({behavior:'smooth', block:'center'}); }
    catch(_){
      var y = target.getBoundingClientRect().top + window.pageYOffset - 80;
      window.scrollTo(0, y);
    }
    // Fokus
    var inp = target.querySelector('input, textarea, [contenteditable="true"]');
    if (inp && typeof inp.focus==='function') inp.focus();
    return true;
  }

  function triggerScrollWithRetries(){
    var start = Date.now();
    var interval = setInterval(function(){
      if (scrollToEditor()){ clearInterval(interval); return; }
      if (Date.now() - start > 3000){ clearInterval(interval); }
    }, 120);
    scrollToEditor();
  }

  // Trigger an "Nächste Karte" und "Karte fertig"
  document.addEventListener('click', function(ev){
    var el = ev.target;
    if (!el) return;
    if (el.closest && (el.closest('#btn-next-card, .btn-next-card') ||
                       el.closest('#btn-finish-card, .btn-finish-card, button[data-action="finish"], button[name="karte-fertig"], .karte-fertig'))){
      if (el.disabled || el.getAttribute('aria-disabled') === 'true') return;
      setTimeout(triggerScrollWithRetries, 80);
    }
  }, true);

  // Zusätzlich: Wenn Karte wirklich neu initialisiert wurde und App ein Event feuert
  window.addEventListener('ppk:card:initialized', function(){ setTimeout(triggerScrollWithRetries, 50); });
  window.addEventListener('ppk:state:editing', function(){ setTimeout(triggerScrollWithRetries, 50); });
})();
</script>
<script>
// OK-Button: Scroll nach oben (und/oder Editorbereich), robust und minimal-invasiv
(function(){
  function findEditorContainer(){
    // Primär: "Karte leeren"-Anker (sitzt im Editorbereich)
    var btns = Array.from(document.querySelectorAll('button, .btn, [role="button"]'));
    var clearBtn = btns.find(function(b){
      var t = (b.textContent||'').trim().toLowerCase();
      return t === 'karte leeren' || t.indexOf('karte leeren') !== -1;
    });
    if (clearBtn){
      var host = clearBtn;
      for (var i=0;i<5 && host && host.parentElement;i++){
        host = host.parentElement;
        if (host.classList && (host.classList.contains('editor') || host.classList.contains('kartenbereich') || host.id === 'editor' || host.id === 'karten-editor')){
          break;
        }
      }
      return host || null;
    }
    return null;
  }
  function scrollToTopOrEditor(){
    var target = findEditorContainer();
    if (target){
      try { target.scrollIntoView({behavior:'smooth', block:'start'}); }
      catch(_){
        var y = target.getBoundingClientRect().top + window.pageYOffset - 20;
        window.scrollTo(0, y);
      }
    } else {
      window.scrollTo({top: 0, behavior: 'smooth'});
    }
  }
  function queueScroll(){
    // kleine Verzögerung, damit UI nach OK aktualisiert
    setTimeout(scrollToTopOrEditor, 80);
    setTimeout(scrollToTopOrEditor, 180);
    setTimeout(scrollToTopOrEditor, 360);
  }
  // A) Direkt am OK-Button (verschiedene Varianten)
  document.addEventListener('click', function(ev){
    var el = ev.target;
    if (!el) return;
    var okBtn = el.closest && el.closest('#btn-ok, .btn-ok, button[name="ok"], button[data-action="ok"], .karte-ok');
    if (!okBtn){
      // Fallback: textbasierte Erkennung
      if (el.matches && el.matches('button, .btn, [role="button"]')){
        var t = (el.textContent||'').trim().toLowerCase();
        if (t === 'ok' || t === 'karte fertig? ok' || t === 'karte fertig ok' || t === 'fertig ok') okBtn = el;
      }
    }
    if (okBtn){ queueScroll(); }
  }, true);
// C) Falls App eigenes Event feuert
  window.addEventListener('ppk:card:saved', function(){ queueScroll(); });
})();
</script>
<script>
// TESTMODE + generisch (auch für Wix): "Zurück zum Shop" Navigation
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    var params = new URLSearchParams(location.search);
    var isTest = (params.get('mode')||'').toLowerCase()==='test' || (typeof MODE!=='undefined' && MODE==='test');

    function isBackToShopButton(el){
      if (!el) return false;
      if (el.matches && el.matches('#btn-back-shop, .btn-back-shop, button[name="back-shop"], button[data-action="back-shop"], .zurueck-shop, .zurück-shop')) return true;
      var t = (el.textContent||'').trim().toLowerCase();
      return t === 'zurück zum shop' || (t.indexOf('zurück')!==-1 && t.indexOf('shop')!==-1) || t.indexOf('zum shop')!==-1;
    }

    function normalizeUrl(u){
      try { return new URL(u, location.href).href; } catch(e){ return null; }
    }

    function targetFromParam(){
      var p = params.get('shop') || params.get('return');
      if (!p) return null;
      return normalizeUrl(p);
    }

    function targetFromReferrer(){
      if (!document.referrer) return null;
      return document.referrer;
    }

    async function tryCandidates(){
      const here = new URL(location.href);
      const basePaths = [
        here.origin + here.pathname.replace(/[^\\/]*$/, ''),
        new URL('..', here.href).href,
        here.origin + '/'
      ];
      const files = [
        'etsy_shop_localhost_stabil.html',
        'etsy_shop.html',
        'shop.html',
        'index.html'
      ];
      for (const b of basePaths){
        for (const f of files){
          const href = new URL(f, b).href;
          try { const res = await fetch(href, {method:'HEAD', cache:'no-store'}); if (res.ok) return href; } catch(_){}
        }
      }
      return null;
    }

    async function computeTarget(){
      return targetFromParam() || targetFromReferrer() || await tryCandidates();
    }

    async function goShop(){
      const tgt = await computeTarget();
      if (tgt){
        try {
          // Wenn im iFrame (Wix), navigiere die Top-Seite
          if (window.top && window.top!==window) { window.top.location.href = tgt; }
          else if (window.opener && !window.opener.closed){ window.location.href = tgt; }
          else { window.location.assign(tgt); }
        } catch(e){
          // Fallback
          window.location.href = tgt;
        }
      } else {
        history.back();
      }
    }

    document.addEventListener('click', function(ev){
      const el = ev.target;
      if (!el) return;
      const btn = el.closest && el.closest('button, a, .btn, [role="button"]');
      if (btn && isBackToShopButton(btn)){
        ev.preventDefault();
        ev.stopPropagation();
        goShop();
      }
    }, true);

    // Optional: auch Enter auf fokussiertem Back-Button abfangen
    document.addEventListener('keydown', function(ev){
      if (ev.key !== 'Enter') return;
      const el = document.activeElement;
      if (el && isBackToShopButton(el)){
        ev.preventDefault();
        goShop();
      }
    });
  }catch(e){ /* no-op */ }
});
</script>
<script>
// Testmodus: Bei 3 Karten -> Checkout-Button ausblenden, Hinweis mit Rücksprung zeigen
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    var params = new URLSearchParams(location.search);
    var isTest = (params.get('mode')||'').toLowerCase()==='test' || (typeof MODE!=='undefined' && MODE==='test');
    if (!isTest) return;

    function num(v){ v = parseInt(v,10); return (Number.isFinite(v) && v>0) ? v : 0; }
    function totalCardsInCart(){
      var items = (typeof window.getCart==='function') ? window.getCart() :
                  (Array.isArray(window.Warenkorb) ? window.Warenkorb : []);
      var total = 0;
      if (Array.isArray(items) && items.length){
        for (var i=0;i<items.length;i++){
          var it = items[i]||{};
          var q = it.qty || it.quantity || (it.meta && it.meta.qty) || 1;
          total += num(q) || 1;
        }
        return total;
      }
      // DOM-Fallback
      var rows = document.querySelectorAll('.cart-item, .warenkorb-item, [data-cart-row]');
      if (rows.length){
        total = 0;
        rows.forEach(function(r){
          var inp = r.querySelector('input[type="number"], input[name*="qty"], .qty');
          total += num(inp ? (inp.value || inp.getAttribute('value')) : 1) || 1;
        });
        return total;
      }
      return 0;
    }

    // Back-to-shop target resolution (same as WIX_READY)
    function normalizeUrl(u){ try { return new URL(u, location.href).href; } catch(e){ return null; } }
    function targetFromParam(){
      var p = params.get('shop') || params.get('return');
      if (!p) return null;
      return normalizeUrl(p);
    }
    async function tryCandidates(){
      const here = new URL(location.href);
      const basePaths = [
        here.origin + here.pathname.replace(/[^\\/]*$/, ''),
        new URL('..', here.href).href,
        here.origin + '/'
      ];
      const files = ['etsy_shop_localhost_stabil.html','etsy_shop.html','shop.html','index.html'];
      for (const b of basePaths){
        for (const f of files){
          const href = new URL(f, b).href;
          try { const res = await fetch(href,{method:'HEAD',cache:'no-store'}); if (res.ok) return href; } catch(_){}
        }
      }
      return null;
    }
    async function computeTarget(){ return targetFromParam() || document.referrer || await tryCandidates(); }
    async function goShop(){
      const tgt = await computeTarget();
      if (tgt){
        try{
          if (window.top && window.top!==window) window.top.location.href = tgt;
          else window.location.assign(tgt);
        }catch(e){ window.location.href = tgt; }
      } else { history.back(); }
    }

    // Find Checkout button (green "Bestellung aufgeben")
    function findCheckoutButton(){
      var btn = document.querySelector('#btn-checkout, .btn-checkout, button[name="checkout"], button[data-action="checkout"], .bestellung-aufgeben');
      if (btn) return btn;
      // text-based
      var cands = Array.from(document.querySelectorAll('button, .btn, [role="button"]'));
      return cands.find(function(b){ return ((b.textContent||'').trim().toLowerCase() === 'bestellung aufgeben'); }) || null;
    }

    // Create notice element styled similar to existing UI (neutral box + button)
    



function ensureNotice(beforeEl){
  var ex = document.getElementById('ppk-testlimit-notice');
  if (ex) return ex;

  var box = document.createElement('div');
  box.id = 'ppk-testlimit-notice';
  box.setAttribute('role','alert');
  box.style.cssText = [
    'margin:18px 0 18px',
    'padding:16px 18px',
    'border-radius:16px',
    'background:#fffbe6',
    'border:2px solid #8b1a1a',
    'box-shadow:0 2px 6px rgba(0,0,0,.08)',
    'display:flex',
    'flex-direction:column',
    'align-items:flex-start',
    'gap:12px',
    'width:100%',
    'max-width:620px',
    'clear:both',
    'position:relative',
    'z-index:0'
  ].join(';');

  var msg = document.createElement('div');
  msg.textContent = 'Es liegen jetzt 3 Testkarten im Warenkorb. Gehe zurück zum Shop.';
  msg.style.cssText = [
    'font-weight:600',
    'line-height:1.35',
    'white-space:normal'
  ].join(';');

  var link = document.createElement('button');
  link.type = 'button';
  link.textContent = 'Zurück zum Shop';
  link.style.cssText = [
    'padding:12px 18px',
    'height:44px',
    'border-radius:12px',
    'border:2px solid #0a7',
    'background:#0b8',
    'color:#fff',
    'font-weight:700',
    'cursor:pointer',
    'white-space:nowrap',
    'min-width:200px',
    'text-align:center',
    'align-self:flex-start',
    'box-shadow:0 1px 0 rgba(0,0,0,.05), inset 0 -2px 0 rgba(0,0,0,.08)',
    'transition:transform .05s ease'
  ].join(';');
  link.addEventListener('mouseenter', function(){ link.style.transform = 'translateY(-1px)'; });
  link.addEventListener('mouseleave', function(){ link.style.transform = 'translateY(0)'; });
  link.addEventListener('click', function(ev){ ev.preventDefault(); goShop(); });

  box.appendChild(msg);
  box.appendChild(link);

  var parent = beforeEl && beforeEl.parentNode ? beforeEl.parentNode : document.body;
  if (beforeEl) parent.insertBefore(box, beforeEl);
  else parent.appendChild(box);

  // --- NEU: Oberkante an ersten gelben Button angleichen ---
  function firstYellowButton(){
    // Textbasierte Suche nach "Warenkorb-Link kopieren" etc.
    var btns = Array.from(document.querySelectorAll('button, .btn, [role="button"]'));
    var candidate = btns.find(function(b){
      var t = (b.textContent||'').trim().toLowerCase();
      return t.indexOf('warenkorb-link kopieren') !== -1
          || t.indexOf('warenkorb leeren') !== -1
          || b.classList.contains('yellow') || b.classList.contains('btn-yellow');
    });
    return candidate || null;
  }

  function alignTop(){
    var y = firstYellowButton();
    if (!y) return;
    var r1 = box.getBoundingClientRect();
    var r2 = y.getBoundingClientRect();
    var delta = Math.round(r2.top - r1.top);
    // aktuelle margin-top auslesen (px) und anpassen
    var mt = parseInt((box.style.marginTop || '18').toString(), 10) || 18;
    box.style.marginTop = (mt + delta) + 'px';
  }

  // nach Layout-Berechnung ausführen und bei Resize/Scroll erneut
  requestAnimationFrame(function(){ requestAnimationFrame(alignTop); });
  window.addEventListener('resize', alignTop);
  window.addEventListener('orientationchange', alignTop);

  return box;
}





    function apply(){
      var count = totalCardsInCart();
      var checkout = findCheckoutButton();
      if (!checkout) return;
      if (count >= 3){
        checkout.style.display = 'none';
        ensureNotice(checkout);
      } else {
        checkout.style.display = '';
        var ex = document.getElementById('ppk-testlimit-notice');
        if (ex && ex.parentNode) ex.parentNode.removeChild(ex);
      }
    }

    apply();
    document.addEventListener('ppk:cart:updated', apply);
  }catch(e){ /* no-op */ }
});
</script>
<script>
// Testmodus: Buttons "Nächste Karte" und "In den Warenkorb" sperren, solange 3 Karten im Warenkorb liegen
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    var params = new URLSearchParams(location.search);
    var isTest = (params.get('mode')||'').toLowerCase()==='test' || (typeof MODE!=='undefined' && MODE==='test');
    if (!isTest) return;

    function num(v){ v = parseInt(v,10); return (Number.isFinite(v) && v>0) ? v : 0; }
    function totalCardsInCart(){
      var items = (typeof window.getCart==='function') ? window.getCart() :
                  (Array.isArray(window.Warenkorb) ? window.Warenkorb : []);
      var total = 0;
      if (Array.isArray(items) && items.length){
        for (var i=0;i<items.length;i++){
          var it = items[i]||{};
          var q = it.qty || it.quantity || (it.meta && it.meta.qty) || 1;
          total += num(q) || 1;
        }
        return total;
      }
      // DOM-Fallback
      var rows = document.querySelectorAll('.cart-item, .warenkorb-item, [data-cart-row]');
      if (rows.length){
        total = 0;
        rows.forEach(function(r){
          var inp = r.querySelector('input[type="number"], input[name*="qty"], .qty');
          total += num(inp ? (inp.value || inp.getAttribute('value')) : 1) || 1;
        });
        return total;
      }
      return 0;
    }

    function setLocked(locked){
      var nextSel = '#btn-next-card, .btn-next-card, button[name="next-card"], [data-action="next-card"]';
      var cartSel = '#btn-add-to-cart, .btn-add-to-cart, .btn-add, button[name="add-to-cart"], [data-action="add-to-cart"], .in-den-warenkorb';
      var nodes = document.querySelectorAll(nextSel + ', ' + cartSel);
      nodes.forEach(function(btn){
        if (!btn) return;
        btn.disabled = !!locked;
        btn.setAttribute('aria-disabled', locked ? 'true' : 'false');
        if (locked) {
          btn.classList.add('ppk-disabled');
          btn.title = 'Testlimit erreicht (3 Karten). Bitte zurück zum Shop.';
        } else {
          btn.classList.remove('ppk-disabled');
          if (btn.title === 'Testlimit erreicht (3 Karten). Bitte zurück zum Shop.') btn.removeAttribute('title');
        }
      });
    }

    function applyLock(){
      var used = totalCardsInCart();
      var locked = used >= 3;
      setLocked(locked);
      if (typeof setRemaining==='function' && typeof TEST_LIMIT!=='undefined'){
        var rest = Math.max(0, TEST_LIMIT - used);
        setRemaining(rest);
      }
    }

    // Blockierende Klicks frühzeitig abfangen
    document.addEventListener('click', function(ev){
      var el = ev.target && ev.target.closest ? ev.target.closest('button, [role="button"]') : null;
      if (!el) return;
      var isTarget = el.matches('#btn-next-card, .btn-next-card, button[name="next-card"], [data-action="next-card"]') ||
                     el.matches('#btn-add-to-cart, .btn-add-to-cart, .btn-add, button[name="add-to-cart"], [data-action="add-to-cart"], .in-den-warenkorb');
      if (isTarget && (el.disabled || el.getAttribute('aria-disabled')==='true')){
        ev.preventDefault(); ev.stopPropagation();
        if (typeof toast==='function') toast('Testlimit 3 erreicht. Bitte zurück zum Shop.');
        return false;
      }
    }, true);

    // Optische Deaktivierung
    var style = document.createElement('style');
    style.textContent = '.ppk-disabled{opacity:.55; cursor:not-allowed !important;}';
    document.head.appendChild(style);

    applyLock();
    document.addEventListener('ppk:cart:updated', applyLock);
  }catch(e){ /* no-op */ }
});
</script>
<script>window.__PPK_SIMPLE_BACK = true;</script>
<script>
// Simple Back-to-Shop: prefer referrer/history; fallback to local files. Wix-safe (navigates window.top).
document.addEventListener('DOMContentLoaded', function () {
  function isBackBtn(el) {
    if (!el) return false;
    if (el.matches && el.matches('#btn-back-shop, .btn-back-shop, .zurueck-shop, .zurück-shop')) return true;
    const t = (el.textContent || '').replace(/\s+/g, ' ').trim().toLowerCase();
    return t.includes('zurück zum shop');
  }
  function goBackToShop() {
    var ref = (document.referrer || '').trim();
    if (!ref || ref === 'null' || ref === 'undefined') ref = '';
    if (ref) {
      try { (window.top && window.top !== window ? window.top : window).location.href = ref; }
      catch (e) { location.href = ref; }
      return;
    }
    if (history.length > 1) {
      try { (window.top && window.top !== window ? window.top.history : history).back(); return; }
      catch (e) { /* fall through */ }
    }
    const files = ['etsy_shop_localhost_stabil.html', 'index.html'];
    for (const f of files) {
      try { location.assign(new URL(f, location.href)); return; } catch (_) {}
    }
  }
  document.addEventListener('click', function (ev) {
    const el = ev.target && ev.target.closest ? ev.target.closest('button, a, [role="button"]') : null;
    if (!el) return;
    if (isBackBtn(el)) { ev.preventDefault(); ev.stopPropagation(); goBackToShop(); }
  }, true);
});
</script>
<script>
// Sichtbarkeits-Limiter (UI-only): versteckt "Nächste Karte" & "In den Warenkorb" und deckelt Mengen-Inputs
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  var params = new URLSearchParams(location.search);
  var MODE = (params.get('mode')||'').toLowerCase();
  var isTest = MODE === 'test';
  var ENABLE_IN_BUYER = false; // auf true setzen, wenn auch im Käufermodus aktiv sein soll

  if (!isTest && !ENABLE_IN_BUYER) return;

  var LIMIT = 3; // Testlimit

  // --- Hilfsfunktionen ---
  function num(v){ v = parseInt(v,10); return (Number.isFinite(v)&&v>0)?v:0; }
  function getCartItems(){
    try { if (typeof window.getCart==='function') return window.getCart()||[]; } catch(_){}
    if (Array.isArray(window.Warenkorb)) return window.Warenkorb;
    return [];
  }
  function totalQty(items){
    var a = items || getCartItems(), t = 0;
    for (var i=0;i<a.length;i++){
      var it=a[i]||{}; var q = it.qty||it.quantity||(it.meta&&it.meta.qty)||1; t += num(q)||1;
    }
    return t;
  }
  function remaining(){ return Math.max(0, LIMIT - totalQty()); }

  var selNext = '#btn-next-card, .btn-next-card, button[name="next-card"], [data-action="next-card"]';
  var selAdd  = '#btn-add-to-cart, .btn-add-to-cart, .btn-add, button[name="add-to-cart"], [data-action="add-to-cart"], .in-den-warenkorb';
  var selQty  = 'input[type="number"][name*="qty"], input[type="number"].qty, input[type="number"][id*="menge"], input[name="menge"]';

  // kleine CSS-Helfer
  (function(){
    var s=document.createElement('style'); s.textContent = '.ppk-hidden{display:none!important}.ppk-muted{opacity:.55;pointer-events:none!important;cursor:not-allowed!important}';
    document.head.appendChild(s);
  })();

  function applyUI(){
    var rest = remaining();

    // Banner Rest aktualisieren, falls Funktion vorhanden
    try{ if (typeof setRemaining==='function') setRemaining(rest); }catch(_){}

    var nextBtns = document.querySelectorAll(selNext);
    var addBtns  = document.querySelectorAll(selAdd);
    var qtyNodes = document.querySelectorAll(selQty);

    if (rest <= 0){
      nextBtns.forEach(function(b){ b && b.classList.add('ppk-hidden'); });
      addBtns.forEach(function(b){ b && b.classList.add('ppk-hidden'); });
      qtyNodes.forEach(function(inp){
        if (!inp) return;
        inp.value = String(Math.min(num(inp.value||1), 1));
        inp.setAttribute('max','1');
        inp.classList.add('ppk-muted');
      });
    } else {
      nextBtns.forEach(function(b){ b && b.classList.remove('ppk-hidden'); });
      addBtns.forEach(function(b){ b && b.classList.remove('ppk-hidden'); });
      qtyNodes.forEach(function(inp){
        if (!inp) return;
        inp.removeAttribute('max');
        inp.classList.remove('ppk-muted');
      });
    }
  }

  // Fallback: Klicks trotzdem abbrechen, falls ein Button später erscheint und noch nicht versteckt wurde
  document.addEventListener('click', function(ev){
    var el = ev.target && ev.target.closest ? ev.target.closest('button, [role="button"]') : null;
    if (!el) return;
    if (remaining()<=0 && (el.matches(selNext) || el.matches(selAdd))){
      ev.preventDefault(); ev.stopPropagation();
      return false;
    }
  }, true);

  // Initial und bei Warenkorb-Änderungen
  applyUI();
  document.addEventListener('ppk:cart:updated', applyUI);
  // und ein paar Nachläufe, falls UI verspätet rendert
  setTimeout(applyUI, 100);
  setTimeout(applyUI, 400);
  setTimeout(applyUI, 1200);
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  var params = new URLSearchParams(location.search);
  var MODE = (params.get('mode')||'').toLowerCase();
  var isTest = MODE === 'test';
  if (!isTest) return;

  var LIMIT = 3;

  function num(v){ v = parseInt(v,10); return (Number.isFinite(v)&&v>0)?v:0; }

  function cartRows(){
    // generische Suche: jede Zeile mit "Entfernen"-Button oder qty-Input zählt als Warenkorb-Zeile
    var rows = Array.from(document.querySelectorAll('.warenkorb-row, [data-cart-row]'));
    if (rows.length) return rows;
    // Fallback: Heuristik über Buttons "Entfernen"
    var removes = Array.from(document.querySelectorAll('button, [role="button"]')).filter(function(b){
      return ((b.textContent||'').trim().toLowerCase()==='entfernen');
    });
    return removes.map(function(b){ return b.closest('tr, li, div') || b.parentElement; }).filter(Boolean);
  }

  function totalQty(){
    var rows = cartRows();
    if (!rows.length) return 0;
    var sum = 0;
    rows.forEach(function(r){
      var inp = r.querySelector('input[type="number"], input[name*="qty"], .qty');
      var q = inp ? num(inp.value || inp.getAttribute('value') || 1) : 1;
      sum += q || 1;
    });
    return sum;
  }

  function remaining(){ return Math.max(0, LIMIT - totalQty()); }

  // --- GLOBAL BLOCKER ---
  function shouldBlock(el){
    if (remaining() > 0) return false;
    if (!el) return true;
    var txt = ((el.textContent||'') + ' ' + (el.getAttribute('name')||'') + ' ' + (el.getAttribute('data-action')||'')).toLowerCase();
    // typische Auslöser
    return txt.includes('in den warenkorb') || txt.includes('add-to-cart') ||
           txt.includes('karte fertig') || txt.includes('finish') ||
           txt.includes('nächste karte') || txt.includes('next-card') ||
           txt.includes('import');
  }

  // Klicks abfangen (capturing)
  document.addEventListener('click', function(ev){
    var el = ev.target && ev.target.closest ? ev.target.closest('button, a, [role="button"], input[type="submit"]') : null;
    if (shouldBlock(el)){ ev.preventDefault(); ev.stopPropagation(); return false; }
  }, true);

  // Form-Submit abfangen
  document.addEventListener('submit', function(ev){
    if (remaining()<=0){ ev.preventDefault(); ev.stopPropagation(); return false; }
  }, true);

  // Enter-Key auf Inputs abfangen
  document.addEventListener('keydown', function(ev){
    if (ev.key !== 'Enter') return;
    if (remaining()<=0){ ev.preventDefault(); ev.stopPropagation(); return false; }
  }, true);

  // --- AUTO-TRIM via "Entfernen" Buttons (DOM) ---
  function trimDOM(){
    var over = totalQty() - LIMIT;
    if (over <= 0) return;
    var rows = cartRows();
    // von unten nach oben entfernen / reduzieren
    for (var i=rows.length-1; i>=0 && over>0; i--){
      var r = rows[i];
      var inp = r.querySelector('input[type="number"], input[name*="qty"], .qty');
      if (inp){
        var q = num(inp.value || inp.getAttribute('value') || 1);
        if (q > 1){
          var take = Math.min(q-1, over);
          var newQ = q - take;
          inp.value = String(newQ);
          // Trigger change falls nötig
          inp.dispatchEvent(new Event('input', {bubbles:true}));
          inp.dispatchEvent(new Event('change', {bubbles:true}));
          over -= take;
          continue;
        }
      }
      var rm = Array.from(r.querySelectorAll('button, [role="button"]')).find(function(b){ return ((b.textContent||'').trim().toLowerCase()==='entfernen'); });
      if (rm){ rm.click(); over -= 1; }
    }
  }

  // Laufende Überwachung: bei Updates und in Intervallen
  function enforce(){
    // Hebel 1: UI-hide (existiert bereits in dieser Datei)
    // Hebel 2: harte DOM-Trim als Notbremse
    trimDOM();
  }

  document.addEventListener('ppk:cart:updated', function(){ setTimeout(enforce, 0); });
  setInterval(enforce, 400); // Notbremse, falls Events fehlen
});
</script>
<style id="ppk-limit-indicator-style">
#ppk-limit-indicator {
  /* In der Wix‑Variante vollständig ausgeblendet */
  display:none !important;
  padding:8px 14px;
  border-radius:14px;
  font-weight:800;
  color:#fff;
  background:#8b1a1a;          /* weinrot */
  border:2px solid #6d1414;
  box-shadow:0 1px 4px rgba(0,0,0,.15);
  margin-left:8px;
  white-space:nowrap;
}
#ppk-top-banner-slot {
  /* Slot für Limit‑Badge in Wix unsichtbar halten */
  display:none !important;
  align-items:center;
  gap:8px;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  try{
    // Try to find the top banner (where "Testmodus …" and "Zurück zum Shop" stehen)
    function findBanner(){
      // Heuristik: das erste DIV/SECTION mit "Testmodus" drin
      var nodes = Array.from(document.querySelectorAll('div,section,header'));
      for (var i=0;i<nodes.length;i++){
        var t = (nodes[i].textContent||'').toLowerCase();
        if (t.includes('testmodus') && t.includes('karten')) return nodes[i];
      }
      // Fallback: body
      return document.body;
    }

    var banner = findBanner();
    // Make a small slot on the right side of the banner to hold our badge.
    // We try to append near the existing "Zurück zum Shop"-Button; otherwise append at the end.
    var slot = document.createElement('span');
    slot.id = 'ppk-top-banner-slot';
    var badge = document.createElement('span');
    badge.id = 'ppk-limit-indicator';
    badge.setAttribute('role','status');
    badge.setAttribute('aria-live','polite');
    badge.textContent = 'Limit erreicht: 0 verfügbar';
    slot.appendChild(badge);

    // Try to place just before the back-to-shop button
    var backBtn = Array.from(banner.querySelectorAll('button, a, [role="button"]')).find(function(el){
      var t = (el.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
      return t.includes('zurück zum shop');
    });
    banner.appendChild(slot);

    function showLimit(n){
      if (typeof n!=='number') n = parseInt(n,10)||0;
      if (n<=0){
        badge.style.display = 'inline-block';
        badge.textContent = 'Limit erreicht: 0 verfügbar';
      } else {
        badge.style.display = 'none';
      }
    }

    // Hook setRemaining if present
    if (typeof window.setRemaining === 'function'){
      var _orig = window.setRemaining;
      window.setRemaining = function(n){
        try{ showLimit(Number(n)||0); }catch(e){}
        return _orig.apply(this, arguments);
      };
    }

    // Also recompute from DOM if needed
    function parseRemainingFromText(){
      // Look for "Verfügbar:" text anywhere in the banner
      var m = (banner.textContent||'').match(/Verfügbar:\s*(\d+)/i);
      return m ? parseInt(m[1],10) : null;
    }

    function refresh(){
      var n = parseRemainingFromText();
      if (n==null) return; // unknown, do not change
      showLimit(n);
    }

    // Initial check
    setTimeout(refresh, 0);
    // On cart updates, re-check
    document.addEventListener('ppk:cart:updated', function(){ setTimeout(refresh, 0); });
  }catch(e){ /* no-op */ }
});
</script>
<style>
/* Testmodus: Preise/Summen ausblenden */
.ppk-hide-testprice { display: none !important; }
</style>
<script>
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  var params = new URLSearchParams(location.search);
  var isTest = (params.get('mode')||'').toLowerCase()==='test';
  if (!isTest) return;

  function hide(el){ if (el) el.classList.add('ppk-hide-testprice'); }
  function isSmallText(el){
    var t = (el.textContent||'').replace(/\s+/g,' ').trim();
    return t.length <= 40;
  }

  // 1) Pro-Zeile die €-Beträge ausblenden (rechte Spalte)
  Array.from(document.querySelectorAll('td, th, span, small, strong, em, div')).forEach(function(el){
    var txt = (el.textContent||'').replace(/\s+/g,' ').trim();
    var low = txt.toLowerCase();
    if (!txt) return;
    if (txt.includes('€') && isSmallText(el)){
      hide(el);
    }
  });

  // 2) Summenzeile „Summe (Bezahlung über Etsy): …“ komplett ausblenden
  var sumNode = Array.from(document.querySelectorAll('*')).find(function(el){
    var t = (el.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
    return t.startsWith('summe (bezahlung über etsy)');
  });
  if (sumNode){
    // bis zum nächstgrößeren Block-Container hochgehen
    var container = sumNode.closest('p, div, section, footer') || sumNode;
    hide(container);
  }

  // 3) Grünen "Bestellung aufgeben"-Button im Testmodus ausblenden (falls vorhanden)
  Array.from(document.querySelectorAll('button, a, [role="button"]')).forEach(function(b){
    var t = (b.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
    if (t === 'bestellung aufgeben' || t.includes('bestellung aufgeben')) hide(b);
  });
});
</script>
<script id="ppk-buyer-limit-only-v2">
(function(){
  try{
    var qs = new URLSearchParams(location.search||"");
    if ((qs.get("mode")||"").toLowerCase() !== "buyer") return;

    var cap = parseInt(qs.get("qty")||"0",10);
    if (!Number.isFinite(cap) || cap < 0) cap = 0;

    function sum(items){
      if (!Array.isArray(items)) return 0;
      var s = 0;
      for (var i=0;i<items.length;i++){
        var q = parseInt((items[i] && items[i].qty) || 0, 10);
        if (Number.isFinite(q)) s += q;
      }
      return s;
    }
    function getUsed(){
      try{ if (typeof window.getCart === 'function') return sum(window.getCart()); }catch(_){}
      try{ if (Array.isArray(window.cart)) return sum(window.cart); }catch(_){}
      return 0;
    }
    function apply(used){
      if (typeof used !== 'number') used = getUsed();
      var remaining = Math.max(0, cap - used);
      if (typeof window.setRemaining === 'function'){
        window.setRemaining(remaining);
      } else {
        var el = document.getElementById('ppk-remaining');
        if (el) el.textContent = String(remaining);
      }
    }

    // initial draw
    apply();

    // mirror tester flow: react to canonical cart event
    document.addEventListener('ppk:cart:updated', function(ev){
      try{
        var items = ev && ev.detail && ev.detail.items;
        apply(sum(items));
      }catch(_){ apply(); }
    });

    // gentle sync fallback
    setInterval(function(){ apply(); }, 1500);
  }catch(e){ console.warn('ppk-buyer-limit-only-v2 error:', e); }
})();
</script>
<script id="ppk-buyer-smooth-v1">
(function(){
  try{
    var qs = new URLSearchParams(location.search||"");
    if ((qs.get("mode")||"").toLowerCase() !== "buyer") return;
    var cap = parseInt(qs.get("qty")||"0",10);
    if (!Number.isFinite(cap) || cap < 0) cap = 0;

    function sum(items){
      if (!Array.isArray(items)) return 0;
      var s=0; for (var i=0;i<items.length;i++){ var q=parseInt((items[i]&&items[i].qty)||0,10); if(Number.isFinite(q)) s+=q; }
      return s;
    }
    function getUsed(){
      try{ if (typeof window.getCart==='function') return sum(window.getCart()); }catch(_){}
      try{ if (Array.isArray(window.cart)) return sum(window.cart); }catch(_){}
      return 0;
    }

    var lastShown = null;
    var zeroTimer = null;
    var rafId = null;
    function renderSmart(nextVal){
      // Coalesce frequent updates
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(function(){
        // Suppress transient zero: require confirmation after 120ms
        if (nextVal === 0 && lastShown !== 0){
          clearTimeout(zeroTimer);
          zeroTimer = setTimeout(function(){
            apply(nextVal);
          }, 120);
        } else {
          clearTimeout(zeroTimer);
          apply(nextVal);
        }
      });
    }

    function apply(val){
      lastShown = val;
      // Use your existing UI if available
      if (typeof window.setRemaining === 'function'){
        try{ window.setRemaining(val); }catch(_){}
      } else {
        var el = document.getElementById('ppk-remaining');
        if (el) el.textContent = String(val);
        var pill = document.getElementById('ppk-limit-indicator');
        if (pill) pill.style.display = (val === 0 ? 'inline-block' : 'none');
        document.documentElement.classList.toggle('buyer-quota-met', val === 0);
      }
    }

    function computeAndRender(fromItems){
      var used = (Array.isArray(fromItems) ? sum(fromItems) : getUsed());
      var remaining = Math.max(0, cap - used);
      renderSmart(remaining);
    }

    // Initial (defer to let tester logic settle)
    setTimeout(function(){ computeAndRender(); }, 50);

    // Use the canonical event payload first
    document.addEventListener('ppk:cart:updated', function(ev){
      try{
        var items = ev && ev.detail && ev.detail.items;
        computeAndRender(items);
      }catch(_){ computeAndRender(); }
    });

    // Gentle fallback
    setInterval(function(){ computeAndRender(); }, 1200);
  }catch(e){ console.warn('ppk-buyer-smooth-v1 error:', e); }
})();
</script>
<script id="ppk-buyer-scroll-behavior-v1">
(function(){
  try{
    var qs = new URLSearchParams(location.search||"");
    if ((qs.get("mode")||"").toLowerCase() !== "buyer") return;

    function isBtn(el, pattern){
      if (!el) return false;
      var txt = (el.textContent || el.innerText || "").trim().toLowerCase();
      return pattern.test(txt);
    }
    function findEditorAnchor(){
      return document.querySelector('#editor, #designer, #konfigurator-editor, [data-section="editor"], [data-anchor="editor"]');
    }

    // 1) Keep viewport on "In den Warenkorb"
    document.addEventListener('click', function(ev){
      var target = ev.target && ev.target.closest ? ev.target.closest('button, a, [role="button"]') : null;
      if (!target) return;
      if (isBtn(target, /(in den warenkorb|add to cart|zum warenkorb)/i)){
        var y = window.scrollY || window.pageYOffset || 0;
        // Let the original handlers run, but restore scroll a few times to fight programmatic jumps
        setTimeout(function(){ window.scrollTo(0, y); }, 0);
        setTimeout(function(){ window.scrollTo(0, y); }, 150);
        setTimeout(function(){ window.scrollTo(0, y); }, 400);
      }
    }, true);

    // 2) Scroll to editor on "Nächste Karte"
    document.addEventListener('click', function(ev){
      var target = ev.target && ev.target.closest ? ev.target.closest('button, a, [role="button"]') : null;
      if (!target) return;
      if (isBtn(target, /(nächste karte|naechste karte|next card)/i)){
        var anchor = findEditorAnchor();
        if (anchor){
          ev.preventDefault();
          try{ anchor.scrollIntoView({behavior:'smooth', block:'start'}); }
          catch(_){ anchor.scrollIntoView(); }
        }
      }
    }, true);
  }catch(e){ console.warn('ppk-buyer-scroll-behavior-v1 error:', e); }
})();
</script>
<script id="ppk-mode-flag-v1">
(function(){
  try{
    var p = new URLSearchParams(location.search||"");
    var mode = (p.get("mode")||"").toLowerCase();
    document.documentElement.classList.toggle('mode-buyer', mode === 'buyer');
    document.documentElement.classList.toggle('mode-test',  mode === 'test');
  }catch(e){}
})();
</script>
<script id="ppk-buyer-code-unlock-inline">
(function(){ 
  if (window.__ppkUnlockInit) return; window.__ppkUnlockInit = true;
  try{
    var qs = new URLSearchParams(location.search||"");
    if((qs.get("mode")||"").toLowerCase()!=="buyer") return;
    var cap = parseInt(qs.get("qty")||"0",10);
    if(Number.isFinite(cap) && cap>0) return;

    var bar=document.createElement('div');
    bar.id='ppk-unlock-bar';
    bar.style.cssText='position:sticky;top:0;z-index:9999;background:#eef6ff;border-bottom:1px solid #cfe0ff;padding:10px 14px;display:flex;gap:8px;align-items:center;font:14px system-ui';
    bar.innerHTML='<strong style="margin-right:6px;">Bestellnummer prüfen:</strong>'+
      '<input id="ppk-unlock-input" type="text" placeholder="z. B. 123456789" style="flex:0 0 240px;padding:6px 8px;border:1px solid #b6c9ff;border-radius:6px" />'+
      '<button id="ppk-unlock-btn" type="button" style="padding:6px 10px;border:0;border-radius:6px;background:#0a7;color:#fff;font-weight:600;cursor:pointer">Prüfen</button>'+
      '<span id="ppk-unlock-msg" style="margin-left:8px;color:#334;opacity:.9"></span>';
    (document.body||document.documentElement).insertBefore(bar, (document.body||document.documentElement).firstChild);

    var inp=document.getElementById('ppk-unlock-input'); var btn=document.getElementById('ppk-unlock-btn'); var msg=document.getElementById('ppk-unlock-msg');
    var preset=(qs.get('order')||'').trim(); if(preset) inp.value=preset;
    function say(s,ok){ msg.textContent=s||''; msg.style.color=ok?'#065':'#a11'; }

    var CHECK_URL='https://script.google.com/macros/s/AKfycbzYcJ8h49o7j-HinFB06rAVpJV7ypaYqxHGKX9O0kHjMQ0ecSXDsglFlOdb3kHmaGpV9g/exec'; var API_KEY='Jo0Hi3ha0nt0nn6en2a0na0ch2';
    function buildCheckUrl(ord){
      try{ var u=new URL(CHECK_URL); u.searchParams.set('op','check'); u.searchParams.set('key',API_KEY); u.searchParams.set('order',ord); return u.toString(); }
      catch(_ ){ return CHECK_URL+'?op=check&key='+encodeURIComponent(API_KEY)+'&order='+encodeURIComponent(ord); }
    }
    function pickCap(txt){
      try{ var j=JSON.parse(txt); var cand=['available','qty','cap','limit','max','qty_total']; for(var i=0;i<cand.length;i++){ var n=parseInt(j[cand[i]],10); if(Number.isFinite(n)&&n>0) return n; } }catch(_ ){}
      var m=String(txt||'').match(/(?:available|qty|cap|limit|max)\s*[:=]\s*(\d{1,3})/i)||String(txt||'').match(/\b(\d{1,3})\s*(?:karte|karten|pcs|stk)\b/i);
      if(m){ var n2=parseInt(m[1],10); if(Number.isFinite(n2)&&n2>0) return n2; }
      return 0;
    }
    async function checkOrder(order){
      say('Prüfe …',true); btn.disabled=true; inp.disabled=true;
      try{
        var ctrl=new AbortController(); var to=setTimeout(function(){try{ctrl.abort();}catch(_ ){}},8000);
        var res=await fetch(buildCheckUrl(order),{method:'GET',signal:ctrl.signal,credentials:'omit'});
        clearTimeout(to);
        var txt=await res.text(); var cap=pickCap(txt);
        if(res.ok && cap>0){
          say('✓ '+cap+' Karten freigeschaltet',true);
          var u=new URL(location.href); u.searchParams.set('order',order); u.searchParams.set('qty',String(cap));
          history.replaceState(null,'',u.toString()); location.reload();
        }else{ say('Bestellung nicht gefunden oder nicht im Sheet. Nutze z. B. 123456789 (aus Spalte order_id).',false); btn.disabled=false; inp.disabled=false; }
      }catch(e){ say('Prüfserver nicht erreichbar (Timeout).',false); btn.disabled=false; inp.disabled=false; }
    }
    btn.addEventListener('click',function(){ var order=(inp.value||'').trim(); if(!order){ say('Bitte Bestellnummer eingeben.',false); return; } checkOrder(order); });
    inp.addEventListener('keydown',function(ev){ if(ev.key==='Enter') btn.click(); });
  }catch(e){ console.warn('unlock-inline error',e); }
})();
</script>
<script id="ppk-buyer-sync-v1">
(function(){
  if (window.__ppkSyncInit) return; window.__ppkSyncInit = true;
  try{
    var qs=new URLSearchParams(location.search||"");
    if((qs.get("mode")||"").toLowerCase()!=="buyer") return;
    var EXEC_URL='https://script.google.com/macros/s/AKfycbzYcJ8h49o7j-HinFB06rAVpJV7ypaYqxHGKX9O0kHjMQ0ecSXDsglFlOdb3kHmaGpV9g/exec', API_KEY='Jo0Hi3ha0nt0nn6en2a0na0ch2', ORDER=(qs.get('order')||'').trim();
    function sum(items){ if(!Array.isArray(items)) return 0; var s=0; for(var i=0;i<items.length;i++){ var q=parseInt((items[i]&&items[i].qty)||0,10); if(Number.isFinite(q)) s+=q; } return s; }
    function getUsed(){ try{ if(typeof window.getCart==='function') return sum(window.getCart()); }catch(_ ){} try{ if(Array.isArray(window.cart)) return sum(window.cart); }catch(_ ){} return 0; }
    function buildSyncUrl(order,used){ try{ var u=new URL(EXEC_URL); u.searchParams.set('op','sync'); u.searchParams.set('key',API_KEY); u.searchParams.set('order',order); u.searchParams.set('used',String(used)); return u.toString(); }catch(_ ){ return EXEC_URL+'?op=sync&key='+encodeURIComponent(API_KEY)+'&order='+encodeURIComponent(order)+'&used='+encodeURIComponent(String(used)); } }
    var timer=null,lastSent=-1;
    function scheduleSync(used){ if(!ORDER) return; if(!Number.isFinite(used)) used=getUsed(); if(used===lastSent) return; if(timer) clearTimeout(timer); timer=setTimeout(async function(){ try{ await fetch(buildSyncUrl(ORDER,used),{method:'GET',credentials:'omit'}); lastSent=used; }catch(_ ){} },600); }
    if(ORDER) setTimeout(function(){ scheduleSync(getUsed()); },800);
    (function(){ var last=ORDER; setInterval(function(){ var cur=(new URLSearchParams(location.search||'').get('order')||'').trim(); if(cur&&cur!==last){ ORDER=cur; last=cur; scheduleSync(getUsed()); } },1000); })();
    document.addEventListener('ppk:cart:updated',function(ev){ try{ var items=ev&&ev.detail&&ev.detail.items; scheduleSync(sum(items)); }catch(_ ){ scheduleSync(getUsed()); } });
  }catch(e){ console.warn('buyer-sync error',e); }
})();
</script>
<script id="ppk-buyer-hide-prices-mirror">
document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

  var params = new URLSearchParams(location.search);
  var isBuyer = (params.get('mode')||'').toLowerCase()==='buyer';
  if (!isBuyer) return;

  function hide(el){ if (el) el.classList.add('ppk-hide-testprice'); }

  // (A) Hide Euro-like nodes (mirror of test logic)
  Array.from(document.querySelectorAll('td, th, span, small, strong, em, div')).forEach(function(el){
    var txt = (el.textContent||'').replace(/\s+/g,' ').trim();
    var low = txt.toLowerCase();
    if (!txt) return;

    // "€", "eur", "euro" or typical 0,00 pattern
    if (/[€]|\beur\b|\beuro\b/.test(low) || /^\d+[\.,]\d{2}\s*(€|eur|euro)?$/i.test(txt)){
      // don't hide large blocks of description; rely on sibling context
      if (txt.length <= 40) hide(el);
    }
  });

  // (B) Specific known elements
  hide(document.querySelector('#cartTotal'));
  // Summe-Hinweis (dein Text)
  var sumNode = Array.from(document.querySelectorAll('div, p, small, strong, em')).find(function(n){
    var t = (n.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
    return t.startsWith('summe (bezahlung über etsy)');
  });
  if (sumNode){
    var container = sumNode.closest('p, div, section, footer') || sumNode;
    hide(container);
  }

  // (C) Legacy "Bestellung aufgeben"-Elemente (falls vorhanden)
  Array.from(document.querySelectorAll('button, a, [role="button"]')).forEach(function(b){
    var t = (b.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
    if (t === 'bestellung aufgeben' || t.includes('bestellung aufgeben')) hide(b);
  });
});
</script>
<script id="ppk-next-card-scroll-fix-v3">
(function(){
  try{
    function editorAnchor(){
      return document.querySelector(window.PPK_EDITOR_SELECTOR || '.steuerleiste')
             || document.querySelector('#editor, .editor, #kartenbereich, #karten-editor, .kartenbereich');
    }
    function scrollToEditor(){
      var target = editorAnchor();
      if (!target) return;
      try{
        target.scrollIntoView({behavior:'smooth', block:'start'});
      }catch(_){
        var y = target.getBoundingClientRect().top + (window.pageYOffset||0) - (window.PPK_SCROLL_OFFSET||80);
        window.scrollTo(0, y);
      }
      setTimeout(function(){
        var inp = document.querySelector('#editor input, #editor textarea, #editor [contenteditable="true"], .editor input, .editor textarea, .editor [contenteditable="true"]');
        if (inp && typeof inp.focus==='function') try{ inp.focus(); }catch(_){}
      }, 240);
    }
    function isNext(el){
      if (!el) return false;
      var t = (el.textContent || el.innerText || "").toLowerCase().trim();
      return /nächste karte|naechste karte|weiter|next card/.test(t) || (el.matches && el.matches('#btn-abschluss-next, #btn-next-card, .btn-next-card, .btn-new-card'));
    }
    document.addEventListener('click', function(ev){
      var btn = ev.target && ev.target.closest('button, a, [role="button"]');
      if (!btn || !isNext(btn)) return;
      if (btn.disabled || btn.getAttribute('aria-disabled') === 'true') return;
      // mehrfach triggern, falls App asynchron rendert
      setTimeout(scrollToEditor, 60);
      setTimeout(scrollToEditor, 260);
      setTimeout(scrollToEditor, 600);
    }, true);
  }catch(e){}
})();
</script>
<script id="ppk_buyer_next_after_panel_hide">
(function(){
  try{
    function isBuyer(){
      try{ var p=new URLSearchParams(location.search||''); return (p.get('mode')||'').toLowerCase()==='buyer'; }catch(_){}
      return false;
    }
    if (!isBuyer()) return;

    var TOOLBAR_SEL = '.steuerleiste';
    var PANEL_SEL   = '#abschluss-panel';

    function $(sel){ try{ return document.querySelector(sel); }catch(_){ return null; } }
    function toToolbar(){
      var t = $(TOOLBAR_SEL);
      if (!t){ window.scrollTo({top:0, behavior:'smooth'}); return; }
      try{ t.scrollIntoView({behavior:'smooth', block:'start'}); }
      catch(_){
        var y = t.getBoundingClientRect().top + (window.pageYOffset||0) - 80;
        window.scrollTo(0, y);
      }
    }

    var armedUntil = 0;
    function arm(ms){ armedUntil = Date.now() + (ms||1800); }
    function armed(){ return Date.now() < armedUntil; }

    var mo = new MutationObserver(function(){
      if (!armed()) return;
      var p = $(PANEL_SEL);
      var hidden = false;
      if (!p) hidden = true;
      else {
        var cs = window.getComputedStyle(p);
        hidden = cs.display === 'none' || cs.visibility === 'hidden' || p.hidden === true;
      }
      if (hidden){
        setTimeout(toToolbar, 50);
        setTimeout(toToolbar, 250);
        setTimeout(toToolbar, 600);
        armedUntil = 0;
      }
    });
    try{
      mo.observe(document.documentElement, {subtree:true, childList:true, attributes:true, attributeFilter:['style','class','hidden']});
    }catch(_){}

    document.addEventListener('click', function(ev){
      var btn = ev.target && ev.target.closest('#btn-abschluss-next, #btn-next-card, .btn-next-card, .btn-new-card');
      if (!btn) return;
      arm(1800);
      // Fast-path: falls Panel sofort weg ist
      setTimeout(function(){
        if (!armed()) return;
        var p = $(PANEL_SEL);
        var hidden = !p || window.getComputedStyle(p).display === 'none';
        if (hidden){
          setTimeout(toToolbar, 30);
          setTimeout(toToolbar, 260);
          armedUntil = 0;
        }
      }, 120);
    }, true);
  }catch(e){ /* silent */ }
})();
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  try {
    const btn = document.getElementById('ppk-unlock-btn');
    const inp = document.getElementById('ppk-unlock-input');
    if (!btn || !inp || typeof BACKEND_URL === 'undefined') return;

    btn.addEventListener('click', async function (e) {
      e.preventDefault();
      const order = (inp.value || '').trim();
      if (!order) { alert('Bitte Bestellnummer eingeben'); return; }

      const u = new URL(BACKEND_URL);
      u.searchParams.set('op', 'check');
      u.searchParams.set('order', order);

      try {
        const r = await fetch(u.toString(), { cache: 'no-store' });
        const j = await r.json();
        let badge = document.getElementById('ppk-availability');
        if (!badge) {
          // create a small, non-intrusive badge near the unlock UI
          const btn = document.getElementById('ppk-unlock-btn');
          const container = (btn && btn.closest('.row, .section, .container, form')) || document.body;
          badge = document.createElement('div');
          badge.id = 'ppk-availability';
          badge.style.fontWeight = '600';
          badge.style.marginTop = '8px';
          badge.style.fontSize = '14px';
          container.prepend(badge);
        }
        if (j.ok) {
          badge.textContent = `Verfügbar: ${j.remaining}`;
          window.__DEBUG__ && console.log('CHECK OK', j);
        setAvailability(j.remaining);
        // Banner mit "Bestellung nicht gefunden" ausblenden (nur display:none, nichts überschreiben)
        try {
          const warnNode = [...document.querySelectorAll('div, p, span')]
            .find(el => /bestellung\s+nicht\s+gefunden/i.test(el.textContent || ''));
          if (warnNode) warnNode.style.display = 'none';
        } catch(_){}
        } else {
          window.__DEBUG__ && console.warn('CHECK FAIL', j);
          alert('Fehler: ' + j.error);
        }
      } catch (err) {
        console.error(err);
        alert('Netzwerkfehler');
      }
    });
  } catch (e) {
    console.error('unlock-bind failed', e);
  }
});
</script>
<script id="ppk-textsafe-polyfill">
(function(){
  if (window.__ppkSetTextSafe) return;
  window.__ppkSetTextSafe = function(el, txt){
    if (!el) return;
    var s = (txt === undefined || txt === null) ? "" : String(txt);
    // Nur reiner Text, kein HTML
    el.textContent = s;
  };
})();
</script>

<script>

function setAvailability(n){
  try{
    // 1) kleiner Badge links oben
    const badge = document.getElementById('ppk-availability');
    if (badge) badge.textContent = 'Verfügbar: ' + n;

    // 2) Hellblaue Kaufmodus-Leiste: <span id="ppk-remaining">Verfügbar: 0</span>
    const rem = document.getElementById('ppk-remaining');
    if (rem) {
      // nur die Zahl ersetzen, Text davor bleibt
      const txt = rem.textContent || '';
      const m = txt.match(/(Verfügbar\s*:\s*)(\d+)/i);
      window.__ppkSetTextSafe(rem, rem.textContent = m ? (m[1] + String(n)) : ('Verfügbar: ' + n));
    }

    // 3) rotes "Limit erreicht"-Badge steuern
    const limit = document.getElementById('ppk-limit-indicator');
    if (limit) {
      limit.style.display = (Number(n) <= 0) ? 'inline-block' : 'none';
      // Zahl im Text ggf. aktualisieren
      const ltxt = limit.textContent || '';
      const lm = ltxt.match(/(Limit\s*erreicht\s*:\s*)(\d+)/i);
      if (lm) limit.textContent = lm[1] + String(n) + ' verfügbar';
    }
  }catch(e){ console.warn('setAvailability failed', e); }
}
</script>
<!-- STEP1: Leiste-Fix (ppk-remaining stabilisieren) -->
<script id="ppk-bridge-leiste-fix-v1">
(function(){
  try{
    window.ppk = window.ppk || {};
    // Gate: block any availability writes until backend confirms
    // state.gateLocked = true -> ignore early writers (URL/LocalStorage/init)
    
    var state = window.ppk.state = window.ppk.state || {};
    state.total  = (typeof state.total  === 'number') ? state.total  : null;
    state.used   = (typeof state.used   === 'number') ? state.used   : 0;
    state.remaining = (typeof state.remaining === 'number') ? state.remaining : null;
    state.order  = state.order || null;
    state.lastBackendTs = state.lastBackendTs || 0;
    state.gateLocked = (typeof state.gateLocked === 'boolean') ? state.gateLocked : true;

    function unlockGate(){
      if (!state.gateLocked) return;
      state.gateLocked = false;
      if (typeof state.remaining === 'number') renderAll(state.remaining);
    }
    // Expose manual unlock (for integration or console testing)
    window.ppkUnlockAvailability = unlockGate;
    

    function q(id){ return document.getElementById(id); }

    // Render both: badge left/top (if present) and the sticky blue bar value (#ppk-remaining)
    var raf = null;
    function renderAll(nextVal){
      if (typeof nextVal !== 'number' || isNaN(nextVal)) return;
      if (raf) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(function(){
        raf = null;
        var txt = 'Verfügbar: ' + String(nextVal);
        var el = q('ppk-remaining');
        if (el && el.textContent !== txt) el.textContent = txt;

        // Optional second display (badge/label), write only if exists
        var gate = q('ppk-gate-text');
        if (gate && gate.textContent && gate.textContent.includes('Verfügbar:')){
          // keep other gate text and just replace the number gently
          gate.textContent = txt;
        }

        // Keep the "Limit erreicht"-badge in sync if it exists
        var pill = q('ppk-limit-indicator');
        if (pill){
          pill.style.display = (nextVal === 0 ? 'inline-block' : 'none');
          if (nextVal === 0) pill.textContent = 'Limit erreicht: 0 verfügbar';
        }
      });
    }

    // Observe changes that may overwrite the blue bar, and re-apply our last known remaining
    var lastApplied = null;
    var observer = new MutationObserver(function(muts){
      if (typeof state.remaining !== 'number') return;
      var el = q('ppk-remaining');
      if (!el) return;
      var expected = 'Verfügbar: ' + String(state.remaining);
      if (el.textContent !== expected){
        // Re-apply only if something external changed it
        renderAll(state.remaining);
      }
    });
    document.addEventListener('DOMContentLoaded', function(){
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){ }

      try{
        var el = q('ppk-remaining');
        if (el) observer.observe(el, {characterData:true, childList:true, subtree:true});
      }catch(_){}
    });

    // Wrap window.setRemaining to coalesce conflicting writers:
    var _origSet = (typeof window.setRemaining === 'function') ? window.setRemaining : null;
    window.setRemaining = function(n){
      // Normalize
      var val = (n==null) ? null : Number(n);
      if (val==null || isNaN(val)) val = 0;

      // If backend just confirmed a higher number, do not let a stray "0" from URL/other scripts override immediately.
      var hasFreshBackend = (Date.now() - state.lastBackendTs) < 30000; // 30s Schutzfenster
      if (hasFreshBackend && typeof state.remaining === 'number' && state.remaining > 0 && val === 0){
        // ignore transient zero; keep backend value
        val = state.remaining;
      }

      state.remaining = val;
      if (!state.gateLocked){
        renderAll(val);
      }

      if (_origSet) return _origSet.apply(this, [val]);
      return val;
    };

    // Hooks: cart add/remove -> keep numbers consistent without flicker
    function safeParseInt(x){ var n = parseInt(x,10); return isNaN(n)?0:n; }

    // Prefer canonical cart events if present
    document.addEventListener('ppk:cart:updated', function(ev){
      try{
        var items = ev && ev.detail && ev.detail.items;
        var sum = 0;
        if (Array.isArray(items)){
          for (var i=0;i<items.length;i++){ sum += safeParseInt(items[i] && items[i].qty); }
        }
        state.used = sum;
        if (typeof state.total === 'number'){
          var rem = Math.max(0, state.total - state.used);
          // This will go through our wrapper and render everywhere
          window.setRemaining(rem);
        }
      }catch(_){}
    }, {passive:true});

    // Listen for backend check completion if the page dispatches it
    document.addEventListener('ppk:order:checked', function(ev){
      try{
        var d = ev && ev.detail || {};
        // Expect either {total, used, remaining, order} or at least {remaining}
        if (typeof d.total === 'number') state.total = d.total;
        if (typeof d.used === 'number') state.used = d.used;
        if (typeof d.remaining === 'number') state.remaining = d.remaining;
        if (d.order) state.order = d.order;
        state.lastBackendTs = Date.now(); unlockGate();
        if (typeof state.remaining === 'number') renderAll(state.remaining);
      }catch(_){}
    }, {passive:true});

    // As a safety net: if we can infer total from URL qty, use it only once (bootstrap), but never override backend
    
    // Optional: try to detect a "Prüfen"-button to anticipate backend check.
    document.addEventListener('click', function(ev){
      try{
        var el = ev.target;
        if (!el) return;
        var txt = (el.textContent||'').trim().toLowerCase();
        if (txt === 'prüfen' || txt === 'pruefen'){
          // keep the gate locked until backend event arrives; clear any premature UI
          var slot = document.getElementById('ppk-remaining');
          if (slot) slot.textContent = 'Verfügbar: —';
        }
      }catch(_){}
    }, {capture:true, passive:true});
(function bootstrapFromUrl(){
      try{
        var qs = new URLSearchParams(location.search);
        var qty = parseInt(qs.get('qty')||'0',10);
        if (qty>0 && typeof state.total !== 'number'){
          state.total = qty;
        }
      }catch(_){}
    })();

  }catch(e){ console.warn('ppk-bridge-leiste-fix-v1 error:', e); }
})();
</script>
<!-- STEP: backend check wire (minimal) -->
<script id="ppk-check-wire-v1">
(function(){ 
  const EXEC_URL = "https://script.google.com/macros/s/AKfycbwQdgQfFV-EnT4Ue1aOX-7WfgZe-CGTZy6xi3u6-2SbhyFgTkTrjpmjM5RLobabQht94Q/exec";
  const API_KEY = "Jo0Hi3ha0nt0nn6en2a0naOch2";

  async function ppkCheckOrder(orderId){
    try {
      const url = new URL(EXEC_URL);
      url.searchParams.set('op', 'check');
      url.searchParams.set('order', (orderId||'').trim());
      url.searchParams.set('key', API_KEY);

      const res = await fetch(url.toString(), { method: 'GET', credentials: 'omit' });
      const data = await res.json().catch(()=>({ok:false, error:'BAD_JSON'}));

      if (data && data.ok) {
        // Map column names: qty_total, qty_used
        const total = Number(data.qty_total || data.total || 0);
        const used  = Number(data.qty_used  || data.used  || 0);
        const remaining = Math.max(0, total - used);
        const order = String(data.order || data.order_id || '').trim();

        document.dispatchEvent(new CustomEvent('ppk:order:checked', {
          detail: { order, total, used, remaining }
        }));

        const msg = document.getElementById('ppk-unlock-msg');
        if (msg) msg.textContent = 'OK ✓';
        return {ok:true, order, total, used, remaining};
      } else {
        const msg = document.getElementById('ppk-unlock-msg');
        if (msg) msg.textContent = 'Bestellung nicht gefunden oder nicht im Sheet.';
        return data;
      }
    } catch (e) {
      const msg = document.getElementById('ppk-unlock-msg');
      if (msg) msg.textContent = 'Prüfserver nicht erreichbar.';
      return {ok:false, error:String(e)};
    }
  }

  // Wire the existing Prüfen-Button if present
  function wireButton(){ 
    const btn = document.getElementById('ppk-unlock-btn');
    const input = document.getElementById('ppk-unlock-input');
    if (!btn || !input) return;
    if (btn._ppkWired) return; // avoid double-binding
    btn._ppkWired = true;
    btn.addEventListener('click', function(ev){
      const orderId = input.value || '';
      // show waiting dash and keep gate locked; the bridge will unlock on event
      const slot = document.getElementById('ppk-remaining');
      if (slot) slot.textContent = 'Verfügbar: —';
      ppkCheckOrder(orderId);
    });
  }

  document.addEventListener('DOMContentLoaded', wireButton);
  // Also try a delayed wire in case elements render late
  setTimeout(wireButton, 1000);
})();
</script>
<!-- STEP: Response-Gate (only newest check may update UI; freeze after success) -->
<script id="ppk-response-gate-v1">
(function(){
  try{
    window.ppk = window.ppk || {};
    var gate = window.ppk.gate = window.ppk.gate || {};
    gate.token = gate.token || 0;          // increments on each Prüfen
    gate.current = gate.current || 0;       // latest active token
    gate.freezeUntil = gate.freezeUntil || 0; // ms timestamp; during freeze we ignore error/zero overwrites
    gate.success = !!gate.success;          // last known success

    function now(){ return Date.now(); }
    function inFreeze(){ return now() < (gate.freezeUntil||0); }

    // Helper to mark success and start freeze window
    function markSuccess(){
      gate.success = true;
      gate.freezeUntil = now() + 20000; // 20s stabilization window
      // ensure OK ✓ visible
      var msg = document.getElementById('ppk-unlock-msg');
      if (msg){ msg.textContent = 'OK ✓'; msg.style.opacity='1'; msg.style.display='inline'; }
    }

    // 1) Count a new token on Prüfen click
    document.addEventListener('click', function(ev){
      try{
        var el = ev.target;
        if (!el) return;
        var t = (el.textContent||'').trim().toLowerCase();
        if (t === 'prüfen' || t === 'pruefen'){
          gate.current = ++gate.token;
        }
      }catch(_){}
    }, {capture:true, passive:true});

    // 2) When a successful backend check fires, accept only if token is current
    document.addEventListener('ppk:order:checked', function(ev){
      try{
        var d = ev && ev.detail || {};
        // Accept all successes but refresh UI and start freeze
        markSuccess();
        // If your bridge is present, it will render remaining; we just reinforce once more
        if (typeof d.remaining === 'number'){
          var el = document.getElementById('ppk-remaining');
          if (el) el.textContent = 'Verfügbar: ' + String(d.remaining);
        }
      }catch(_){}
    });

    // 3) Guard message element against stale errors during freeze
    var errPhrases = ['bestellung nicht gefunden', 'prüfserver nicht erreichbar', 'nicht im sheet'];
    var msgObs = new MutationObserver(function(muts){
      if (!inFreeze()) return;
      var msg = document.getElementById('ppk-unlock-msg');
      if (!msg) return;
      var txt = (msg.textContent||'').toLowerCase();
      for (var i=0;i<errPhrases.length;i++){
        if (txt.indexOf(errPhrases[i]) !== -1){
          // revert to OK during freeze
          msg.textContent = 'OK ✓';
          break;
        }
      }
    });
    document.addEventListener('DOMContentLoaded', function(){
      var msg = document.getElementById('ppk-unlock-msg');
      if (msg) msgObs.observe(msg, {childList:true, characterData:true, subtree:true});
    });

    // 4) Guard against stray setRemaining(0) while frozen and we had a success
    var _origSet = (typeof window.setRemaining === 'function') ? window.setRemaining : null;
    window.setRemaining = function(n){
      var val = (n==null) ? 0 : Number(n);
      if (inFreeze() && gate.success && val === 0){
        // ignore ghost zero during stabilization
        return (typeof _origSet==='function') ? _origSet.call(this, (window.ppk && window.ppk.state && typeof window.ppk.state.remaining==='number') ? window.ppk.state.remaining : val) : val;
      }
      if (window.ppk && window.ppk.state) window.ppk.state.remaining = val;
      if (typeof _origSet==='function') return _origSet.apply(this, [val]);
      // fallback render if no original
      var el = document.getElementById('ppk-remaining');
      if (el) el.textContent = 'Verfügbar: ' + String(val);
      return val;
    };
  }catch(e){ console.warn('ppk-response-gate-v1 error:', e); }
})();
</script>
<!-- STEP: Remaining-Guard (prevent unwanted reset to 0) -->
<script id="ppk-remaining-guard-v1">
(function(){
  try{
    window.ppk = window.ppk || {};
    var guard = window.ppk.remGuard = window.ppk.remGuard || {};
    guard.lastGood = (typeof guard.lastGood==='number') ? guard.lastGood : null;
    guard.total = (typeof guard.total==='number') ? guard.total : null;
    guard.used = (typeof guard.used==='number') ? guard.used : 0;
    guard.lastCartTs = guard.lastCartTs || 0;
    guard.lastBackendTs = guard.lastBackendTs || 0;

    function now(){ return Date.now(); }
    function parseRemainingText(txt){
      if (!txt) return null;
      var m = txt.match(/Verfügbar:\s*([0-9]+)/i);
      return m ? parseInt(m[1],10) : null;
    }
    function setText(n){
      var el = document.getElementById('ppk-remaining');
      if (el) el.textContent = 'Verfügbar: ' + String(n);
    }

    document.addEventListener('ppk:order:checked', function(ev){
      try{
        var d = ev && ev.detail || {};
        if (typeof d.total==='number') guard.total = d.total;
        if (typeof d.used==='number') guard.used = d.used;
        if (typeof d.remaining==='number'){
          guard.lastGood = d.remaining;
          setText(d.remaining);
        }
        guard.lastBackendTs = now();
      }catch(_){}
    });

    document.addEventListener('ppk:cart:updated', function(ev){
      try{
        var items = ev && ev.detail && ev.detail.items;
        var sum = 0;
        if (Array.isArray(items)){
          for (var i=0;i<items.length;i++){
            var q = parseInt(items[i] && items[i].qty, 10);
            if (!isNaN(q)) sum += q;
          }
        }
        guard.used = sum;
        if (typeof guard.total==='number'){
          var rem = Math.max(0, guard.total - guard.used);
          guard.lastGood = rem;
          setText(rem);
        }
        guard.lastCartTs = now();
      }catch(_){}
    }, {passive:true});

    var mo = new MutationObserver(function(){
      try{
        var el = document.getElementById('ppk-remaining');
        if (!el) return;
        var num = parseRemainingText(el.textContent||'');
        if (num === 0 && typeof guard.lastGood==='number' && guard.lastGood > 0){
          var recentCart = (now() - guard.lastCartTs) < 1500;
          var recentBackend = (now() - guard.lastBackendTs) < 1500;
          if (!recentCart && !recentBackend){
            setText(guard.lastGood);
          }
        }
      }catch(_){}
    });
    document.addEventListener('DOMContentLoaded', function(){
      var el = document.getElementById('ppk-remaining');
      if (el) mo.observe(el, {childList:true, characterData:true, subtree:true});
    });

    var _origSet = (typeof window.setRemaining === 'function') ? window.setRemaining : null;
    window.setRemaining = function(n){
      var val = (n==null) ? 0 : Number(n);
      if (val === 0 && typeof guard.lastGood==='number' && guard.lastGood > 0){
        var recentCart = (now() - guard.lastCartTs) < 1500;
        var recentBackend = (now() - guard.lastBackendTs) < 1500;
        if (!recentCart && !recentBackend){
          return (typeof _origSet==='function') ? _origSet.call(this, guard.lastGood) : guard.lastGood;
        }
      }
      if (typeof _origSet==='function') return _origSet.apply(this, [val]);
      setText(val);
      return val;
    };
  }catch(e){ console.warn('ppk-remaining-guard-v1 error:', e); }
})();
</script>
<!-- CART COUPLING (display only) --><script id="ppk-cart-coupling-v1">(function(){try{window.ppk=window.ppk||{};var lk=window.ppk.lock=window.ppk.lock||{};var cart=window.ppk.cart=window.ppk.cart||{};function safeInt(x){var n=parseInt(x,10);return isNaN(n)?0:n}function countCartItems(){if(Array.isArray(cart.items))return cart.items.reduce(function(a,it){return a+safeInt(it&&it.qty)},0);if(window.cart&&Array.isArray(window.cart.items))return window.cart.items.reduce(function(a,it){return a+safeInt(it&&it.qty)},0);return cart.pendingLocal||0}function baseRemaining(){if(typeof lk.total==='number'&&typeof lk.used==='number')return Math.max(0,lk.total-lk.used);if(typeof lk.lastGood==='number')return lk.lastGood;return null}function recompute(){if(lk.locked)return;var base=baseRemaining();if(base==null)return;var disp=Math.max(0,base-countCartItems());if(typeof window.setRemaining==='function'){window.setRemaining(disp)}else{var s=document.getElementById('ppk-remaining');if(s)s.textContent='Verfügbar: '+String(disp)}}document.addEventListener('ppk:order:checked',function(){setTimeout(recompute,0)},{passive:true});document.addEventListener('ppk:cart:updated',function(){recompute()},{passive:true});function wrap(n){var o=window[n];if(typeof o!=='function'||o._ppkWrapped)return;function w(){var r=o.apply(this,arguments);try{document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{}}))}catch(_){ }return r}w._ppkWrapped=true;window[n]=w}wrap('addToCart');wrap('removeFromCart');document.addEventListener('DOMContentLoaded',function(){setTimeout(recompute,0)})}catch(e){console.warn('ppk-cart-coupling-v1 error:',e)}})();</script>
<!-- AVAILABILITY PILL --><script id="ppk-availability-pill-v1">(function(){try{window.ppk=window.ppk||{};var lk=window.ppk.lock=window.ppk.lock||{};var cart=window.ppk.cart=window.ppk.cart||{};function safeInt(x){var n=parseInt(x,10);return isNaN(n)?0:n}function countCart(){if(Array.isArray(cart.items))return cart.items.reduce((a,it)=>a+safeInt(it&&it.qty),0);if(window.cart&&Array.isArray(window.cart.items))return window.cart.items.reduce((a,it)=>a+safeInt(it&&it.qty),0);return cart.pendingLocal||0}function baseRemaining(){if(typeof lk.total==='number'&&typeof lk.used==='number')return Math.max(0,lk.total-lk.used);if(typeof lk.lastGood==='number')return lk.lastGood;return null}function ensureUI(){var banner=document.getElementById('ppk-gate-banner');if(!banner||!banner.parentNode)return null;var slot=document.getElementById('ppk-availability-slot');if(!slot){slot=document.createElement('div');slot.id='ppk-availability-slot';banner.parentNode.insertBefore(slot,banner)}var pill=document.getElementById('ppk-availability-pill');if(!pill){pill=document.createElement('button');pill.type='button';pill.id='ppk-availability-pill';pill.textContent='Verfügbar: —';slot.appendChild(pill)}return pill}function render(){var pill=ensureUI();if(!pill)return;var base=baseRemaining();if(base==null){pill.textContent='Verfügbar: —';pill.classList.remove('ppk-zero');return}var disp=Math.max(0,base-countCart());pill.textContent=disp===0?'Limit erreicht: 0 verfügbar':'Verfügbar: '+String(disp);pill.classList.toggle('ppk-zero',disp===0)}document.addEventListener('ppk:order:checked',function(){setTimeout(render,0)},{passive:true});document.addEventListener('ppk:cart:updated',function(){render()},{passive:true});document.addEventListener('DOMContentLoaded',function(){render();setTimeout(render,50)});function wrap(n){var o=window[n];if(typeof o!=='function'||o._ppkWrapped)return;function w(){var r=o.apply(this,arguments);try{document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{}}))}catch(_){ }return r}w._ppkWrapped=true;window[n]=w}wrap('addToCart');wrap('removeFromCart')}catch(e){console.warn('ppk-availability-pill-v1 error:',e)}})();</script>
<!-- CART BRIDGE --><script id="ppk-availability-pill-bridge">(function(){try{window.ppk=window.ppk||{};var cart=window.ppk.cart=window.ppk.cart||{};cart.pendingLocal=cart.pendingLocal||0;function safeInt(x){var n=parseInt(x,10);return isNaN(n)?0:n}window.ppkCartSetPending=function(n){cart.pendingLocal=Math.max(0,safeInt(n));document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{reason:'bridge'}}))};document.addEventListener('click',function(ev){try{var el=ev.target;if(!el)return;var btn=el.closest&&el.closest('button, a, [role="button"]');if(!btn)return;var txt=(btn.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();if(txt==='zum warenkorb'){cart.pendingLocal+=1;document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{reason:'click'}}))}else if(txt==='karte leeren'||txt==='aus dem warenkorb entfernen'){cart.pendingLocal=Math.max(0,cart.pendingLocal-1);document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{reason:'click'}}))}}catch(_){ }},{capture:true});var lastSig=null;function snapshotStorage(){try{var keys=Object.keys(localStorage);var sig=[];var found=0;for(var i=0;i<keys.length;i++){var k=keys[i];if(!/cart|warenkorb|ppk/i.test(k))continue;var v=localStorage.getItem(k);sig.push(k+':'+(v?v.length:0));try{var obj=JSON.parse(v);if(Array.isArray(obj))found+=obj.reduce((a,it)=>a+safeInt(it&&(it.qty||it.quantity||it.count)),0);else if(obj&&Array.isArray(obj.items))found+=obj.items.reduce((a,it)=>a+safeInt(it&&(it.qty||it.quantity||it.count)),0)}catch(_){}}var sigStr=sig.sort().join('|');if(sigStr!==lastSig){lastSig=sigStr;cart.pendingLocal=Math.max(0,found);document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{reason:'storage'}}))}}catch(_){}}setInterval(snapshotStorage,1200)}catch(e){console.warn('ppk-availability-pill-bridge error:',e)}})();</script>
<!-- STEP: hoist original red limit indicator to sticky top (stabilized) -->
<script id="ppk-limit-hoist-v2">
(function(){
  try{
    window.ppk = window.ppk || {};
    var lk = window.ppk.lock = window.ppk.lock || {};
    var cart = window.ppk.cart = window.ppk.cart || {};

    function safeInt(x){ var n=parseInt(x,10); return isNaN(n)?0:n; }
    function countCart(){
      if (Array.isArray(cart.items)) return cart.items.reduce((a,it)=>a+safeInt(it&&it.qty),0);
      if (window.cart && Array.isArray(window.cart.items)) return window.cart.items.reduce((a,it)=>a+safeInt(it&&it.qty),0);
      return (cart.pendingLocal||0);
    }
    function baseRemaining(){
      if (typeof lk.total==='number' && typeof lk.used==='number') return Math.max(0, lk.total - lk.used);
      if (typeof lk.lastGood==='number') return lk.lastGood;
      return null;
    }
    function computeDisplay(){
      var base = baseRemaining();
      if (base==null) return null;
      return Math.max(0, base - countCart());
    }

    function ensureStickySlot(){
      var banner = document.getElementById('ppk-gate-banner');
      var slot = document.getElementById('ppk-limit-sticky-slot');
      if (!slot){
        slot = document.createElement('div');
        slot.id = 'ppk-limit-sticky-slot';
        if (banner && banner.parentNode){
          banner.parentNode.insertBefore(slot, banner);
        } else {
          document.body.insertBefore(slot, document.body.firstChild);
        }
      }
      return slot;
    }

    var lastRendered = null;
    function renderPill(){
      var pill = document.getElementById('ppk-limit-indicator');
      if (!pill) return;
      var n = computeDisplay();
      if (n==null) return;
      // only update when the number changed
      if (lastRendered === n) return;
      lastRendered = n;
      // Textangleichung: 0 -> rot, sonst grün (Klasse wird ggf. von vorhandener CSS gesteuert)
      var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + String(n));
      // write textContent only (kein innerHTML)
      window.__ppkSetTextSafe(pill, txt);
      pill.setAttribute('data-ppk-val', String(n));
    }

    var hoistScheduled = false;
    function hoist(){
      if (hoistScheduled) return;
      hoistScheduled = true;
      setTimeout(function(){
        hoistScheduled = false;
        var pill = document.getElementById('ppk-limit-indicator');
        if (!pill) return;
        var slot = ensureStickySlot();
        if (pill.parentNode !== slot){
          try{ slot.appendChild(pill); }catch(_){}
        }
        renderPill();
      }, 60);
    }

    document.addEventListener('DOMContentLoaded', hoist, {once:true});
    // in case the pill renders late, retry a bit – but no global DOM observer
    setTimeout(hoist, 300);
    setTimeout(hoist, 1000);

    // keep content synced with backend and cart changes (no DOM thrash)
    document.addEventListener('ppk:order:checked', function(){ renderPill(); }, {passive:true});
    document.addEventListener('ppk:cart:updated', function(){ renderPill(); }, {passive:true});
  }catch(e){ console.warn('ppk-limit-hoist-v2 error:', e); }
})();
</script>
<!-- STEP: Bind red limit button to backend + cart (same logic as Tester) -->
<script id="ppk-limit-from-backend-v1">
(function(){
  try{
    window.ppk = window.ppk || {};
    var S = window.ppk.avail = window.ppk.avail || { total:null, used:0, remaining:null, inCart:0 };
    var cart = window.ppk.cart = window.ppk.cart || {};
    var pillId = 'ppk-limit-indicator';
    var lastTxt = null;

    function safeInt(x){ var n = parseInt(x,10); return isNaN(n)?0:n; }
    function countCart(){
      if (Array.isArray(cart.items)) return cart.items.reduce((a,it)=>a+safeInt(it&&it.qty),0);
      if (window.cart && Array.isArray(window.cart.items)) return window.cart.items.reduce((a,it)=>a+safeInt(it&&it.qty),0);
      return safeInt(cart.pendingLocal||S.inCart||0);
    }
    function baseRemaining(){
      if (typeof S.total==='number' && typeof S.used==='number') return Math.max(0, S.total - S.used);
      if (typeof S.remaining==='number') return Math.max(0, S.remaining);
      if (window.ppk && window.ppk.lock && typeof window.ppk.lock.lastGood==='number') return Math.max(0, window.ppk.lock.lastGood);
      return null;
    }
    function render(){
      var pill = document.getElementById(pillId);
      if (!pill) return;
      var base = baseRemaining();
      if (base==null) return;
      var disp = Math.max(0, base - countCart());
      var txt = (disp===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + String(disp));
      if (lastTxt !== txt){
        lastTxt = txt;
        window.__ppkSetTextSafe(pill, txt);                      // nur Text, kein HTML
        pill.classList.toggle('ppk-zero', disp===0); // visuelle Klasse falls vorhanden
        pill.setAttribute('data-ppk-val', String(disp));
      }
    }

    document.addEventListener('ppk:order:checked', function(ev){
      try{
        var d = ev && ev.detail || {};
        if (typeof d.total==='number')     S.total     = d.total;
        if (typeof d.used==='number')      S.used      = d.used;
        if (typeof d.remaining==='number') S.remaining = d.remaining;
        render();
      }catch(_){}
    }, {passive:true});

    document.addEventListener('ppk:cart:updated', function(){
      try{ S.inCart = countCart(); render(); }catch(_){}
    }, {passive:true});

    window.ppkCartSetPending = function(n){
      S.inCart = Math.max(0, safeInt(n));
      document.dispatchEvent(new CustomEvent('ppk:cart:updated', {detail:{reason:'bridge'}}));
    };

    var mo = new MutationObserver(function(){
      var pill = document.getElementById(pillId);
      if (!pill) return;
      if (lastTxt!=null && pill.textContent !== lastTxt){
        pill.textContent = lastTxt;
      }
    });
    document.addEventListener('DOMContentLoaded', function(){
      var pill = document.getElementById(pillId);
      if (pill) mo.observe(pill, { characterData:true, childList:true, subtree:true });
      setTimeout(render, 0);
    });
  }catch(e){ console.warn('ppk-limit-from-backend-v1 error:', e); }
})();
</script>
<script id="ppk-greenpill-disable">
(function(){
  try{
    function nuke(){
      var el = document.getElementById('ppk-availability-slot');
      if (el && el.parentNode) el.parentNode.removeChild(el);
      var el2 = document.getElementById('ppk-availability-pill');
      if (el2 && el2.parentNode) el2.parentNode.removeChild(el2);
      window.ppk = window.ppk || {}; window.ppk.flags = window.ppk.flags || {};
      window.ppk.flags.greenPillDisabled = true;
    }
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', nuke, {once:true});
    } else {
      nuke();
    }
  }catch(e){ console.warn('ppk-greenpill-disable error:', e); }
})();
</script>
<!-- STEP: next-card guard: ignore availability changes triggered by "Nächste Karte" -->
<!-- STEP: override legacy showLimit to stop flicker -->
<script id="ppk-limit-showlimit-override">
(function(){
  try{
    var pill, lastVal=null;
    function ensure(){
      pill = document.getElementById('ppk-limit-indicator');
      if (!pill) return false;
      pill.style.display = 'inline-block'; // never hide; we manage content only
      return true;
    }
    function render(n){
      if (!ensure()) return;
      var v = (n==null)?0:Number(n);
      if (v === lastVal) return;
      lastVal = v;
      var txt = (v<=0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + String(v));
      window.__ppkSetTextSafe(pill, txt);
      pill.classList.toggle('ppk-zero', v===0);
      pill.setAttribute('data-ppk-val', String(v));
    }
    // Override legacy function if present
    window.showLimit = function(n){ render(n); };
    // Also refresh after relevant events to keep content in sync
    document.addEventListener('ppk:order:checked', function(ev){
      var d = ev && ev.detail || {};
      var rem = (typeof d.remaining==='number') ? d.remaining :
                (typeof d.total==='number' && typeof d.used==='number' ? Math.max(0, d.total-d.used): null);
      if (rem!=null){ setTimeout(function(){ render(rem); }, 0); }
    }, {passive:true});
    document.addEventListener('ppk:cart:updated', function(){
      // Ensure the last rendered value remains visible (if some code rewrites)
      var valAttr = pill && pill.getAttribute && pill.getAttribute('data-ppk-val');
      if (valAttr!=null){ setTimeout(function(){ render(Number(valAttr)); }, 0); }
    }, {passive:true});
  }catch(e){ console.warn('ppk-limit-showlimit-override error:', e); }
})();
</script>
<!-- STEP: ppk-limit-stabilizer-v1 -->
<script id="ppk-limit-stabilizer-v1">
(function(){
  try{
    var pill = null, lastTxt = null, lastVal = null;
    var minInterval = 100; // ms, cap at 10 fps
    var lastTs = 0;

    function ensure(){
      if (!pill) pill = document.getElementById('ppk-limit-indicator');
      if (!pill) return false;
      // defensive: visibility constants
      pill.style.display = 'inline-block';
      pill.hidden = false;
      return true;
    }

    function render(txt, val){
      if (!ensure()) return;
      var now = Date.now();
      if (val === lastVal && txt === lastTxt) return;
      if (now - lastTs < minInterval) { // throttle
        setTimeout(function(){ render(txt, val); }, minInterval - (now - lastTs));
        return;
      }
      lastTs = now;
      lastVal = val;
      lastTxt = txt;
      // set text only if changed
      if (pill.textContent !== txt) window.__ppkSetTextSafe(pill, txt);
      pill.setAttribute('data-ppk-val', String(val));
      pill.classList.toggle('ppk-zero', val===0);
    }

    // Observe attempts to hide or move the pill and undo them
    var mo = new MutationObserver(function(muts){
      if (!pill) return;
      // keep it visible
      if (pill.style && pill.style.display === 'none') pill.style.display = 'inline-block';
      if (pill.hidden) pill.hidden = false;
      // if someone rewrites text quickly to the same value, ignore; otherwise refresh our text
      var attrVal = pill.getAttribute('data-ppk-val');
      if (attrVal != null){
        var v = parseInt(attrVal, 10);
        var txt = (v===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + String(v));
        if (pill.textContent !== txt) {
          // don't spam: defer a tick
          setTimeout(function(){ render(txt, v); }, 0);
        }
      }
    });

    document.addEventListener('DOMContentLoaded', function(){
      if (ensure()){
        mo.observe(pill, { attributes:true, attributeFilter:['style','hidden','class'], childList:true, subtree:true, characterData:true });
        // initial normalize
        var vAttr = pill.getAttribute('data-ppk-val');
        var v = (vAttr!=null) ? parseInt(vAttr,10) : null;
        var txt = (v===0) ? 'Limit erreicht: 0 verfügbar' : (v!=null ? 'Verfügbar: '+String(v) : pill.textContent);
        render(txt, (v==null?0:v));
      }
    });

    // Sync after backend/cart events using current authoritative value on the pill
    function syncFromAttr(){
      if (!ensure()) return;
      var vAttr = pill.getAttribute('data-ppk-val');
      if (vAttr==null) return;
      var v = parseInt(vAttr, 10);
      var txt = (v===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + String(v));
      render(txt, v);
    }
    document.addEventListener('ppk:order:checked', function(){ setTimeout(syncFromAttr, 0); }, {passive:true});
    document.addEventListener('ppk:cart:updated', function(){ setTimeout(syncFromAttr, 0); }, {passive:true});
  }catch(e){ console.warn('ppk-limit-stabilizer-v1 error:', e); }
})();
</script>

<!-- STEP: next-card guard v5 (document-level watch: prevent 0 + node-recreate) -->
<script id="ppk-nextcard-guard-v5">
(function(){
  try{
    window.ppk = window.ppk || {}; window.ppk.flags = window.ppk.flags || {};
    var F = window.ppk.flags;
    F.nextFreezeUntil = F.nextFreezeUntil || 0;
    var lastGood = {n:null};

    function now(){ return Date.now(); }
    function inFreeze(){ return now() < (F.nextFreezeUntil||0); }

    function readVal(){
      var pill = document.getElementById('ppk-limit-indicator');
      var attr = pill && pill.getAttribute && pill.getAttribute('data-ppk-val');
      var n = (attr!=null && !isNaN(parseInt(attr,10))) ? parseInt(attr,10) : null;
      return n;
    }
    function applyVal(n){
      var pill = document.getElementById('ppk-limit-indicator');
      if (pill){
        var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: '+String(n));
        if (pill.textContent !== txt) window.__ppkSetTextSafe(pill, txt);
        pill.setAttribute('data-ppk-val', String(n));
        pill.classList.toggle('ppk-zero', n===0);
        pill.style.display = 'inline-block';
        pill.hidden = false;
      }
      var t = document.getElementById('ppk-remaining');
      if (t){
        var s = 'Verfügbar: ' + String(n);
        if (t.textContent !== s) t.textContent = s;
      }
    }

    function armFreeze(){
      var v = readVal();
      if (v!=null) lastGood.n = v;
      F.nextFreezeUntil = now() + 3000;
      applyVal(lastGood.n==null?0:lastGood.n);
    }

    document.addEventListener('click', function(ev){
      var el = ev.target;
      if (!el) return;
      var btn = el.closest && el.closest('#btn-abschluss-next, button, [role="button"], a');
      if (!btn) return;
      var id = btn.id || '';
      var txt = (btn.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
      if (id==='btn-abschluss-next' || txt==='nächste karte' || txt==='naechste karte'){
        armFreeze();
      }
    }, {capture:true});

    var mo = new MutationObserver(function(muts){
      if (!inFreeze()) return;
      var touched = false;
      var pill = document.getElementById('ppk-limit-indicator');
      var t    = document.getElementById('ppk-remaining');
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        if (m.type === 'childList'){
          for (var j=0;j<m.addedNodes.length;j++){
            var n = m.addedNodes[j];
            if (!n || n.nodeType!==1) continue;
            if (n.id==='ppk-limit-indicator' || (n.querySelector && n.querySelector('#ppk-limit-indicator'))) touched = true;
            if (n.id==='ppk-remaining' || (n.querySelector && n.querySelector('#ppk-remaining'))) touched = true;
          }
        }else if (m.type === 'characterData'){
          touched = true;
        }
      }
      if (pill && /(?:limit erreicht:\s*0|verfügbar:\s*0)/i.test(pill.textContent||'')) touched = true;
      if (t && /Verfügbar:\s*0\b/i.test(t.textContent||'')) touched = true;
      if (touched && lastGood.n!=null){
        applyVal(lastGood.n);
      }
    });
    document.addEventListener('DOMContentLoaded', function(){
      mo.observe(document.documentElement, {childList:true, subtree:true, characterData:true});
    });

    var _origSet = (typeof window.setRemaining === 'function') ? window.setRemaining : null;
    window.setRemaining = function(n){
      if (inFreeze()){ if (lastGood.n!=null) applyVal(lastGood.n); return Number(n||0); }
      if (typeof _origSet === 'function') return _origSet.apply(this, arguments);
      var v = Number(n||0);
      var el = document.getElementById('ppk-remaining'); if (el) el.textContent = 'Verfügbar: ' + String(v);
      return v;
    };
    document.addEventListener('ppk:cart:updated', function(ev){ if(inFreeze()){ try{ev.stopImmediatePropagation();}catch(_){ } if(lastGood.n!=null) applyVal(lastGood.n);} }, {capture:true});
    document.addEventListener('ppk:order:checked', function(ev){ if(inFreeze()){ try{ev.stopImmediatePropagation();}catch(_){ } if(lastGood.n!=null) applyVal(lastGood.n);} }, {capture:true});
  }catch(e){ console.warn('ppk-nextcard-guard-v5 error:', e); }
})();
</script>
<!-- STEP: write-authority-gate (only backend/cart may change availability) -->
<script id="ppk-write-authority-gate-v1">
(function(){
  try{
    window.ppk = window.ppk || {}; window.ppk.flags = window.ppk.flags || {};
    var F = window.ppk.flags;
    var lastGood = { n: null };
    F.writeGateUntil = F.writeGateUntil || 0;

    function now(){ return Date.now(); }
    function permitWindow(ms){ F.writeGateUntil = now() + (ms||600); }
    function isPermitted(){ return now() < (F.writeGateUntil||0); }

    function readVal(){
      var pill = document.getElementById('ppk-limit-indicator');
      var attr = pill && pill.getAttribute && pill.getAttribute('data-ppk-val');
      var n = (attr!=null && !isNaN(parseInt(attr,10))) ? parseInt(attr,10) : null;
      return n;
    }
    function applyVal(n){
      if (n==null) return;
      var pill = document.getElementById('ppk-limit-indicator');
      if (pill){
        var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: '+String(n));
        if (pill.textContent !== txt) window.__ppkSetTextSafe(pill, txt);
        pill.setAttribute('data-ppk-val', String(n));
        pill.classList.toggle('ppk-zero', n===0);
        pill.style.display = 'inline-block'; pill.hidden = false;
      }
      var t = document.getElementById('ppk-remaining');
      if (t){
        var s = 'Verfügbar: ' + String(n);
        if (t.textContent !== s) t.textContent = s;
      }
    }
    function captureGood(){
      var v = readVal(); if (v!=null) lastGood.n = v;
    }

    // Allow backend + cart writes for a short window
    document.addEventListener('ppk:order:checked', function(){ captureGood(); permitWindow(1200); }, {passive:true});
    document.addEventListener('ppk:cart:updated', function(){ captureGood(); permitWindow(1200); }, {passive:true});

    // Harden legacy setters
    var _origSetRem = (typeof window.setRemaining === 'function') ? window.setRemaining : null;
    window.setRemaining = function(n){
      var v = Number(n||0);
      if (!isPermitted()){ if (lastGood.n!=null) applyVal(lastGood.n); return v; }
      if (typeof _origSetRem === 'function') return _origSetRem.apply(this, arguments);
      applyVal(v); lastGood.n = v; return v;
    };
    var _origShowLimit = window.showLimit;
    window.showLimit = function(n){
      var v = Number(n||0);
      if (!isPermitted()){ if (lastGood.n!=null) applyVal(lastGood.n); return v; }
      applyVal(v); lastGood.n = v; return v;
    };

    // Any clicks on likely destructive controls open a NO-WRITE window to block accidental zeros
    document.addEventListener('click', function(ev){
      var el = ev.target; if (!el) return;
      var btn = el.closest && el.closest('button,[role="button"],a');
      if (!btn) return;
      var txt = (btn.textContent||'').replace(/\s+/g,' ').trim().toLowerCase();
      var id  = (btn.id||'').toLowerCase();
      // Heuristics: modal OK / Karte leeren / Weiter / Bestätigen
      if (/(ok|bestätigen|weiter|confirm)/.test(txt) || /(leeren|clear)/.test(txt) || id.indexOf('clear')>=0 || id.indexOf('leeren')>=0){
        // explicitly DISallow writes for 2s and snap back to last known good
        F.writeGateUntil = 0; // close gate
        captureGood();
        setTimeout(function(){ if (lastGood.n!=null) applyVal(lastGood.n); }, 0);
        var until = now()+2000;
        var t = setInterval(function(){
          if (now()>until){ clearInterval(t); return; }
          if (lastGood.n!=null) applyVal(lastGood.n);
        }, 60);
      }
    }, {capture:true});
  }catch(e){ console.warn('ppk-write-authority-gate-v1 error:', e); }
})();
</script>
<!-- STEP: targeted plant-change OK guard -->
<script id="ppk-guard-rb-confirm-ok">
(function(){
  try{
    window.ppk = window.ppk || {}; window.ppk.flags = window.ppk.flags || {};
    var F = window.ppk.flags;
    F.okFreezeUntil = F.okFreezeUntil || 0;
    var lastGood = { n: null };
    var loop = null;

    function now(){ return Date.now(); }
    function inFreeze(){ return now() < (F.okFreezeUntil||0); }

    function readVal(){
      var pill = document.getElementById('ppk-limit-indicator');
      var attr = pill && pill.getAttribute && pill.getAttribute('data-ppk-val');
      var n = (attr!=null && !isNaN(parseInt(attr,10))) ? parseInt(attr,10) : null;
      return n;
    }
    function applyVal(n){
      if (n==null) return;
      var pill = document.getElementById('ppk-limit-indicator');
      if (pill){
        var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: '+String(n));
        if (pill.textContent !== txt) window.__ppkSetTextSafe(pill, txt);
        pill.setAttribute('data-ppk-val', String(n));
        pill.classList.toggle('ppk-zero', n===0);
        pill.style.display = 'inline-block'; pill.hidden = false;
      }
      var t = document.getElementById('ppk-remaining');
      if (t){
        var s = 'Verfügbar: ' + String(n);
        if (t.textContent !== s) t.textContent = s;
      }
    }
    function startLoop(){
      if (loop) return;
      loop = setInterval(function(){
        if (!inFreeze()){ clearInterval(loop); loop=null; return; }
        if (lastGood.n!=null) applyVal(lastGood.n);
      }, 50);
    }

    function armFreeze(){
      var v = readVal(); if (v!=null) lastGood.n = v;
      F.okFreezeUntil = now() + 3000;
      applyVal(lastGood.n);
      startLoop();
    }

    // Bind specifically to the modal OK
    document.addEventListener('click', function(ev){
      var el = ev.target;
      if (!el) return;
      var ok = el.closest && el.closest('#rb-confirm-ok');
      if (ok){
        armFreeze();
      }
    }, {capture:true});

    // Block writes during freeze
    var _origSet = (typeof window.setRemaining === 'function') ? window.setRemaining : null;
    window.setRemaining = function(n){
      if (inFreeze()){ if (lastGood.n!=null) applyVal(lastGood.n); return Number(n||0); }
      if (typeof _origSet === 'function') return _origSet.apply(this, arguments);
      var v = Number(n||0);
      var t = document.getElementById('ppk-remaining'); if (t) t.textContent = 'Verfügbar: ' + String(v);
      return v;
    };
    var _origShow = window.showLimit;
    window.showLimit = function(n){
      if (inFreeze()){ if (lastGood.n!=null) applyVal(lastGood.n); return Number(n||0); }
      if (typeof _origShow === 'function') return _origShow.apply(this, arguments);
      applyVal(Number(n||0));
      return n;
    };
    document.addEventListener('ppk:cart:updated', function(ev){ if(inFreeze()){ try{ev.stopImmediatePropagation();}catch(_){ } if(lastGood.n!=null) applyVal(lastGood.n);} }, {capture:true});
    document.addEventListener('ppk:order:checked', function(ev){ if(inFreeze()){ try{ev.stopImmediatePropagation();}catch(_){ } if(lastGood.n!=null) applyVal(lastGood.n);} }, {capture:true});
  }catch(e){ console.warn('ppk-guard-rb-confirm-ok error:', e); }
})();
</script>
<script id="ppk-buyer-hardlock-nosmooth">
(function(){
  try{
    // Nur im Buyer-Mode aktiv
    var qs = new URLSearchParams(location.search||"");
    var isBuyer = (qs.get('mode')||'').toLowerCase()==='buyer';
    if(!isBuyer) return;

    var sheetOK = false;
    var lastGood = null;

    function readGood(){
      var pill = document.getElementById('ppk-limit-indicator');
      var a = pill && pill.getAttribute && pill.getAttribute('data-ppk-val');
      var n = (a!=null && !isNaN(+a)) ? +a : null;
      return n;
    }
    function applyBoth(n){
      if(n==null) return;
      var pill = document.getElementById('ppk-limit-indicator');
      if (pill){
        var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: '+n);
        window.__ppkSetTextSafe(pill, txt);
        pill.setAttribute('data-ppk-val', String(n));
        pill.classList.toggle('ppk-zero', n===0);
      }
      var rem = document.getElementById('ppk-remaining');
      if (rem) rem.textContent = 'Verfügbar: ' + n;
    }

    // Nach erfolgreichem Tabellen-Check: letzten guten Wert merken und Smooth deaktivieren
    document.addEventListener('ppk:order:checked', function(ev){
      sheetOK = true;
      lastGood = readGood();
      // 1) Smooth-Funktionen neutralisieren
      if (window.renderSmart)      try{ window.renderSmart = function(){}; }catch(_){}
      if (window.computeAndRender) try{ window.computeAndRender = function(){}; }catch(_){}
      // 2) requestAnimationFrame-Wrapper: blockiert nur bekannte Render-Loops
      var _raf = window.requestAnimationFrame;
      if (!_raf || _raf.__ppkWrapped) return;
      function wrappedRAF(cb){
        try{
          var name = (cb && cb.name)||'';
          if (name==='renderSmart' || name==='computeAndRender') {
            return 0; // ignorieren
          }
        }catch(_){}
        return _raf.apply(this, arguments);
      }
      wrappedRAF.__ppkWrapped = true;
      try{ window.requestAnimationFrame = wrappedRAF; }catch(_){}
    }, {capture:true});

    // Guard: 0-Schreibungen von überall blocken, solange der Tabellenstand führend ist
    var _setRem = window.setRemaining;
    window.setRemaining = function(n){
      var v = Number(n||0);
      if (sheetOK && v===0){
        if (lastGood==null) lastGood = readGood();
        if (lastGood!=null) applyBoth(lastGood);
        return v;
      }
      lastGood = (v || lastGood);
      return (typeof _setRem==='function') ? _setRem.apply(this, arguments) : v;
    };
    var _showLim = window.showLimit;
    window.showLimit = function(n){
      var v = Number(n||0);
      if (sheetOK && v===0){
        if (lastGood==null) lastGood = readGood();
        if (lastGood!=null) applyBoth(lastGood);
        return v;
      }
      lastGood = (v || lastGood);
      return (typeof _showLim==='function') ? _showLim.apply(this, arguments) : v;
    };
  }catch(e){ console.warn('ppk-buyer-hardlock-nosmooth error:', e); }
})();
</script>
<script id="ppk-hardlock-v3-precheck">
/* Hard-Lock V3
 * 1) PRE-CHECK-FREEZE: Bis zum ersten ppk:order:checked werden alle setRemaining(0)/showLimit(0) ignoriert.
 *    Werte > 0 gehen durch (falls qty in URL testweise gesetzt ist).
 * 2) NACH CHECK: Nur echte Quellen (Backend/Warenkorb) dürfen noch 0 schreiben (über separate Whitelist, falls vorhanden).
 */
(function(){
  try{
    var preFreeze = true;   // aktiv bis CHECK_OK
    var lastGood  = null;

    function readGood(){
      var pill = document.getElementById('ppk-limit-indicator');
      var a = pill && pill.getAttribute && pill.getAttribute('data-ppk-val');
      var n = (a!=null && !isNaN(+a)) ? +a : null;
      return n;
    }
    function applyBoth(n){
      var pill = document.getElementById('ppk-limit-indicator');
      if (pill){
        var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: '+n);
        window.__ppkSetTextSafe(pill, txt);
        pill.setAttribute('data-ppk-val', String(n));
        pill.classList.toggle('ppk-zero', n===0);
      }
      var rem = document.getElementById('ppk-remaining');
      if (rem) rem.textContent = 'Verfügbar: ' + n;
    }

    document.addEventListener('ppk:order:checked', function(){
      preFreeze = false; // ab jetzt übernimmt Backend/Whitelist
    }, {capture:true});

    // Hooken
    var _setRem  = window.setRemaining;
    var _showLim = window.showLimit;

    window.setRemaining = function(n){
      var v = Number(n||0);
      if (preFreeze && v===0){
        if (lastGood==null) lastGood = readGood();
        if (lastGood!=null) applyBoth(lastGood);
        return v;
      }
      if (!preFreeze && v>0) lastGood = v;
      return (typeof _setRem==='function') ? _setRem.apply(this, arguments) : v;
    };

    window.showLimit = function(n){
      var v = Number(n||0);
      if (preFreeze && v===0){
        if (lastGood==null) lastGood = readGood();
        if (lastGood!=null) applyBoth(lastGood);
        return v;
      }
      if (!preFreeze && v>0) lastGood = v;
      return (typeof _showLim==='function') ? _showLim.apply(this, arguments) : v;
    };

    // Initialen "guten" Wert merken (falls vorhanden)
    lastGood = readGood();
  }catch(e){ console.warn('hardlock-v3 error:', e); }
})();
</script>
<script id="ppk-ok-freeze-only">
/* Einzelschritt: OK-Freeze ohne Einfluss auf "Prüfen"
   - Beim Klick auf #rb-confirm-ok: 2.5s Freeze, währenddessen werden 0-Schreibungen ignoriert.
   - Prüfen/Warenkorb bleiben unberührt.
   - Rote Pille wird mit #ppk-remaining synchronisiert, falls dieser Text >0 bekommt.
*/
(function(){
  try{
    var freezeUntil = 0;
    function now(){ return Date.now(); }
    function inFreeze(){ return now() < freezeUntil; }

    // OK im Pflanzenwechsel → Freeze kurz aktivieren
    document.addEventListener('click', function(ev){
      var ok = ev.target && ev.target.closest && ev.target.closest('#rb-confirm-ok');
      if (ok){ freezeUntil = now() + 2500; }
    }, {capture:true});

    // Hilfsfunktionen
    function syncPill(n){
      var pill = document.getElementById('ppk-limit-indicator');
      if (!pill || typeof n !== 'number') return;
      var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + n);
      window.__ppkSetTextSafe(pill, txt);
      pill.setAttribute('data-ppk-val', String(n));
      if (pill.classList) pill.classList.toggle('ppk-zero', n===0);
    }

    // Setter-Hooks (nur 0 während Freeze blocken, sonst durchlassen)
    var _set = window.setRemaining;
    window.setRemaining = function(n){
      var v = Number(n||0);
      if (v===0 && inFreeze()) return v;    // 0 ignorieren, kein Seiteneffekt
      return (typeof _set === 'function') ? _set.apply(this, arguments) : v;
    };
    var _show = window.showLimit;
    window.showLimit = function(n){
      var v = Number(n||0);
      if (v===0 && inFreeze()) return v;    // 0 ignorieren
      return (typeof _show === 'function') ? _show.apply(this, arguments) : v;
    };

    // Sichtbaren Text "Verfügbar: n" beobachten und Pille nachziehen
    var rem = document.getElementById('ppk-remaining');
    if (rem && window.MutationObserver){
      var mo = new MutationObserver(function(){
        try{
          var m = String(rem.textContent||'').match(/Verfügbar:\s*(\d+)/i);
          if (m){
            var n = parseInt(m[1],10);
            if (!isNaN(n)) syncPill(n);
          }
        }catch(_){}
      });
      mo.observe(rem, {characterData:true, childList:true, subtree:true});
    }
  }catch(e){ console.warn('ppk-ok-freeze-only error:', e); }
})();
</script>
<script id="ppk-pill-cart-aware-v1">
/* Einzelschritt: Roter Button = Tabellenwert MINUS Warenkorb (cart-aware)
   - Backend-Stand aus ppk:order:checked (detail.remaining | total-used)
   - Warenkorb-Stand über:
       a) Event 'ppk:cart:updated' mit detail.count oder detail.pending
       b) Bridge: window.ppkCartSetPending(n)  (kannst du beim Add/Remove aufrufen)
   - Anti-Zucken: nur rendern, wenn sich der Wert wirklich ändert.
   - OK-Freeze (aus vorherigem Patch) bleibt aktiv.
*/
(function(){
  try{
    var S = { backendRem:null, cartCount:0, lastRendered:null };
    function clamp(n){ n = Number(n||0); return (n<0)?0:n; }
    function compute(){ 
      if (S.backendRem==null) return null;
      var v = clamp(S.backendRem - clamp(S.cartCount));
      return v;
    }
    function render(){
      var v = compute();
      if (v === S.lastRendered || v == null) return;
      S.lastRendered = v;
      var pill = document.getElementById('ppk-limit-indicator');
      if (!pill) return;
      var txt = (v===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + v);
      if (pill.textContent !== txt) window.__ppkSetTextSafe(pill, txt);
      pill.setAttribute('data-ppk-val', String(v));
      if (pill.classList) pill.classList.toggle('ppk-zero', v===0);
    }

    // Backend-Stand setzen
    document.addEventListener('ppk:order:checked', function(ev){
      try{
        var d = ev && ev.detail || {};
        // bevorzugt 'remaining'; sonst total-used
        var rem = null;
        if (typeof d.remaining === 'number') rem = d.remaining;
        else if (typeof d.total==='number' && typeof d.used==='number') rem = Math.max(0, d.total - d.used);
        if (rem != null){ S.backendRem = clamp(rem); render(); }
      }catch(_){}
    }, {capture:true});

    // Sichtbarer Text "Verfügbar: n" beobachten → als Backend-Stand interpretieren
    // (Falls ein anderes Script den Text schreibt)
    var remEl = document.getElementById('ppk-remaining');
    if (remEl && window.MutationObserver){
      var mo = new MutationObserver(function(){
        try{
          var m = String(remEl.textContent||'').match(/Verfügbar:\s*(\d+)/i);
          if (m){ S.backendRem = clamp(parseInt(m[1],10)); render(); }
        }catch(_){}
      });
      mo.observe(remEl, {characterData:true, childList:true, subtree:true});
    }

    // Warenkorb-Stand: event-basiert
    document.addEventListener('ppk:cart:updated', function(ev){
      try{
        var d = ev && ev.detail || {};
        var c = (typeof d.count==='number') ? d.count :
                (typeof d.pending==='number') ? d.pending : null;
        if (c != null){ S.cartCount = clamp(c); render(); }
      }catch(_){}
    }, {capture:true});

    // Bridge-Funktion: manuell setzen
    window.ppkCartSetPending = function(n){
      S.cartCount = clamp(n);
      render();
    };

    // Initialer Versuch: Falls Pillen-Attribut schon gesetzt war
    document.addEventListener('DOMContentLoaded', function(){
      var pill = document.getElementById('ppk-limit-indicator');
      if (pill){
        var a = pill.getAttribute('data-ppk-val');
        if (a!=null && a!=='' && !isNaN(+a)){ S.lastRendered = +a; }
      }
    });
  }catch(e){ console.warn('ppk-pill-cart-aware-v1 error:', e); }
})();
</script>
<script id="ppk-availability-controller">
(function(){
  try{
    // State
    var checked = false;
    var availableChecked = null;
    var debounceTimer = null;

    function $(sel){ return document.querySelector(sel); }
    function asInt(txt){
      var n = parseInt(String(txt).replace(/[^\d\-]/g,''),10);
      return isNaN(n) ? 0 : n;
    }
    function totalCart(){
      try{
        var items = (window.__ppkCart && window.__ppkCart.get && window.__ppkCart.get()) || [];
        var t = 0;
        for (var i=0;i<items.length;i++){
          var q = items[i] && (items[i].qty!=null ? items[i].qty : items[i].meta && items[i].meta.qty);
          t += asInt(q);
        }
        return t;
      }catch(_){ return 0; }
    }
    function pillNodes(){
      var ids = [
        '#ppk-availability-pill',
        '#ppk-availability-pill-v1',
        '#ppk-pill-cart-aware-v1'
      ];
      var out = [];
      ids.forEach(function(id){ var n = $(id); if(n) out.push(n); });
      return out;
    }
    function setText(el, txt){
      if (!el) return;
      var s = String(txt);
      if (el.textContent !== s){
        if (window.__ppkSetTextSafe){ window.__ppkSetTextSafe(el, s); }
        else { el.textContent = s; }
      }
    }
    function updatePill(){
      if (!checked || availableChecked==null) return;
      var rem = Math.max(0, asInt(availableChecked) - totalCart());
      pillNodes().forEach(function(n){ setText(n, rem); });
    }
    function maskBeforeCheck(){
      if (checked) return;
      var remEl = $('#ppk-remaining');
      if (remEl) setText(remEl, '—');
      pillNodes().forEach(function(n){ setText(n, '—'); });
    }
    // Run masks early
    document.addEventListener('DOMContentLoaded', maskBeforeCheck);
    maskBeforeCheck();

    // Observe unwanted writes before 'checked'
    var targetEls = [];
    var remEl = $('#ppk-remaining');
    if (remEl) targetEls.push(remEl);
    targetEls = targetEls.concat(pillNodes());
    targetEls.forEach(function(el){
      try{
        var mo = new MutationObserver(function(){
          if (!checked){
            // keep masked until order is checked
            maskBeforeCheck();
          } else {
            // if checked, enforce computed value
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(updatePill, 0);
          }
        });
        mo.observe(el, { characterData:true, childList:true, subtree:true });
      }catch(_){}
    });

    // When order is checked by backend
    window.addEventListener('ppk:order:checked', function(){
      var el = $('#ppk-remaining');
      if (el){
        availableChecked = asInt(el.textContent);
        checked = true;
        updatePill();
      }
    }, true);

    // Cart updates always reflow pill after checked
    window.addEventListener('ppk:cart:updated', function(){
      if (!checked) return;
      updatePill();
    }, true);

    // Optional: on plant change, some scripts rewrite displays. Counter that with a short debounce.
    window.addEventListener('change', function(ev){
      var t = ev && ev.target;
      if (!t) return;
      if (/pflanze|plant|species|variante|option/i.test(t.name||t.id||'')){
        if (!checked){
          maskBeforeCheck();
        } else {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(updatePill, 0);
        }
      }
    }, true);
  }catch(e){ console.warn('ppk-availability-controller error:', e); }
})();
</script>
<script id="ppk-check-orchestrator">
(function(){
  'use strict';
  function $(sel){ return document.querySelector(sel); }
  function $all(sel){ return Array.prototype.slice.call(document.querySelectorAll(sel)); }
  function asInt(txt){ var n = parseInt(String(txt||'').replace(/[^0-9\-]/g,''),10); return isNaN(n)?0:n; }
  function setText(el, txt){ if(!el) return; var s = String(txt); if (el.textContent!==s) el.textContent = s; }
  function isBtn(el){ return el && (el.tagName==='BUTTON' || el.getAttribute('role')==='button' || el.tagName==='A'); }

  function markCheckButtons(){
    var candidates = $all('button,[role=\"button\"],a,[data-action]');
    candidates.forEach(function(el){
      try{
        var lab = (el.innerText||el.textContent||'').trim();
        var act = (el.getAttribute('data-action')||'').trim();
        if (/(^|\\b)(prüfen|pruefen|check)(\\b|$)/i.test(lab) || /check/i.test(act)){
          el.setAttribute('data-ppk-check','1');
        }
      }catch(_){}
    });
  }

  function runCheck(){
    try{ if (typeof window.runOrderCheck==='function'){ window.runOrderCheck(); return true; } }catch(_){}
    try{ if (window.__ppkOrder && typeof window.__ppkOrder.check==='function'){ window.__ppkOrder.check(); return true; } }catch(_){}
    var btn = $('[data-ppk-check=\"1\"]') || $('#ppk-check') || $('#btn-check') || $('#check-order') || $('[data-action=\"check\"]');
    if (isBtn(btn)){ try{ btn.click(); return true; }catch(_){} }
    try{ window.dispatchEvent(new CustomEvent('ppk:order:checked')); return true; }catch(_){}
    return false;
  }
  window.__ppkForceCheck = runCheck;

  var checked = false;
  var availableChecked = null;
  var debounce = null;

  function totalCart(){
    try{
      var items = (window.__ppkCart && window.__ppkCart.get && window.__ppkCart.get()) || [];
      var t=0; for (var i=0;i<items.length;i++){ var q = items[i] && (items[i].qty!=null? items[i].qty : items[i].meta && items[i].meta.qty); t += asInt(q); }
      return t;
    }catch(_){ return 0; }
  }
  function pillNodes(){ return ['#ppk-availability-pill','#ppk-availability-pill-v1','#ppk-pill-cart-aware-v1'].map($).filter(Boolean); }
  function updatePill(){
    if (!checked || availableChecked==null) return;
    var rem = Math.max(0, asInt(availableChecked) - totalCart());
    pillNodes().forEach(function(n){ setText(n, rem); });
  }
  function mask(){
    var rem = $('#ppk-remaining');
    if (rem) setText(rem, '—');
    pillNodes().forEach(function(n){ setText(n, '—'); });
  }

  document.addEventListener('DOMContentLoaded', function(){
    markCheckButtons();
    mask();
  });

  function guard(el){
    try{
      var mo = new MutationObserver(function(){
        if (!checked){ mask(); } else { clearTimeout(debounce); debounce = setTimeout(updatePill, 0); }
      });
      mo.observe(el, {childList:true, characterData:true, subtree:true});
    }catch(_){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    var rem = $('#ppk-remaining'); if (rem) guard(rem);
    pillNodes().forEach(guard);
  });

  window.addEventListener('ppk:order:checked', function(){
    var rem = $('#ppk-remaining');
    if (rem){
      availableChecked = asInt(rem.textContent);
      checked = true;
      updatePill();
    }
  }, true);

  window.addEventListener('ppk:cart:updated', function(){ if (checked) updatePill(); }, true);

  window.addEventListener('change', function(ev){
    var t = ev && ev.target; if (!t) return;
    if (/pflanze|plant|species|variante|option/i.test((t.name||'') + ' ' + (t.id||''))){
      if (!checked){ mask(); } else { clearTimeout(debounce); debounce = setTimeout(updatePill, 0); }
    }
  }, true);

  function hookRbConfirm(){
    if (typeof window.rbConfirm !== 'function') return false;
    var orig = window.rbConfirm;
    window.rbConfirm = function(message){
      var p = orig.call(this, message);
      try{
        if (p && typeof p.then==='function'){
          return p.then(function(ok){
            if (ok){
              setTimeout(function(){
                var okRun = runCheck();
                var t0 = Date.now();
                var itv = setInterval(function(){
                  var rem = $('#ppk-remaining');
                  var txt = rem ? rem.textContent : '';
                  if (/\d/.test(txt)){
                    availableChecked = asInt(txt); checked = true; updatePill(); clearInterval(itv);
                  } else if (Date.now()-t0>1500){ clearInterval(itv); }
                }, 50);
              }, 0);
            }
            return ok;
          });
        }
      }catch(_){}
      setTimeout(function(){ runCheck(); }, 0);
      return p;
    };
    return true;
  }

  if (!hookRbConfirm()){
    var tries = 0;
    var iv = setInterval(function(){
      tries++;
      if (hookRbConfirm() || tries>40) clearInterval(iv);
    }, 50);
  }

  document.addEventListener('click', function(ev){
    var el = ev.target && (ev.target.closest ? ev.target.closest('#rb-confirm-ok') : null);
    if (el){
      setTimeout(function(){
        runCheck();
        var t0 = Date.now();
        var itv = setInterval(function(){
          var rem = $('#ppk-remaining');
          if (rem && /\d/.test(rem.textContent)){
            availableChecked = asInt(rem.textContent);
            checked = true; updatePill(); clearInterval(itv);
          } else if (Date.now()-t0>1500){ clearInterval(itv); }
        }, 50);
      }, 0);
    }
  }, true);
})();
</script>
<script id="ppk-ok-strong-hook">
(function(){
  'use strict';
  function forceCheck(){
    try{ if (typeof window.__ppkForceCheck==='function'){ return window.__ppkForceCheck(); } }catch(_){}
    try{ if (typeof window.runOrderCheck==='function'){ window.runOrderCheck(); return true; } }catch(_){}
    try{ if (window.__ppkOrder && typeof window.__ppkOrder.check==='function'){ window.__ppkOrder.check(); return true; } }catch(_){}
    var btn = document.querySelector('[data-ppk-check="1"],#ppk-check,#btn-check,#check-order,[data-action="check"]');
    if (btn){ try{ btn.click(); return true; }catch(_){ } }
    try{ window.dispatchEvent(new CustomEvent('ppk:order:checked')); return true; }catch(_){}
    return false;
  }
  function bindOk(btn){
    if (!btn || btn.__ppkOkBound) return;
    btn.__ppkOkBound = true;
    btn.addEventListener('click', function(){
      // Let overlay close, then force Prüfen repeatedly for a short window
      var t0 = Date.now();
      var iv = setInterval(function(){
        var ok = forceCheck();
        if (ok || Date.now()-t0>2000){
          clearInterval(iv);
        }
      }, 120);
      // HUD ping if present
      try{
        var trig = document.querySelector('#ppk-d-trigger');
        var note = document.querySelector('#ppk-d-note');
        var dot = document.querySelector('#ppk-d-signal');
        if (trig) trig.textContent = 'OK(#rb-confirm-ok) → Prüfen';
        if (note) note.textContent = 'OK erkannt – Prüfen erzwungen';
        if (dot) dot.className = 'dot warn';
      }catch(_){}
    }, true);
  }
  function scan(){
    var btn = document.getElementById('rb-confirm-ok');
    if (btn) bindOk(btn);
  }
  // Initial scan and continuous observe on overlay container
  document.addEventListener('DOMContentLoaded', function(){
    scan();
    var ov = document.getElementById('rb-confirm-overlay');
    if (ov){
      var mo = new MutationObserver(function(){ scan(); });
      mo.observe(ov, {childList:true, subtree:true});
    } else {
      // fallback: observe body
      var mo2 = new MutationObserver(function(){ scan(); });
      mo2.observe(document.body, {childList:true, subtree:true});
    }
  });
})();
</script>
<script id="ppk-ok-deep-clean">
(function(){
  'use strict';

  // ---------- Utility ----------
  function $(sel){ return document.querySelector(sel); }
  function $all(sel){ return Array.prototype.slice.call(document.querySelectorAll(sel)); }
  function fire(el, type, opts){
    if (!el) return;
    try{
      var ev = new Event(type, Object.assign({bubbles:true,cancelable:true}, opts||{}));
      el.dispatchEvent(ev);
    }catch(_){}
  }
  function pressEnter(el){
    if (!el) return;
    try{
      var e1 = new KeyboardEvent('keydown', {key:'Enter',code:'Enter',keyCode:13,which:13,bubbles:true});
      var e2 = new KeyboardEvent('keyup',   {key:'Enter',code:'Enter',keyCode:13,which:13,bubbles:true});
      el.dispatchEvent(e1); el.dispatchEvent(e2);
    }catch(_){}
  }
  function setHUD(msg, level){
    try{
      var trig = document.querySelector('#ppk-d-trigger');
      var note = document.querySelector('#ppk-d-note');
      var dot = document.querySelector('#ppk-d-signal');
      if (trig) trig.textContent = msg + ' @' + (new Date()).toLocaleTimeString();
      if (note) note.textContent = msg;
      if (dot) dot.className = 'dot ' + (level||'warn');
    }catch(_){}
  }

  // ---------- Prüfen-Sequenz (deeper) ----------
  function tryDeepCheckOnce(){
    // 1) Preferred APIs
    try{ if (typeof window.__ppkForceCheck === 'function'){ if (window.__ppkForceCheck()) return true; } }catch(_){}
    try{ if (typeof window.runOrderCheck === 'function'){ window.runOrderCheck(); return true; } }catch(_){}
    try{ if (window.__ppkOrder && typeof window.__ppkOrder.check === 'function'){ window.__ppkOrder.check(); return true; } }catch(_){}

    // 2) Button routes
    var btn = document.querySelector('[data-ppk-check="1"],#ppk-check,#btn-check,#check-order,[data-action="check"]');
    if (btn){ try{ btn.click(); return true; }catch(_){} }

    // 3) Form submit routes
    var form = document.querySelector('form[action*="check"], form[data-action*="check"], form[id*="check"], form[name*="check"]');
    if (!form){
      // nearest form around order input
      var orderInput = $('#order') || $('[name="order"]') || $('[id*="order"]');
      if (orderInput){
        var n = orderInput;
        while (n && n.nodeType===1){
          if (n.tagName === 'FORM'){ form = n; break; }
          n = n.parentElement;
        }
      }
    }
    if (form){
      try{ form.requestSubmit ? form.requestSubmit() : form.submit(); return true; }catch(_){}
    }

    // 4) Enter key on order input (common shortcut)
    var order = $('#order') || $('[name="order"]') || $('[id*="order"]');
    if (order){
      // ensure change event and then Enter
      try{ fire(order, 'change'); }catch(_){}
      try{ pressEnter(order); return true; }catch(_){}
    }
    return false;
  }

  function ensureDeepCheckAfterOk(){
    var t0 = Date.now();
    var fired = false;
    function stop(){ fired = true; }
    var evh = function(){ stop(); };
    window.addEventListener('ppk:order:checked', evh, {once:true, capture:true});

    var iv = setInterval(function(){
      if (fired || Date.now()-t0 > 2500){
        clearInterval(iv);
        try{ window.removeEventListener('ppk:order:checked', evh, {capture:true}); }catch(_){}
        return;
      }
      tryDeepCheckOnce();
    }, 120);
  }

  // ---------- Capture-Phase Hook auf OK ----------
  // Greift VOR stopImmediatePropagation von anderen Listenern.
  window.addEventListener('click', function(ev){
    var t = ev.target;
    if (!t) return;
    var okBtn = t.closest ? t.closest('#rb-confirm-ok') : null;
    if (okBtn){
      // In capture-phase minimal verzögern, damit Overlay schließen kann.
      setTimeout(function(){
        setHUD('OK(#rb-confirm-ok) – Deep-Check startet','warn');
        ensureDeepCheckAfterOk();
      }, 0);
    }
  }, true); // <-- capture

  // ---------- Safety: Wenn Overlay zugeht, auch starten ----------
  document.addEventListener('DOMContentLoaded', function(){
    var ov = document.getElementById('rb-confirm-overlay');
    if (!ov) return;
    var mo = new MutationObserver(function(){
      var v = ov.getAttribute('data-show');
      if (v === '0'){
        setTimeout(function(){
          setHUD('Overlay geschlossen – Deep-Check startet','warn');
          ensureDeepCheckAfterOk();
        }, 0);
      }
    });
    mo.observe(ov, { attributes:true, attributeFilter:['data-show'] });
  });
})();
</script>
<script id="ppk-ok-hook-min">
(function(){
  'use strict';
  function runCheck(){
    try{ if (typeof window.__ppkForceCheck==='function') return window.__ppkForceCheck(); }catch(_){}
    try{ if (typeof window.runOrderCheck==='function'){ window.runOrderCheck(); return true; } }catch(_){}
    var btn = document.querySelector('[data-ppk-check="1"],#ppk-check,#btn-check,#check-order,[data-action="check"]');
    if (btn){ try{ btn.click(); return true; }catch(_){ } }
    return false;
  }
  window.addEventListener('click', function(ev){
    var okBtn = ev.target && ev.target.closest ? ev.target.closest('#rb-confirm-ok') : null;
    if (!okBtn) return;
    setTimeout(function(){
      var t0 = Date.now(), got=false;
      function stop(){ got=true; }
      window.addEventListener('ppk:order:checked', stop, {once:true, capture:true});
      var iv = setInterval(function(){
        if (got || Date.now()-t0>2000){ clearInterval(iv); return; }
        runCheck();
      }, 120);
    }, 0);
  }, true);
})();
</script>
<script id="ppk-availability-guard-min">
(function(){
  'use strict';
  function $(s){ return document.querySelector(s); }
  function asInt(x){ var n=parseInt(String(x||'').replace(/[^0-9\-]/g,''),10); return isNaN(n)?0:n; }
  var checked=false, availableChecked=null, debounce=null;
  var pillSel=['#ppk-limit-indicator','#ppk-availability-pill','#ppk-pill-cart-aware-v1'];
  function setText(el,txt){ if(el && el.textContent!==String(txt)) el.textContent=String(txt); }
  function mask(){
    setText($('#ppk-remaining'),'—');
    pillSel.map($).filter(Boolean).forEach(function(n){ setText(n,'—'); });
  }
  function totalCart(){
    try{
      var items=(window.__ppkCart && window.__ppkCart.get && window.__ppkCart.get())||[];
      var t=0; for (var i=0;i<items.length;i++){ var q=items[i] && (items[i].qty!=null?items[i].qty:items[i].meta&&items[i].meta.qty); t+=asInt(q); }
      return t;
    }catch(_){ return 0; }
  }
  function updatePill(){
    if(!checked || availableChecked==null) return;
    var rem=Math.max(0, availableChecked-totalCart());
    pillSel.map($).filter(Boolean).forEach(function(n){ setText(n,rem); });
  }
  document.addEventListener('DOMContentLoaded', mask);
  [$('#ppk-remaining')].concat(pillSel.map($)).filter(Boolean).forEach(function(el){
    try{
      new MutationObserver(function(){
        if(!checked){ mask(); } else { clearTimeout(debounce); debounce=setTimeout(updatePill,0); }
      }).observe(el,{childList:true,characterData:true,subtree:true});
    }catch(_){}
  });
  window.addEventListener('ppk:order:checked', function(){
    var t=$('#ppk-remaining'); if(t){ availableChecked=asInt(t.textContent); checked=true; updatePill(); }
  }, true);
  window.addEventListener('ppk:cart:updated', function(){ if(checked) updatePill(); }, true);
})();
</script>
<script id="ppk-limit-cart-aware-min">
(function(){
  'use strict';
  var S={total:null,used:0,remaining:null,inCart:0}, lastTxt=null, pillId='ppk-limit-indicator';
  function safeInt(x){ var n=parseInt(x,10); return isNaN(n)?0:n; }
  function countCart(){
    try{
      if (window.__ppkCart && window.__ppkCart.get){
        return (window.__ppkCart.get()||[]).reduce(function(a,it){ return a + safeInt(it && it.qty); }, 0);
      }
    }catch(_){}
    return safeInt(S.inCart||0);
  }
  function baseRemaining(){
    if (typeof S.total==='number' && typeof S.used==='number') return Math.max(0,S.total-S.used);
    if (typeof S.remaining==='number') return Math.max(0,S.remaining);
    return null;
  }
  function render(){
    var pill=document.getElementById(pillId); if(!pill) return;
    var base=baseRemaining(); if(base==null) return;
    var disp=Math.max(0, base-countCart());
    var txt=(disp===0)?'Limit erreicht: 0 verfügbar':'Verfügbar: '+disp;
    if (txt!==lastTxt){ lastTxt=txt; pill.textContent=txt; pill.setAttribute('data-ppk-val', String(disp)); pill.classList.toggle('ppk-zero',disp===0); }
  }
  document.addEventListener('ppk:order:checked', function(ev){
    var d=ev && ev.detail || {};
    if (typeof d.total==='number') S.total=d.total;
    if (typeof d.used==='number') S.used=d.used;
    if (typeof d.remaining==='number') S.remaining=d.remaining;
    render();
  }, {passive:true});
  document.addEventListener('ppk:cart:updated', function(){ S.inCart=countCart(); render(); }, {passive:true});
  window.ppkCartSetPending=function(n){ S.inCart=Math.max(0,safeInt(n)); document.dispatchEvent(new CustomEvent('ppk:cart:updated',{detail:{reason:'bridge'}})); };
})();
</script>
<!-- PPK Inline-Check + Sheets-Wiring + OK-Hook + Anti-Flackern  -->
<style id="ppk-inline-check-style">
#ppk-inline-wrap{display:flex;align-items:center;gap:10px;margin-left:10px;flex-wrap:wrap}
#ppk-inline-wrap label{font-weight:600}
#ppk-inline-wrap input{height:30px;border:1px solid #b0bec5;border-radius:8px;padding:0 10px;min-width:260px}
#ppk-inline-wrap button{height:30px;padding:0 12px;border:0;border-radius:8px;background:#2E7D32;color:#fff;cursor:pointer}
#ppk-status{display:none;padding:6px 10px;border-radius:8px;font-size:13px}
#ppk-status.ok{display:inline-flex;align-items:center;gap:8px;background:#e8f5e9;color:#1b5e20;border:1px solid #a5d6a7}
#ppk-status.err{display:inline-flex;align-items:center;gap:8px;background:#ffebee;color:#b71c1c;border:1px solid #ef9a9a}
#ppk-status .server{opacity:.75;font-style:italic}
#ppk-status button{height:24px;padding:0 8px;border-radius:6px;background:#eceff1;color:#37474f}
/* Pille (falls noch nicht vorhanden) */
#ppk-availability-pill{display:inline-block;padding:8px 14px;border-radius:18px;font-weight:600;border:1px solid rgba(0,0,0,.15);background:#cdeccd;color:#104010;box-shadow:0 1px 2px rgba(0,0,0,.08)}
#ppk-availability-pill.ppk-zero{background:#b33434;color:#fff;border-color:#9a2b2b}
</style>
<script id="ppk-inline-check-core">
(function(){
  'use strict';
  // ---- Konfiguration (nicht überschreiben, falls bereits gesetzt) ----
  window.PPK_CONFIG = Object.assign({}, window.PPK_CONFIG||{}, {
    CHECK_ENDPOINT: (window.PPK_CONFIG && window.PPK_CONFIG.CHECK_ENDPOINT) || 'https://script.google.com/macros/s/AKfycbzYcJ8h49o7j-HinFB06rAVpJV7ypaYqxHGKX9O0kHjMQ0ecSXDsglFlOdb3kHmaGpV9g/exec',
    CHECK_METHOD:   (window.PPK_CONFIG && window.PPK_CONFIG.CHECK_METHOD)   || 'GET',
    CHECK_PARAM:    (window.PPK_CONFIG && window.PPK_CONFIG.CHECK_PARAM)    || 'order'
  });

  // ---- kleine Utils ----
  function $(s){ return document.querySelector(s); }
  function $all(s){ return Array.prototype.slice.call(document.querySelectorAll(s)); }
  function asInt(x){ var m=String(x==null?'':x).match(/-?\d+/); return m?parseInt(m[0],10):0; }
  function coerceAvailable(data){
    if (data==null) return null;
    if (typeof data==='number') return data;
    if (typeof data==='string') return asInt(data);
    var keys=['available','verfuegbar','verfügbar','remaining','rest','anzahl','count','qty','qty_available','limit','frei','free'];
    for (var i=0;i<keys.length;i++){ var k=keys[i]; if (data[k]!=null) return asInt(data[k]); }
    // letzte Chance: erster numerischer Wert
    for (var k2 in data){ var n=asInt(data[k2]); if (!isNaN(n) && String(data[k2]).trim()!=='') return n; }
    return null;
  }

  // ---- Verfügbar-Pille bereitstellen und in die hellblaue Leiste ziehen ----
  function ensurePill(){
    var pill = $('#ppk-availability-pill');
    if (!pill){
      pill = document.createElement('div');
      pill.id='ppk-availability-pill';
      pill.innerHTML = 'Verfügbar: <span id="ppk-remaining">—</span>';
    }
    return pill;
  }
  function movePillIntoBlueBanner(){
    var pill = ensurePill();
    var nodes=$all('div,section,header,p,span');
    var banner=null, textEl=null, reInfo=/Kaufmodus\s*–\s*Menge wird automatisch gegen deine Bestellung geprüft\./i;
    for (var i=0;i<nodes.length;i++){ var n=nodes[i], t=(n.textContent||'').replace(/\s+/g,' ').trim(); if (reInfo.test(t)){ banner=n.parentElement||n; textEl=n; break; } }
    if (!banner) return;
    if (textEl) textEl.style.display='none';
    banner.style.display='flex'; banner.style.alignItems='center'; banner.style.gap='12px'; banner.style.justifyContent='flex-start';
    if (pill.parentElement!==banner) banner.insertBefore(pill, banner.firstChild);
    pill.style.marginRight='12px';
  }
  function setRemaining(n){
    var r=$('#ppk-remaining'); if(r) r.textContent=String(n);
    var pill=$('#ppk-availability-pill');
    if(pill){ pill.classList.toggle('ppk-zero', parseInt(n,10)<=0); }
  }

  // ---- Inline Prüfen UI einbauen ----
  function buildInline(){
    movePillIntoBlueBanner();
    var nodes=$all('div,section,header,p,span');
    var banner=null, reInfo=/Kaufmodus\s*–\s*Menge wird automatisch gegen deine Bestellung geprüft\./i;
    for (var i=0;i<nodes.length;i++){ var n=nodes[i], t=(n.textContent||'').replace(/\s+/g,' ').trim(); if (reInfo.test(t)){ banner=n.parentElement||n; break; } }
    if (!banner) return;

    var old=$('#ppk-inline-wrap'); if(old) old.remove();
    var wrap=document.createElement('div'); wrap.id='ppk-inline-wrap';
    wrap.innerHTML='<label for="ppk-order">Bestellnummer:</label><input id="ppk-order" placeholder="z. B. 20250922-9LR2E" />'+
                   '<button id="ppk-check-inline">Prüfen</button>'+
                   '<span id="ppk-status"><span class="msg"></span> <span class="server"></span> <button id="ppk-status-ok" type="button">OK</button></span>';
    banner.appendChild(wrap);

    function setStatus(type,msg,server){
      var st=$('#ppk-status'), msgEl=$('#ppk-status .msg'), srv=$('#ppk-status .server');
      if(!st) return;
      st.className=''; st.classList.add(type);
      if(msgEl) msgEl.textContent=msg||'';
      if(srv)   srv.textContent = server ? '(Prüfserver: '+server+')' : '';
      st.style.display='inline-flex';
    }

    var btn=$('#ppk-check-inline'); if(btn){ btn.addEventListener('click', function(e){ e.preventDefault(); if(window.runOrderCheck) window.runOrderCheck(); }, false); }
    var inp=$('#ppk-order'); if(inp){ inp.addEventListener('keydown', function(e){ if(e.key==='Enter'){ e.preventDefault(); if(window.runOrderCheck) window.runOrderCheck(); } }, false); }
    var ok=$('#ppk-status-ok'); if(ok){ ok.addEventListener('click', function(){ var st=$('#ppk-status'); if(st) st.style.display='none'; }, false); }

    window.addEventListener('ppk:order:checked', function(ev){
      var det=(ev&&ev.detail)||{};
      var server=(window.PPK_CONFIG&&window.PPK_CONFIG.CHECK_ENDPOINT)? new URL(window.PPK_CONFIG.CHECK_ENDPOINT).hostname : '';
      setStatus('ok','OK – verfügbar: '+det.available, server);
    }, true);
    window.addEventListener('ppk:order:check-failed', function(ev){
      var det=(ev&&ev.detail)||{};
      var server=(window.PPK_CONFIG&&window.PPK_CONFIG.CHECK_ENDPOINT)? new URL(window.PPK_CONFIG.CHECK_ENDPOINT).hostname : '';
      setStatus('err', det.message||'Fehler beim Prüfen', server);
    }, true);

    // Alle alten Prüfen-Buttons ausblenden (außer unserem)
    $all('button,[role="button"],a').forEach(function(el){
      try{
        if (wrap.contains(el)) return;
        var txt=(el.innerText||el.textContent||'').trim();
        var act=(el.getAttribute('data-action')||'').trim();
        if (/^(prüfen|pruefen|check)$/i.test(txt) || /\bcheck\b/i.test(act)){
          el.style.display='none';
        }
      }catch(_){}
    });
  }

  // ---- Sheets-Check ----
  async function runOrderCheck(){
    var cfg=window.PPK_CONFIG||{};
    var ep=cfg.CHECK_ENDPOINT||'';
    if(!ep) throw new Error('Kein CHECK_ENDPOINT konfiguriert.');
    var method=(cfg.CHECK_METHOD||'GET').toUpperCase();
    var param=encodeURIComponent(cfg.CHECK_PARAM||'order');
    var inp=$('#ppk-order'); var order=(inp && inp.value || '').trim();
    if(!order){ if(inp) inp.focus(); throw new Error('Bitte Bestellnummer eingeben'); }
    var url=ep; var fetchOpts={method:method, headers:{}};
    if(method==='GET') url += (ep.indexOf('?')>=0?'&':'?')+param+'='+encodeURIComponent(order);
    else { fetchOpts.headers['Content-Type']='application/json'; fetchOpts.body=JSON.stringify({ [cfg.CHECK_PARAM||'order']: order }); }
    var res = await fetch(url, fetchOpts);
    var txt = await res.text();
    var data={}; try{ data=JSON.parse(txt); }catch(_){ data={ raw:txt }; }
    window.__DEBUG__ && console.debug('[PPK Sheets raw]', txt);
    var avail = coerceAvailable(data);
    if (avail==null) throw new Error('Sheets-Antwort ohne verfügbare Zahl');
    setRemaining(avail);
    window.dispatchEvent(new CustomEvent('ppk:order:checked', { detail:{ order: order, available: avail, source:'sheets' } }));
    return true;
  }
  window.runOrderCheck = runOrderCheck;

  // ---- OK->Prüfen Hook (robust) ----
  (function(){
    if (window.__ppkOkHookBound) return; window.__ppkOkHookBound = true;
    function isVisible(el){ if(!el) return false; var cs=getComputedStyle(el); return cs.display!=='none'&&cs.visibility!=='hidden'&&el.offsetParent!==null; }
    function triggerOnce(){
      try{ if (typeof window.__ppkForceCheck==='function') return !!window.__ppkForceCheck(); }catch(_){}
      try{ if (typeof window.runOrderCheck==='function'){ window.runOrderCheck(); return true; } }catch(_){}
      var btn = $('#ppk-check-inline') || $('[data-ppk-check="1"]') || $('#ppk-check') || $('#btn-check') || $('#check-order') || document.querySelector('[data-action="check"]');
      if (btn && isVisible(btn)){ try{ btn.click(); return true; }catch(_){ } }
      var inp=$('#ppk-order') || document.querySelector('[name="order"]') || document.querySelector('[id*="order"]');
      var form=null;
      if (inp){ var n=inp; while(n && n.nodeType===1){ if(n.tagName==='FORM'){ form=n; break; } n=n.parentElement; } if(form){ try{ (form.requestSubmit?form.requestSubmit():form.submit()); return true; }catch(_){ } } }
      try{ window.dispatchEvent(new CustomEvent('ppk:ui:check')); return true; }catch(_){}
      return false;
    }
    function ensureAfterOk(){
      var t0=Date.now(), got=false; function stop(){ got=true; }
      window.addEventListener('ppk:order:checked', stop, {once:true, capture:true});
      var iv=setInterval(function(){
        if (got || Date.now()-t0>2500){ clearInterval(iv); return; }
        triggerOnce();
      }, 140);
    }
    window.addEventListener('click', function(ev){
      var ok = ev.target && ev.target.closest ? ev.target.closest('#rb-confirm-ok') : null;
      if(!ok) return;
      setTimeout(ensureAfterOk, 0);
    }, true);
    function bindOverlayObserver(){
      var ov = document.getElementById('rb-confirm-overlay');
      if(!ov) return;
      var mo = new MutationObserver(function(){
        var v = ov.getAttribute('data-show');
        if (v==='0'){ setTimeout(ensureAfterOk, 0); }
      });
      mo.observe(ov,{attributes:true, attributeFilter:['data-show']});
    }
    if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', bindOverlayObserver);
    else bindOverlayObserver();
  })();

  // ---- Anti-Flackern + cart-aware Anzeige ----
  (function(){
    function $(s){ return document.querySelector(s); }
    function asInt(x){ var n=parseInt(String(x||'').replace(/[^0-9\-]/g,''),10); return isNaN(n)?0:n; }
    var checked=false, availableChecked=null, debounce=null;
    var pillSel=['#ppk-limit-indicator','#ppk-availability-pill','#ppk-pill-cart-aware-v1'];
    function setText(el,txt){ if(el && el.textContent!==String(txt)) el.textContent=String(txt); }
    function mask(){
      var r=$('#ppk-remaining'); if(r) setText(r,'—');
      pillSel.map($).filter(Boolean).forEach(function(n){ setText(n,'—'); });
    }
    function cartTotal(){
      try{
        var items=(window.__ppkCart && window.__ppkCart.get && window.__ppkCart.get())||[];
        var t=0; for (var i=0;i<items.length;i++){ var q=items[i] && (items[i].qty!=null?items[i].qty:items[i].meta&&items[i].meta.qty); t+=asInt(q); } return t;
      }catch(_){ return 0; }
    }
    function updatePill(){
      if(!checked || availableChecked==null) return;
      var rem=Math.max(0, availableChecked-cartTotal());
      pillSel.map($).filter(Boolean).forEach(function(n){ setText(n, rem); });
      var pill=$('#ppk-availability-pill'); if(pill) pill.classList.toggle('ppk-zero', rem<=0);
    }
    document.addEventListener('DOMContentLoaded', mask);
    [$('#ppk-remaining')].concat(pillSel.map($)).filter(Boolean).forEach(function(el){
      try{
        new MutationObserver(function(){
          if(!checked){ mask(); } else { clearTimeout(debounce); debounce=setTimeout(updatePill,0); }
        }).observe(el,{childList:true,characterData:true,subtree:true});
      }catch(_){}
    });
    window.addEventListener('ppk:order:checked', function(){
      var t=$('#ppk-remaining'); if(t){ availableChecked=asInt(t.textContent); checked=true; updatePill(); }
    }, true);
    window.addEventListener('ppk:cart:updated', function(){ if(checked) updatePill(); }, true);
  })();

  // ---- Bootstrap ----
  function boot(){ buildInline(); movePillIntoBlueBanner(); }
  document.addEventListener('DOMContentLoaded', boot);
  setTimeout(boot, 100); setTimeout(boot, 400);
  window.addEventListener('resize', boot);
})();
</script>
<!-- OK-Coop v2: Pflanzenwechsel-OK kooperativ – lässt rbConfirm durch, dann Editor-Reset + Hints-Neuaufbau + Verfügbarkeit erhalten -->
<script id="rb-confirm-ok-coop-reset">
(function(){
  'use strict';
  if (window.__rbOkCoopBound_SPEC) return;

  function $(sel, ctx){ return (ctx||document).querySelector(sel); }

  function readAvail(){
    try{
      var p = document.querySelector('#ppk-availability-pill');
      if(!p) return null;
      return p.classList.contains('ppk-zero') ? 0 : 1;
    }catch(_){ return null; }
  }
  function setFilterAll(){ try{ window.rbFilterRedBoxes && window.rbFilterRedBoxes('all'); }catch(_){ } }
  function clearCardFrontBack(){
    try{
      if(window.clearCardSideOverlays) window.clearCardSideOverlays();
      if(window.clearDragTexts) window.clearDragTexts();
    }catch(_){}
  }
  function clearKosename(){ try{ if(window.setKosenamen) window.setKosenamen(''); }catch(_){} }
  function clearHintsLeft(){
    try{
      var scope = document.getElementById('rb-scope');
      if(!scope) return;
      Array.from(scope.querySelectorAll('.rb-row')).forEach(function(row){
        row.classList.add('hidden');
        var hint = row.querySelector('.rb-hint');
        if(hint) hint.textContent = '';
      });
    }catch(_){}
  }
  function applyAvail(avail){
    try{
      var pill = document.getElementById('ppk-availability-pill');
    if(!pill) return;
      if(avail===0) pill.classList.add('ppk-zero');
      else pill.classList.remove('ppk-zero');
    }catch(_){}
  }

  function bindOverlayObserver(){
    var ov = $('#rb-confirm-overlay');
    if (!ov || ov.__rbOkCoopObsSPEC) return;
    ov.__rbOkCoopObsSPEC = true;
    try{
      var mo = new MutationObserver(function(){
        var v = ov.getAttribute('data-show');
        if (v === '0'){
          var avail = readAvail();
          setTimeout(function(){
            setFilterAll();
            clearCardFrontBack();
            clearKosename();
            clearHintsLeft();
            applyAvail(avail);
            try{
              window.dispatchEvent(new CustomEvent('ppk:ok:exact-actions', { detail:{ avail: avail } }));
            }catch(_){}
          }, 0);
        }
      });
      mo.observe(ov, { attributes:true, attributeFilter:['data-show'] });
    }catch(_){}
  }

  function init(){ bindOverlayObserver(); }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  try{
    var mo = new MutationObserver(function(){ bindOverlayObserver(); });
    mo.observe(document.body, { childList:true, subtree:true });
  }catch(_){}

  window.__rbOkCoopBound_SPEC = true;
})();
</script>
<script id="ppk-ok-availability-guard-strong">
(function(){
  'use strict';
  if (window.__ppkOkAvailGuardStrong) return;

  function $(s){ return document.querySelector(s); }
  function hasDigit(text){ return /\d/.test(String(text||'')); }

  function applyAvail(n){
    try{
      var pill = $('#ppk-limit-indicator');
      if (pill){
        var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: ' + n);
        pill.textContent = txt;
        pill.setAttribute('data-ppk-val', String(n));
        pill.classList.toggle('ppk-zero', n===0);
      }
      var rem = $('#ppk-remaining');
      if (rem){ rem.textContent = 'Verfügbar: ' + n; }
    }catch(_){}
  }

  function protectValue(n){
    // 1) Monkey-patch setRemaining/showLimit during guard
    try{
      if (!window.__ppkOrigSetRemaining){
        window.__ppkOrigSetRemaining = window.setRemaining;
      }
      window.setRemaining = function(v){
        try{
          var num = Number(v);
          if (!isFinite(num)) { applyAvail(n); return n; }
          applyAvail(num);
          return num;
        }catch(_){ applyAvail(n); return n; }
      };
    }catch(_){}

    try{
      if (!window.__ppkOrigShowLimit){
        window.__ppkOrigShowLimit = window.showLimit;
      }
      window.showLimit = function(v){
        try{
          var num = Number(v);
          if (!isFinite(num)) { applyAvail(n); return n; }
          applyAvail(num);
          return num;
        }catch(_){ applyAvail(n); return n; }
      };
    }catch(_){}

    // 2) Observe DOM changes on the two display nodes and revert bad writes
    var pill = $('#ppk-limit-indicator');
    var rem  = $('#ppk-remaining');
    var cfg = { characterData:true, childList:true, subtree:true };

    function mkObs(node){
      if (!node) return null;
      try{
        var mo = new MutationObserver(function(){
          var text = node.textContent;
          if (!hasDigit(text)) { applyAvail(n); }
        });
        mo.observe(node, cfg);
        return mo;
      }catch(_){ return null; }
    }
    var mop = mkObs(pill);
    var mor = mkObs(rem);

    // 3) Also on relevant events, re-apply snapshot
    function reapply(){ applyAvail(n); }
    window.addEventListener('ppk:cart:updated', reapply, true);
    window.addEventListener('ppk:order:checked', reapply, true);
    window.addEventListener('ppk:order:check-failed', reapply, true);

    // 4) Stop guard after a short window (legacy timeouts should have fired)
    setTimeout(function(){
      // restore originals if present
      try{ if (window.__ppkOrigSetRemaining) window.setRemaining = window.__ppkOrigSetRemaining; }catch(_){}
      try{ if (window.__ppkOrigShowLimit)    window.showLimit    = window.__ppkOrigShowLimit;    }catch(_){}
      try{ if (mop) mop.disconnect(); }catch(_){}
      try{ if (mor) mor.disconnect(); }catch(_){}
      window.removeEventListener('ppk:cart:updated', reapply, true);
      window.removeEventListener('ppk:order:checked', reapply, true);
      window.removeEventListener('ppk:order:check-failed', reapply, true);
    }, 2000);
  }

  // Hook into our exact-actions signal to start guard with the snapshotted value
  window.addEventListener('ppk:ok:exact-actions', function(ev){
    try{
      var n = ev && ev.detail ? ev.detail.avail : null;
      if (n==null || !isFinite(n)) {
        // try to read current value from DOM if not in detail
        var pill = $('#ppk-limit-indicator');
        var d = pill && pill.getAttribute ? pill.getAttribute('data-ppk-val') : null;
        if (d!=null && !isNaN(+d)) n = +d;
      }
      if (n!=null) protectValue(n);
    }catch(_){}
  }, true);

  window.__ppkOkAvailGuardStrong = true;
})();
</script>
<script id="ppk-add-brand-new-ok">
(function(){
  'use strict';
  if (window.__ppkNewOkInstalledV6) return;

  function $(s, ctx){ return (ctx||document).querySelector(s); }
  function asInt(x){ var m=String(x||'').match(/-?\d+/); return m?parseInt(m[0],10):null; }

  // helpers
  function readAvail(){
    var pill = $('#ppk-limit-indicator');
    var d = pill && pill.getAttribute ? pill.getAttribute('data-ppk-val') : null;
    if (d!=null && !isNaN(+d)) return +d;
    var rem = $('#ppk-remaining');
    if (rem){
      var n = asInt(rem.textContent);
      if (n!=null) return n;
    }
    return null;
  }
  function applyAvail(n){
    if (n==null) return;
    var pill = $('#ppk-limit-indicator');
    if (pill){
      var txt = (n===0) ? 'Limit erreicht: 0 verfügbar' : ('Verfügbar: '+n);
      try{ pill.textContent = txt; }catch(_){}
      pill.setAttribute('data-ppk-val', String(n));
      pill.classList.toggle('ppk-zero', n===0);
    }
    var rem = $('#ppk-remaining');
    if (rem){ rem.textContent = 'Verfügbar: ' + n; }
  }
  function clearCardFrontBack(){
    var btn = document.getElementById('btn-leeren');
    if (btn) try{ btn.click(); }catch(_){}
  }
  function clearKosename(){
    try{
      var inp = document.getElementById('kosenameInput');
      if (inp) inp.value = '';
      var f1k = document.getElementById('feld1KosenameAnzeige');
      if (f1k) f1k.textContent = '';
    }catch(_){}
  }
  function setFeld1Name(name){
    try{
      var f1 = document.getElementById('feld1NameAnzeige');
      if (f1) f1.textContent = name || '';
      var f1in = document.getElementById('feld1NameInput');
      if (f1in) f1in.value = name || '';
    }catch(_){}
  }
  function clearHintsLeft(){
    try{
      document.querySelectorAll('.rb-hint').forEach(function(el){ el.textContent=''; });
      var candidates = Array.prototype.slice.call(document.querySelectorAll('[id*="hinweis"], [class*="hinweis"]'));
      candidates.forEach(function(el){
        var tag = (el.tagName || '').toLowerCase();
        if (tag === 'style' || tag === 'script') return;
        if (el.classList.contains('rb-box') || el.classList.contains('rb-boxes')) return;
        try{ el.innerHTML = ''; }catch(_){}
      });
    }catch(_){}
  }
  function closeByCancel(){
    var cancel = document.getElementById('rb-confirm-cancel');
    if (cancel){
      try{ cancel.click(); return; }catch(_){}
    }
    var ov = document.getElementById('rb-confirm-overlay');
    if (ov){ try{ ov.setAttribute('data-show','0'); ov.style.display='none'; }catch(_){} }
  }

  function fireEnterSequence(ps){
    // Focus first so key events are received by the input
    try{ ps.focus(); }catch(_){}
    try{
      var len = ps.value ? ps.value.length : 0;
      if (typeof ps.setSelectionRange === 'function') ps.setSelectionRange(len, len);
    }catch(_){}

    var opts = {key:'Enter', code:'Enter', keyCode:13, which:13, bubbles:true, cancelable:true};

    try{ ps.dispatchEvent(new KeyboardEvent('keydown', opts)); }catch(_){}
    // Some listeners still use deprecated 'keypress'
    try{ ps.dispatchEvent(new KeyboardEvent('keypress', opts)); }catch(_){}
    try{ ps.dispatchEvent(new KeyboardEvent('keyup', opts)); }catch(_){}

    // If inside a form, also submit
    try{
      var form = ps.form;
      if (form){
        form.dispatchEvent(new Event('submit', {bubbles:true, cancelable:true}));
      }
    }catch(_){}
  }

  function triggerPlantFilterAndHints(name){
    var ps = document.getElementById('pflanzensuche');
    if (!ps) return;
    try{ ps.value = name || ps.value; }catch(_){}

    // Dispatch input/change
    try{ ps.dispatchEvent(new Event('input', {bubbles:true})); }catch(_){}
    try{ ps.dispatchEvent(new Event('change', {bubbles:true})); }catch(_){}

    // Timed ENTER sequence to satisfy debounce/async listeners
    setTimeout(function(){ fireEnterSequence(ps); }, 30);
    setTimeout(function(){ fireEnterSequence(ps); }, 120);

    // Click an explicit apply button if present
    var applyBtn = document.getElementById('btn-suche-apply') || document.querySelector('[data-action="apply-plant"]');
    if (applyBtn){ try{ applyBtn.click(); }catch(_){} }

    // Optional hook
    try{ if (typeof window.ppkRecalcHints === 'function') window.ppkRecalcHints(); }catch(_){}
  }

  function ensureNewOk(){
    var oldOk = document.getElementById('rb-confirm-ok');
    if (!oldOk) return null;
    // Deactivate old OK completely
    try{
      oldOk.disabled = true;
      oldOk.classList.add('ppk-disabled');
      oldOk.setAttribute('aria-disabled','true');
      oldOk.title = 'Deaktiviert (ersetzt durch neuen OK)';
    }catch(_){}
    // If new button already exists, return it
    var newOk = document.getElementById('rb-confirm-ok-new');
    if (newOk) return newOk;

    // Create a new OK button
    newOk = document.createElement('button');
    newOk.id = 'rb-confirm-ok-new';
    // Copy some visual classes
    try{
      var cls = (oldOk.getAttribute('class')||'').split(/\s+/).filter(Boolean);
      cls = cls.filter(function(c){ return c !== 'ppk-disabled'; });
      if (cls.length){ newOk.setAttribute('class', cls.join(' ')); }
    }catch(_){}
    // Label
    var label = (oldOk.textContent||'OK').trim() || 'OK';
    newOk.textContent = label;

    // Insert after old OK
    try{ oldOk.parentNode.insertBefore(newOk, oldOk.nextSibling); }catch(_){}

    return newOk;
  }

  function installNewOkHandler(){
    var newOk = ensureNewOk();
    if (!newOk || newOk.__ppkBoundV6) return;
    newOk.__ppkBoundV6 = true;

    newOk.addEventListener('click', function(e){
      try{ e.preventDefault(); }catch(_){}
      var avail = readAvail();
      var ps = document.getElementById('pflanzensuche');
      var plant = ps ? (ps.value||'') : '';

      // exact actions
      clearCardFrontBack();
      clearKosename();
      clearHintsLeft();
      setFeld1Name(plant);
      applyAvail(avail);

      // close and then filter to the NEW plant + rebuild hints (incl. robust ENTER sim)
      closeByCancel();
      setTimeout(function(){ triggerPlantFilterAndHints(plant); }, 0);

      try{ window.dispatchEvent(new CustomEvent('ppk:ok:new-defined', {detail:{ avail: avail, plant: plant }})); }catch(_){}
    }, false);
  }

  function init(){
    installNewOkHandler();
    // Reinstall if overlay DOM changes
    var ov = document.getElementById('rb-confirm-overlay');
    if (ov && !ov.__ppkNewOkMo){
      ov.__ppkNewOkMo = true;
      try{
        var mo = new MutationObserver(installNewOkHandler);
        mo.observe(ov, { childList:true, subtree:true });
      }catch(_){}
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }

  window.__ppkNewOkInstalledV6 = true;
})();
</script>
<script>
(() => {
  // Verhindert, dass der Patch mehrfach aktiviert wird
  if (window.__F67_PATCHED__) return;
  window.__F67_PATCHED__ = true;

  // 1) Order aus URL übernehmen und "Prüfen" automatisch klicken
  try {
    const qs = new URLSearchParams(location.search);
    const order = qs.get('order') || '';
    const inp = document.querySelector('#ppk-unlock-input');
    const btn = document.querySelector('#ppk-unlock-btn,[data-ppk-check]');
    if (order && inp && btn) {
      inp.value = order;
      setTimeout(() => btn.click(), 0);
      window.__DEBUG__ && console.log('[F67] Prüf-Button auto geklickt');
    }
  } catch (_) {}

  // 2) runOrderCheck patchen und Bestellnummer-Fehler still abfangen
  const origRunOrderCheck = window.runOrderCheck;
  if (typeof origRunOrderCheck === 'function') {
    let logged = false; // nur 1x loggen
    window.runOrderCheck = async function (...args) {
      try {
        return await origRunOrderCheck.apply(this, args);
      } catch (err) {
        const msg = String((err && (err.message || err)) || '');
        if (/Bestellnummer/i.test(msg)) {
          if (!logged) {
            window.__DEBUG__ && console.debug('[F67] runOrderCheck: Fehler abgefangen (Promise)');
            logged = true;
          }
          return { ok: false, skipped: true, reason: 'no-order' };
        }
        throw err;
      }
    };
    window.__DEBUG__ && console.log('[F67] runOrderCheck gepatcht');
  }

  // 3) runCheck entprellen (höchstens 1x pro Sekunde)
  const origRunCheck = window.runCheck;
  if (typeof origRunCheck === 'function') {
    let last = 0;
    window.runCheck = function (...a) {
      const now = Date.now();
      if (now - last < 1000) {
        return Promise.resolve({ ok: true, skipped: true, reason: 'debounced' });
      }
      last = now;
      return origRunCheck.apply(this, a);
    };
    window.__DEBUG__ && console.log('[F67] runCheck debounced');
  }
})();
</script>



<script id="rbForceRestorePlant">
(function(){
  if (window.rbForceRestorePlant) return;

  window.rbForceRestorePlant = function(name){
    if (!name || typeof name !== 'string') return;

    try {
      // 1. Interner State zurücksetzen
      if (window.state) window.state.selectedPlant = name;

      // 2. Suchfeld setzen mit Events
      var input = document.getElementById('pflanzensuche');
      if (input) {
        input.value = name;
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
        input.focus();
        input.setSelectionRange(name.length, name.length);
      }

      // 3. Pflegehinweis-Zeile aktualisieren
      var status = document.querySelector('#rb-status');
      if (status) status.textContent = 'Pflegehinweise für „' + name + '“';

      // 4. Boxen neu filtern (wie nach Suchauswahl)
      if (window.__filterBySearch) window.__filterBySearch(name);

      // 5. Hinweise (slot-hint) aus Tabelle neu setzen
      var data = window.__plantData || [];
      var row = data.find(r => r[0] === name);
      if (row) {
        var box = document.querySelector('.hint-column');
        if (box) box.innerHTML = '';
        var keys = Object.keys(row);
        for (var k of keys){
          if (!k.match(/^\d+$/)) continue;
          var val = row[k];
          if (val && typeof val === 'string') {
            var div = document.createElement('div');
            div.className = 'slot-hint';
            div.textContent = val.trim();
            box.appendChild(div);
          }
        }
      }

    } catch (e) {
      window.__DEBUG__ && console.warn('Fehler beim forceRestore', e);
    }
  };
})();
</script>


<script id="ps2-tester-mode">
(function(){
  const params = new URLSearchParams(location.search);
  const MODE = (params.get('mode') || 'buyer').toLowerCase();
  const IS_TESTER = MODE === 'tester';

  function $(sel, root=document){ return root.querySelector(sel); }
  function $all(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function showInlineHintNear(el, text){
    if (!el) return;
    $all('.ps2-hint.ps2-tester').forEach(n=>n.remove());
    const hint = document.createElement('div');
    hint.className = 'ps2-hint ps2-tester';
    hint.innerHTML = '<header><span class="ps2-title">Hinweis</span><button class="ps2-x" type="button" aria-label="Schließen">×</button></header>' +
                     '<p>'+ (text||'') +'</p>';
    document.body.appendChild(hint);
    const r = el.getBoundingClientRect();
    hint.style.left = Math.round(r.left)+'px';
    hint.style.top  = Math.round(r.bottom + 8)+'px';
    hint.querySelector('.ps2-x').addEventListener('click', ()=>{ try{ hint.remove(); }catch(e){} }, {once:true});
    setTimeout(()=>{ try{ hint.remove(); }catch(e){} }, 6000);
  }

  // 1) Bestellung im Tester: Button wird zu "Zurück zum Shop"
  function applyTesterSubmitBlock(){
    const submitBtn = $all('button,.btn,.rb-btn').find(b=>{
      const t = (b.textContent||'').trim().toLowerCase();
      return t.includes('bestellung') || b.id === 'btn-submit' || b.name === 'submit-order';
    });
    if (IS_TESTER && submitBtn){
      const SHOP_URL = '/'; // bei Bedarf anpassen
      submitBtn.textContent = 'Zurück zum Shop';
      submitBtn.onclick = (e)=>{ e.preventDefault(); location.href = SHOP_URL; };
      submitBtn.disabled = false;
      submitBtn.title = 'Testmodus: Bestellung nicht möglich';
    }
  }

  // 2) Keine Bestellnummer im Tester nötig: runOrderCheck nie blockierend
  function patchOrderCheck(){
    if (!IS_TESTER) return;
    if (typeof window.runOrderCheck === 'function'){
      const orig = window.runOrderCheck;
      window.runOrderCheck = function(){
        try{
          const okNodes = $all('.order-status,.ok,.rb-ok');
          okNodes.forEach(n=>n.classList.add('ok'));
        }catch(_){}
        return true;
      };
    }
    const orderInput = $all('input[type="text"],input').find(i=> (i.id||'').toLowerCase().includes('order') || (i.name||'').toLowerCase().includes('order'));
    if (orderInput && IS_TESTER){
      orderInput.placeholder = (orderInput.placeholder||'') + ' (im Test nicht erforderlich)';
    }
  }

  // 3) Warenkorb-Limit = 3 im Tester
  function getCartCount(){
    const items = $all('.cart-item, #abschluss-cart-list li');
    if (items.length) return items.length;
    window.__ps_cart_count = window.__ps_cart_count || 0;
    return window.__ps_cart_count;
  }
  function incCartCount(){ window.__ps_cart_count = getCartCount()+1; }
  function decCartCount(){ window.__ps_cart_count = Math.max(0, getCartCount()-1); }

  function guardAddToCart(){
    const addBtn = $all('button,.btn,.rb-btn').find(b=>{
      const t = (b.textContent||'').trim().toLowerCase();
      return t === 'zum warenkorb' || t.includes('warenkorb') || b.id === 'btn-warenkorb';
    });
    if (!addBtn) return;
    const origClick = addBtn.onclick || null;
    addBtn.onclick = function(ev){
      if (IS_TESTER && getCartCount() >= 3){
        ev.preventDefault();
        showInlineHintNear(addBtn, 'Im Testmodus sind maximal 3 Karten im Warenkorb erlaubt. Entferne zuerst eine Karte.');
        return false;
      }
      if (origClick) { origClick.call(this, ev); }
      if (IS_TESTER){
        if (!$all('.cart-item, #abschluss-cart-list li').length) incCartCount();
      }
      return true;
    };
    $all('.cart-remove,.remove-from-cart,#abschluss-cart-list .remove').forEach(btn=>{
      btn.addEventListener('click', ()=>{ if (IS_TESTER) decCartCount(); }, true);
    });
  }

  // Init jetzt + ein paar Mal nachladen (falls UI spät kommt)
  applyTesterSubmitBlock();
  patchOrderCheck();
  guardAddToCart();

  let tries = 0;
  const t = setInterval(()=>{
    applyTesterSubmitBlock();
    guardAddToCart();
    if (++tries > 20) clearInterval(t);
  }, 500);
})();
</script>
<script id="nohit-observer-js">
(function(){
  function ensureButton(){
    var toast = document.getElementById('nohit-toast');
    if(!toast) return;
    // if actions row not present, add it at the end
    var actions = toast.querySelector('#nohit-actions');
    if(!actions){
      actions = document.createElement('div');
      actions.id = 'nohit-actions';
      actions.innerHTML = '<button class="rbc-btn primary" id="nohit-accept-rbc" type="button">✓</button>';
      toast.appendChild(actions);
    }
  }
  function onAccept(ev){
    if (ev.target && ev.target.id === 'nohit-accept-rbc'){
      ev.preventDefault();
      try{ if (typeof window.rbSelectPlant === 'function'){ window.rbSelectPlant(''); } }catch(_){}
      var toast = document.getElementById('nohit-toast');
      if (toast){ toast.style.display='none'; }
    }
  }
  document.addEventListener('click', onAccept);
  // Observe changes to keep the button even if other code overwrites innerHTML/textContent
  var toast = document.getElementById('nohit-toast');
  if (toast){
    var mo = new MutationObserver(function(){ ensureButton(); });
    mo.observe(toast, {childList:true, characterData:true, subtree:true});
    // Also ensure on show
    var lastDisplay = '';
    setInterval(function(){
      var t = document.getElementById('nohit-toast');
      if(!t) return;
      var d = getComputedStyle(t).display;
      if (d !== lastDisplay){
        lastDisplay = d;
        if (d !== 'none') ensureButton();
      }
    }, 200);
    ensureButton();
  }
})();
</script>
<script id="nohit-variantA-like-accept">
(function(){
  'use strict';
  if (window.__nohitVariantA) return; // init once
  window.__nohitVariantA = true;

  function acceptAndClose(){
    try{ if (typeof window.rbSelectPlant === 'function'){ window.rbSelectPlant(''); } }catch(_){}
    try{
      var t = document.getElementById('nohit-toast');
      if (t) t.style.display = 'none';
    }catch(_){}
  }

  function ensureButton(){
    var toast = document.getElementById('nohit-toast');
    if (!toast) return;
    var btn = toast.querySelector('#nohit-accept-rbc, #nohit-accept');
    if (!btn){
      var actions = toast.querySelector('#nohit-actions');
      if (!actions){
        actions = document.createElement('div');
        actions.id = 'nohit-actions';
        toast.appendChild(actions);
      }
      btn = document.createElement('button');
      btn.type = 'button'; btn.id = 'nohit-accept-rbc'; btn.textContent = '✓';
      actions.appendChild(btn);
    }
  }

  // Original: Haken-Klick
  document.addEventListener('click', function(ev){
    if (ev.target && (ev.target.id === 'nohit-accept-rbc' || ev.target.id === 'nohit-accept')){
      ev.preventDefault();
      ev.stopPropagation();
      acceptAndClose();
    }
  }, true);

  // Variant A: Klick irgendwo im Hinweis => wie Haken
  var toast = document.getElementById('nohit-toast');
  if (toast){
    toast.addEventListener('click', function(ev){
      // Wenn expliziter Haken geklickt wurde, greift oben der Handler
      if (ev.target && (ev.target.id === 'nohit-accept-rbc' || ev.target.id === 'nohit-accept')) return;
      ev.preventDefault();
      ev.stopPropagation();
      acceptAndClose();
    }, true);
  }

  // Sicherstellen, dass der Haken-Button existiert, und stabil bleibt
  ensureButton();
  var t = document.getElementById('nohit-toast');
  if (t){
    var mo = new MutationObserver(function(){ ensureButton(); });
    mo.observe(t, {childList:true, subtree:true, characterData:true});
  }
})();
</script>
<script id="ps-clear-action-js">
(function(){
  var input = document.getElementById('pflanzensuche');
  var clearWrap = document.querySelector('.ps-clearwrap');
  if(!input || !clearWrap) return;

  function performNoPlant(){
    try{ if (typeof window.rbSelectPlant === 'function'){ window.rbSelectPlant(''); } }catch(_){}
    try{ var t = document.getElementById('nohit-toast'); if (t){ t.style.display='none'; } }catch(_){}
    try{
      document.querySelectorAll('.hidden').forEach(function(el){ el.classList.remove('hidden'); });
      document.querySelectorAll('#karte-vorderseite .slot-hint').forEach(function(el){ el.textContent=''; });
    }catch(_){}
  }
  function clearAndReset(ev){
    if(ev) ev.preventDefault();
    input.value = '';
    try{ input.dispatchEvent(new Event('input', {bubbles:true})); }catch(_){}
    performNoPlant();
    input.focus();
  }
  clearWrap.addEventListener('click', clearAndReset);
  clearWrap.addEventListener('keydown', function(e){
    if (e.key === 'Enter' || e.key === ' '){
      clearAndReset(e);
    }
  });
})();
</script>
<script id="nohit-mini-fix">
// Schließt #nohit-toast NUR bei Klick auf den Haken im Hinweis oder auf das Header-X.
document.addEventListener('click', function(ev){
  var t = ev.target;
  if (!t) return;
  var isHintCheck = (t.id === 'nohit-accept' || t.id === 'nohit-accept-inline');
  var isHeaderX = (t.classList && t.classList.contains('ps2-x')) || (t.closest && t.closest('button.ps2-x'));
  if (isHintCheck || isHeaderX){
    var toast = document.getElementById('nohit-toast');
    if (toast){ toast.style.display = 'none'; }
  }
}, true);
</script>
<!-- RB: Entfernt den Pflanzenwechsel-Hinweis (#rb-confirm .ps2-hint) vollständig und dauerhaft -->
<style id="rb-back-hint-typography">
/* Äußere Box wie besprochen */
#karte_rueckseite_overlay #hint-layer .slot-hint{
  background:#fff !important;
  color:#222 !important;
  border: 1mm solid #800020 !important;
  border-radius: 6px !important;
  padding: 10px 12px !important;
  box-shadow:none !important;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif !important;
  font-size: 12px !important;
  line-height: 1.35 !important;
  font-weight: 400 !important;
}

/* Reset innen, damit nichts eigene Kästchen/Typo mitbringt */
#karte_rueckseite_overlay #hint-layer .slot-hint *{
  background: transparent !important;
  border: none !important;
  box-shadow: none !important;
  color: inherit !important;
  font-family: inherit !important;
  line-height: inherit !important;
}

/* Titel auffetten, minimal mehr Abstand */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-title{
  font-weight: 600 !important;   /* etwas fetter als Text */
  margin: 0 0 8px 0 !important;
}

/* Alternative normal */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-alt{
  font-weight: 400 !important;
  margin: 0 !important;
}

/* Close-X optisch passend */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-close{
  background: transparent !important;
  border: none !important;
  color: #800020 !important;     /* Bordeaux */
  font-weight: 700 !important;   /* klar sichtbar */
  font-size: 16px !important;    /* leicht größer */
  line-height: 1 !important;
  padding: 0 !important;
  cursor: pointer !important;
}
</style>
<style id="rb-back-hint-finalize">
/* Außen: 1 mm Bordeaux, 10 px Radius, 12 px / 1.35 */
#karte_rueckseite_overlay #hint-layer .slot-hint{
  background:#fff !important;
  color:#222 !important;
  border: 1mm solid #800020 !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  box-shadow: none !important;
  font: 400 12px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif !important;
}

/* Innen alles neutralisieren (inkl. ::before/::after), damit keine Kästchen/anderen Fonts durchkommen */
#karte_rueckseite_overlay #hint-layer .slot-hint *,
#karte_rueckseite_overlay #hint-layer .slot-hint *::before,
#karte_rueckseite_overlay #hint-layer .slot-hint *::after{
  background: transparent !important;
  border: 0 !important;
  box-shadow: none !important;
  outline: none !important;
  color: inherit !important;
  font: inherit !important;
  line-height: inherit !important;
  text-shadow: none !important;
}

/* Titel etwas kräftiger, kleiner Abstand */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-title{
  display:block !important;
  font-weight: 600 !important;
  margin: 0 0 8px 0 !important;
}

/* Alttext normal */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-alt{
  display:block !important;
  font-weight: 400 !important;
  margin: 0 !important;
}

/* Schließen (X) wie bei den anderen Hinweisen – bordeaux, fett, ohne Kasten */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-close{
  background: transparent !important;
  border: none !important;
  color: #800020 !important;
  font-weight: 700 !important;
  font-size: 14px !important; /* dezent */
  line-height: 1 !important;
  padding: 0 !important;
  cursor: pointer !important;
}
</style>
<style id="rb-back-hint-finalize">
/* Außen: 1 mm Bordeaux, 10 px Radius, 12 px / 1.35 */
#karte_rueckseite_overlay #hint-layer .slot-hint{
  background:#fff !important;
  color:#222 !important;
  border: 1mm solid #800020 !important;
  border-radius: 10px !important;
  padding: 10px 12px !important;
  box-shadow: none !important;
  font: 400 12px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif !important;
}

/* Innen alles neutralisieren (inkl. ::before/::after), damit keine Kästchen/anderen Fonts durchkommen */
#karte_rueckseite_overlay #hint-layer .slot-hint *,
#karte_rueckseite_overlay #hint-layer .slot-hint *::before,
#karte_rueckseite_overlay #hint-layer .slot-hint *::after{
  background: transparent !important;
  border: 0 !important;
  box-shadow: none !important;
  outline: none !important;
  color: inherit !important;
  font: inherit !important;
  line-height: inherit !important;
  text-shadow: none !important;
}

/* Titel etwas kräftiger, kleiner Abstand */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-title{
  display:block !important;
  font-weight: 600 !important;
  margin: 0 0 8px 0 !important;
}

/* Alttext normal */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-alt{
  display:block !important;
  font-weight: 400 !important;
  margin: 0 !important;
}

/* Schließen (X) wie bei den anderen Hinweisen – bordeaux, fett, ohne Kasten */
#karte_rueckseite_overlay #hint-layer .slot-hint .slot-hint-close{
  background: transparent !important;
  border: none !important;
  color: #800020 !important;
  font-weight: 700 !important;
  font-size: 14px !important; /* dezent */
  line-height: 1 !important;
  padding: 0 !important;
  cursor: pointer !important;
}
</style>
<script>
(function () {
  "use strict";
  const cfg = {
    border: "3.8px solid #800020",   // ≈ 1 mm
    radius: "10px",                  // Eckenradius
    fs: "12px",                      // Schriftgröße
    lh: "1.35"                       // Zeilenhöhe
  };

  function fixBackHint() {
    const el = document.querySelector("#karte_rueckseite_overlay #hint-layer .slot-hint");
    if (!el) return;

    // Außenbox exakt setzen – INLINE (gewinnt gegen alles)
    Object.assign(el.style, {
      background: "#fff",
      color: "#222",
      border: cfg.border,
      borderRadius: cfg.radius,
      padding: "10px 12px",
      boxShadow: "none",
      fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif',
      fontSize: cfg.fs,
      lineHeight: cfg.lh,
      fontWeight: "400"
    });

    // Innen alles neutralisieren
    el.querySelectorAll("*").forEach(function (n) {
      n.style.background = "transparent";
      n.style.border = "0";
      n.style.boxShadow = "none";
      n.style.outline = "none";
      n.style.fontFamily = "inherit";
      n.style.lineHeight = "inherit";
      n.style.color = "inherit";
      n.style.textShadow = "none";
      // Standard-Margins raus
      if (!n.classList.contains("slot-hint-title")) n.style.margin = "0";
      n.style.padding = "0";
    });

    // Titel etwas fetter + Abstand
    const title = el.querySelector(".slot-hint-title");
    if (title) {
      title.style.display = "block";
      title.style.fontWeight = "600";
      title.style.margin = "0 0 8px 0";
    }

    // Alttext normal
    const alt = el.querySelector(".slot-hint-alt");
    if (alt) {
      alt.style.display = "block";
      alt.style.fontWeight = "400";
      alt.style.margin = "0";
    }

    // Schließen (X) – bordeaux, fett, ohne Kasten
    const x = el.querySelector(".slot-hint-close");
    if (x) {
      Object.assign(x.style, {
        background: "transparent",
        border: "0",
        color: "#800020",
        fontWeight: "700",
        fontSize: "14px",
        lineHeight: "1",
        padding: "0",
        cursor: "pointer"
      });
    }
  }

  // Sofort und bei jedem Neurendern anwenden
  const run = () => fixBackHint();
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", run);
  } else {
    run();
  }
  new MutationObserver(run).observe(document.documentElement, { childList: true, subtree: true });
})();
</script>
<!-- RB FIX: Rückseiten-Hinweis neu aufbauen, einheitlich -->
<style id="rb-back-hint-style">
  /* Fallback-Styles (Script setzt das gleiche inline) */
  #karte_rueckseite_overlay #hint-layer .rb-back-hint{
    font: 400 12px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    background:#fff; color:#222;
    border: 1mm solid #800020; border-radius: 10px;
    padding: 10px 12px; box-shadow: none; position: relative;
  }
  #karte_rueckseite_overlay #hint-layer .rb-back-hint .rb-title{
    display:block; font-weight:600; margin:0 0 8px 0;
  }
  #karte_rueckseite_overlay #hint-layer .rb-back-hint .rb-alt{
    display:block; font-weight:400; margin:0;
  }
  #karte_rueckseite_overlay #hint-layer .rb-back-hint .rb-close{
    position:absolute; top:6px; right:8px;
    color:#800020; font-weight:700; font-size:14px; line-height:1;
    cursor:pointer; user-select:none; background:transparent; border:0; padding:0;
  }
</style>
<script id="rb-back-hint-rebuilder">
(() => {
  "use strict";

  const INLINE = {
    background:"#fff",
    color:"#222",
    border:"3.8px solid #800020",      // ≈ 1 mm
    borderRadius:"10px",
    padding:"10px 12px",
    boxShadow:"none",
    fontFamily:'system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif',
    fontSize:"12px",
    lineHeight:"1.35",
    fontWeight:"400",
    position:"relative"
  };

  function buildNewHint(titleTx, altTx){
    const hint = document.createElement("div");
    hint.className = "rb-back-hint";
    Object.assign(hint.style, INLINE);

    const close = document.createElement("span");
    close.className = "rb-close";
    close.textContent = "×";
    close.onclick = () => hint.remove();

    const title = document.createElement("span");
    title.className = "rb-title";
    title.textContent = titleTx || "Dieser Sticker ist für die Rückseite eher ungeeignet.";
    title.style.fontWeight = "600";
    title.style.margin = "0 0 8px 0";

    hint.append(close, title);

    if (altTx) {
      const alt = document.createElement("div");
      alt.className = "rb-alt";
      alt.textContent = altTx;
      hint.appendChild(alt);
    }
    return hint;
  }

  function replaceBackHint(layer){
    const old = layer.querySelector(".slot-hint");
    if (!old) return;

    const titleTx = (old.querySelector(".slot-hint-title")?.textContent || "").trim();
    const altTx   = (old.querySelector(".slot-hint-alt")?.textContent   || "").trim();
    old.remove();

    layer.appendChild(buildNewHint(titleTx, altTx));
  }

  function scan(){
    // nur im Rückseiten-Overlay arbeiten
    const layer = document.querySelector("#karte_rueckseite_overlay #hint-layer");
    if (layer && layer.querySelector(".slot-hint")) replaceBackHint(layer);
  }

  // sofort + bei späteren DOM-Änderungen
  (document.readyState === "loading")
    ? document.addEventListener("DOMContentLoaded", scan)
    : scan();

  new MutationObserver(() => scan())
    .observe(document.documentElement, { childList:true, subtree:true });
})();
</script>
<script>
(function () {
  const scopeSelectors = [
    '#karte_rueckseite_overlay #hint-layer .slot-hint.rb-hint-back',
    '#karte_rueckseite #hint-layer .slot-hint.rb-hint-back',
    // Fallback: wenn "rb-hint-back" nicht gesetzt ist
    '#karte_rueckseite_overlay #hint-layer .slot-hint',
    '#karte_rueckseite #hint-layer .slot-hint'
  ];

  function restyle(el) {
    if (!el || el.dataset.rbStyled === '1') return;

    // Box (Style B)
    el.style.fontFamily = 'system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif';
    el.style.fontSize = '12px';
    el.style.lineHeight = '1.35';
    el.style.color = '#222';
    el.style.background = '#fff';
    el.style.border = '3.78px solid #800020'; // ~1 mm
    el.style.borderRadius = '10px';
    el.style.padding = '10px 12px';
    el.style.boxShadow = 'none';
    el.style.outline = '0';
    el.style.position = el.style.position || 'relative';

    // Titel fett
    const title = el.querySelector('.slot-hint-title');
    if (title) {
      title.style.display = 'block';
      title.style.fontWeight = '600';
      title.style.margin = '0 0 8px 0';
      title.style.background = 'transparent';
      title.style.border = '0';
      title.style.boxShadow = 'none';
    }

    // Schließen-Kreuz oben rechts, Bordeaux
    const close = el.querySelector('.slot-hint-close');
    if (close) {
      close.style.position = 'absolute';
      close.style.top = '6px';
      close.style.right = '8px';
      close.style.fontWeight = '700';
      close.style.fontSize = '14px';
      close.style.lineHeight = '1';
      close.style.color = '#800020';
      close.style.background = 'transparent';
      close.style.border = '0';
      close.style.padding = '0';
      close.style.cursor = 'pointer';
    }

    // Innere Deko neutralisieren (nur innerhalb des Hinweises!)
    el.querySelectorAll('*').forEach(n => {
      n.style.background = n === title || n === close ? n.style.background : n.style.background || 'transparent';
      n.style.border = n.style.border || '0';
      n.style.boxShadow = n.style.boxShadow || 'none';
      n.style.textShadow = n.style.textShadow || 'none';
    });

    el.dataset.rbStyled = '1';
  }

  function scan() {
    scopeSelectors.forEach(sel => {
      document.querySelectorAll(sel).forEach(el => {
        // Nur echte Rückseiten-Hinweise: enthalten title/alt-Knoten
        if (el.querySelector('.slot-hint-title')) restyle(el);
      });
    });
  }

  // initial
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', scan, { once: true });
  } else {
    scan();
  }

  // dynamische Einfügungen abfangen
  const obs = new MutationObserver(muts => {
    muts.forEach(m => {
      m.addedNodes && m.addedNodes.forEach(node => {
        if (node.nodeType !== 1) return;
        // direkt gematchter Knoten?
        if (node.matches && scopeSelectors.some(s => node.matches(s))) {
          if (node.querySelector('.slot-hint-title')) restyle(node);
        }
        // oder enthält passende Knoten?
        scopeSelectors.forEach(s => {
          node.querySelectorAll && node.querySelectorAll(s).forEach(el => {
            if (el.querySelector('.slot-hint-title')) restyle(el);
          });
        });
      });
    });
  });
  obs.observe(document.body, { childList: true, subtree: true });
})();
</script>
<script id="sl4-align-js">
document.addEventListener('DOMContentLoaded', function(){
  try{
    var bar = document.querySelector('.steuerleiste');
    if(!bar) return;

    // 1) "Bestellnummer eingeben" als temporäres Inline-Feld oben links
    if (!document.getElementById('order-inline')){
      var ord = document.createElement('input');
      ord.type = 'text';
      ord.id = 'order-inline';
      ord.placeholder = 'Bestellnummer eingeben…';
      bar.insertBefore(ord, bar.firstChild);
    }

    // 2) Kosename-Eingabe: falls noch nicht existiert -> anlegen
    if (!document.getElementById('kosenameInput')){
      var inp = document.createElement('input');
      inp.type = 'text';
      inp.id = 'kosenameInput';
      inp.placeholder = 'Kosename eingeben…';
      bar.appendChild(inp);
    }

    // 3) Shop-Reihe (oben rechts Guthaben, Mitte Zurück, unten Warenkorb)
    if (!document.getElementById('sl4-credit')){
      /* Guthaben removed */
    }
    if (!document.getElementById('sl4-back-shop')){
      var back = document.createElement('button');
      back.type = 'button';
      back.id = 'sl4-back-shop';
      back.textContent = 'Zurück zum Shop';
      bar.appendChild(back);
    }

    // 4) Falls das Suchfeld keine ID hat, gebe ihm #pflanzensuche
    var s = bar.querySelector('.ac-wrap input[type="text"]');
    if (s && !s.id) s.id = 'pflanzensuche';
  }catch(_){}
});
</script>
<script id="sl4-stable-icons-js">
document.addEventListener('DOMContentLoaded', function(){
  try{
    var bar = document.querySelector('.steuerleiste');
    if (!bar) return;
    var wrap = bar.querySelector('.ac-wrap');
    if (!wrap) return;

    // Sucheingabe identifizieren
    var input = wrap.querySelector('input#pflanzensuche') || wrap.querySelector('input[type="text"]');
    if (!input) return;

    // Wenn noch keine Box existiert, direkt um das INPUT legen
    if (!input.parentElement.classList.contains('sl4-inputbox')){
      var box = document.createElement('span');
      box.className = 'sl4-inputbox';
      // input an Position ersetzen
      input.parentElement.insertBefore(box, input);
      box.appendChild(input);
    } else {
      var box = input.parentElement;
    }

    // Vorhandene ✓ / ✕ in die Box verschieben (damit sie sich NICHT mit der ac-list bewegen)
    var ok = wrap.querySelector('.ps-checkwrap');
    var x  = wrap.querySelector('.ps-clearwrap');
    if (ok && ok.parentElement !== box) box.appendChild(ok);
    if (x  && x.parentElement  !== box) box.appendChild(x);

  }catch(_){}
});
</script>
<script id="match-shop-btn">
(function(){
  function txt(el){ return (el.textContent||'').trim().replace(/\s+/g,' '); }
  function findBtn(re){
    return Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .find(el => re.test(txt(el)));
  }
  function matchButtons(){
    var warenkorb = findBtn(/Zum\s+Warenkorb/i);
    var back = document.getElementById('sl4-back-shop') || findBtn(/Zurück\s+zum\s+Shop/i);
    if(!warenkorb || !back) return;

    var cs = getComputedStyle(warenkorb);

    // Reset possible custom classes that distort size
    back.style.margin    = '0';
    back.style.display   = 'inline-flex';
    back.style.alignItems= 'center';
    back.style.justifyContent = 'center';

    // Copy visual metrics
    back.style.paddingTop    = cs.paddingTop;
    back.style.paddingBottom = cs.paddingBottom;
    back.style.paddingLeft   = cs.paddingLeft;
    back.style.paddingRight  = cs.paddingRight;
    back.style.borderRadius  = cs.borderRadius;
    back.style.fontSize      = cs.fontSize;
    back.style.lineHeight    = cs.lineHeight;
    back.style.borderWidth   = cs.borderWidth;
    back.style.borderStyle   = cs.borderStyle;
    back.style.borderColor   = cs.borderColor;
    back.style.boxShadow     = cs.boxShadow;
    back.style.height        = cs.height;
    back.style.minWidth      = cs.minWidth !== '0px' ? cs.minWidth : '';

    // Keep its original green background
    // back.style.background kept as-is
  }

  // find the "Bestellnummer eingeben" input in the toolbar
    var orderInput = Array.from(document.querySelectorAll('input, textarea'))
      .find(el => /Bestellnummer\s+eingeben/i.test(el.placeholder||''));
    if(!orderInput) return;

    // Build a small inline check button if not yet present
    var wrap = orderInput.parentElement;
    if (wrap && !wrap.querySelector('.order-check-btn')) {
      var btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'order-check-btn';
      btn.setAttribute('aria-label','Bestellnummer prüfen');
      btn.textContent = '✔';
      btn.style.marginLeft = '8px';
      btn.style.padding = '4px 10px';
      btn.style.borderRadius = '12px';
      btn.style.border = '2px solid #2a7d2e';
      btn.style.background = '#e8f7ea';
      btn.style.cursor = 'pointer';
      btn.style.fontWeight = '700';

      // Click handler: prefer existing Prüfen handler if we can find it;
      // otherwise, dispatch a custom event 'order:check' with value.
      btn.addEventListener('click', function(){
        var oldBtn = Array.from(document.querySelectorAll('button, a, [role="button"]'))
          .find(el => /Prüfen/i.test((el.textContent||'')));
        if(oldBtn && oldBtn.isConnected){
          oldBtn.click();
        }else{
          var ev = new CustomEvent('order:check', { detail: { value: orderInput.value }});
          window.dispatchEvent(ev);
        }
      });

      wrap.appendChild(btn);
    }

  const init = ()=>{
    matchButtons();
    enhanceOrderCheck();
  };
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
  else init();
  window.addEventListener('resize', matchButtons);
})();</script>
<script id="order-check-inside-js">
(function(){
  function txt(el){ return (el.textContent||'').trim().replace(/\s+/g,' '); }
  function findBtn(re){
    return Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .find(el => re.test(txt(el)));
  }
  function moveCheckInside(){
    // Hide top Prüfen block if present (same logic as before)
    var topCheck = Array.from(document.querySelectorAll('button, a, [role="button"]'))
      .find(el => /Prüfen/i.test((el.textContent||'')) && el.getBoundingClientRect().top < 180);
    var topCheckContainer = topCheck ? topCheck.closest('.block, .row, .column, div') : null;
    if(topCheckContainer && topCheckContainer.parentElement && topCheckContainer.getBoundingClientRect().top < 200){
      topCheckContainer.style.display = 'none';
    }

    var input = Array.from(document.querySelectorAll('input, textarea'))
      .find(el => /Bestellnummer\s+eingeben/i.test(el.placeholder||''));
    if(!input) return;

    // If not wrapped yet, wrap in .order-input-wrap
    var alreadyWrap = input.closest('.order-input-wrap');
    var wrap = alreadyWrap;
    if(!wrap){
      wrap = document.createElement('span');
      wrap.className = 'order-input-wrap';
      input.parentNode.insertBefore(wrap, input);
      wrap.appendChild(input);
    }

    // Remove old external button if any
    var oldInline = wrap.querySelector('.order-check-inside');
    if(!oldInline){
      var btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'order-check-inside';
      btn.setAttribute('aria-label','Bestellnummer prüfen');
      btn.textContent = '✔';
      btn.addEventListener('click', function(){
        var oldBtn = Array.from(document.querySelectorAll('button, a, [role="button"]'))
          .find(el => /Prüfen/i.test((el.textContent||'')));
        if(oldBtn && oldBtn.isConnected){
          oldBtn.click();
        }else{
          var ev = new CustomEvent('order:check', { detail: { value: input.value }});
          window.dispatchEvent(ev);
        }
      });
      wrap.appendChild(btn);
    }
  }
  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', moveCheckInside);
  else moveCheckInside();
})();
</script>
<script>
// === Insert yellow "Verfügbar" button in col 4, replacing "Guthaben:" ===
(function(){
  try{
    // 1) Find the top hint that says "bis zu X Karten"
    const hint = Array.from(document.querySelectorAll('body *'))
      .find(n => n.childNodes.length===1 && n.textContent && /bis zu\s+\d+\s+Karten/i.test(n.textContent));
    let maxCards = 0;
    if(hint){
      const m = hint.textContent.match(/bis zu\s+(\d+)\s+Karten/i);
      if(m) maxCards = parseInt(m[1],10);
    }

    /* Guthaben search removed */
    if(!gut){ return; }

    // 3) Build wrapper
    const wrap = document.createElement('div');
    wrap.className = 'ps-guthaben-wrap';

    // Move original node into wrapper (hidden) to preserve DOM for scripts
    const placeholder = document.createElement('span');
    placeholder.style.display = 'none';
    placeholder.setAttribute('aria-hidden','true');
    wrap.appendChild(placeholder);

    // 4) Create pill
    const pill = document.createElement('button');
    pill.className = 'ps-available-pill';
    pill.type = 'button';
    const val = Number.isFinite(maxCards) ? maxCards : 0;
    pill.textContent = 'Verfügbar: ' + (isNaN(val)? '—' : String(val));
    if(val===0) pill.classList.add('ps-zero');

    // 5) Replace "Guthaben:" visually with our pill
    const parent = gut.parentElement || document.body;
    parent.insertBefore(wrap, gut);
    wrap.appendChild(pill);
    gut.style.display = 'none';

    // Optional: expose updater for later logic
    window.psSetVerfuegbar = function(n){
      const num = Math.max(0, parseInt(n,10)||0);
      pill.textContent = 'Verfügbar: ' + num;
      pill.classList.toggle('ps-zero', num===0);
    };
  }catch(e){ console.warn('ps available pill error', e); }
})();
</script>
<script id="sl5-match-cart-style">
(function(){
  function $(sel){ return document.querySelector(sel); }
  function applyFromCart(){
    var cart = $('#btn-open-cart-top');
    var green = document.getElementById('sl4-back-shop') || document.getElementById('ppk-shop');
    var yellow = document.getElementById('btn-verfuegbar');
    if(!cart || !green || !yellow) return;

    var cs = getComputedStyle(cart);
    var props = [
      'height','paddingTop','paddingBottom','paddingLeft','paddingRight',
      'borderTopWidth','borderRightWidth','borderBottomWidth','borderLeftWidth',
      'borderTopStyle','borderRightStyle','borderBottomStyle','borderLeftStyle',
      'borderTopColor','borderRightColor','borderBottomColor','borderLeftColor',
      'borderRadius','fontSize','fontWeight','letterSpacing','textTransform',
      'boxSizing','lineHeight'
    ];
    [green, yellow].forEach(function(btn){
      btn.style.display = 'inline-block';
      props.forEach(function(p){
        var val = cs[p];
        if (val) btn.style.setProperty(p.replace(/[A-Z]/g, m => '-'+m.toLowerCase()), val, 'important');
      });
      // ensure text vertically centered
      btn.style.setProperty('line-height', cs.lineHeight || cs.height, 'important');
      // keep their unique backgrounds
      if (btn === green){
        btn.style.setProperty('background-color', '#176a49', 'important'); // bestehendes Grün sinngemäß
        btn.style.setProperty('color', '#fff', 'important');
      } else if (btn === yellow){
        btn.style.setProperty('background-color', '#FFD86B', 'important');
        btn.style.setProperty('color', '#000', 'important');
      }
    });
  }
  if (document.readyState==='loading') {
    document.addEventListener('DOMContentLoaded', applyFromCart, {once:true});
  } else {
    applyFromCart();
  }
  // one extra run after layout settles
  setTimeout(applyFromCart, 200);
})();
</script>
<script id="sl5-yellow-equal-cart">
(function(){
  function $(sel){ return document.querySelector(sel); }
  function apply(){
    var cart = $('#btn-open-cart-top');
    var yellow = document.getElementById('btn-verfuegbar');
    if(!cart || !yellow) return false;
    var r = cart.getBoundingClientRect();
    if(!r.width) return false;
    var w = Math.round(r.width);
    yellow.style.setProperty('box-sizing','border-box','important');
    yellow.style.setProperty('width',     w + 'px', 'important');
    yellow.style.setProperty('min-width', w + 'px', 'important');
    yellow.style.setProperty('max-width', w + 'px', 'important');
    yellow.style.setProperty('padding-left','0px','important');
    yellow.style.setProperty('padding-right','0px','important');
    return true;
  }
  function boot(){
    let tries=0;
    (function loop(){
      tries++; if (apply() || tries>50) return; requestAnimationFrame(loop);
    })();
    window.addEventListener('resize', apply);
    var cart = $('#btn-open-cart-top');
    if (cart && 'ResizeObserver' in window){
      var ro = new ResizeObserver(apply); ro.observe(cart);
      setTimeout(()=>{ try{ ro.disconnect(); }catch(_){ } }, 8000);
    }
  }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot, {once:true});
  else boot();
})();
</script>
<script id="sl5-counters">
(function(){
  var DEBOUNCE_MS = 120, rafId=null, tmr=null;
  function $(s, root){ return (root||document).querySelector(s); }
  function $all(s, root){ return Array.from((root||document).querySelectorAll(s)); }

  // TOTAL = MAX of all "Verfügbar: N" texts excluding the yellow badge itself
  function readTotal(){
    var nums = [];
    $all('body *:not(#btn-verfuegbar):not(#btn-verfuegbar *)').forEach(function(n){
      var txt = (n.textContent||'').trim();
      var m = txt.match(/\bVerf(?:ü|u)gbar\s*:?(\s*\d+)\b/i);
      if (m){
        var v = parseInt(m[1],10);
        if (!isNaN(v)) nums.push(v);
      }
    });
    if (!nums.length) return null;
    return Math.max.apply(null, nums);
  }

  // CART = sum of quantities inside '#abschluss-cart-list' list items
  function readCart(){
    var root = document.getElementById('abschluss-cart-list');
    if (!root) return 0;
    var inputs = $all('li input[type="number"][data-set-qty]', root)
                 .filter(el => el.offsetParent !== null);
    if (!inputs.length) return 0;
    var sum = 0;
    for (var el of inputs){
      var raw = (el.value || el.getAttribute('value') || '').trim();
      var v = parseInt(raw, 10);
      if (!isNaN(v) && v > 0) sum += v;
    }
    return sum;
  }

  function hideTopRedBanner(){
    $all('body *').forEach(function(n){
      var txt = (n.textContent||'').trim();
      if (/^\s*Verf(?:ü|u)gbar\s*:\s*\d+\s*$/.test(txt) && n.getBoundingClientRect().top < 350){
        n.style.display = 'none';
      }
    });
  }

  function render(){
    var total = readTotal();      // Y
    var cart  = readCart();       // N (>=0)
    var rem   = (total==null) ? null : Math.max(0, total - cart); // X

    var y = $('#btn-verfuegbar .btn-badge');
    if (y){
      if (total==null){ y.textContent = ''; }
      else if (rem==null){ y.textContent = 'von ' + total; }
      else { y.textContent = rem + ' von ' + total; }
    }

    var c = $('#btn-open-cart-top .btn-badge');
    if (c){
      c.textContent = String(cart);
    }

    hideTopRedBanner();
  }

  function debounced(){
    if (rafId) cancelAnimationFrame(rafId);
    if (tmr) clearTimeout(tmr);
    rafId = requestAnimationFrame(function(){ tmr = setTimeout(render, DEBOUNCE_MS); });
  }

  function boot(){
    render();
    if ('MutationObserver' in window){
      var mo = new MutationObserver(debounced);
      mo.observe(document.body, {childList:true, subtree:true, characterData:true});
    }
    window.addEventListener('resize', debounced);
    window.addEventListener('focus', debounced);
  }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot, {once:true});
  else boot();
})();
</script>
<script id="druck100-js">
(function(){
  'use strict';
  function setStatus(msg){ var s=document.getElementById('druck100-status'); if(s) s.textContent=msg||''; }

  function stripTransformsDeep(node){
    try{
      node.style && (node.style.transform='none', node.style.zoom='1');
      node.classList && Array.from(node.classList).forEach(function(c){
        if(/^zoom[-_]?/i.test(c)) node.classList.remove(c);
      });
      node.querySelectorAll('*').forEach(function(n){
        try{
          if(n.style){ n.style.transform='none'; n.style.zoom='1'; }
          if(n.classList){
            Array.from(n.classList).forEach(function(c){ if(/^zoom[-_]?/i.test(c)) n.classList.remove(c); });
          }
        }catch(_){}
      });
    }catch(_){}
  }

  function sanitize(node){
    if(!node) return node;
    try{
      node.querySelectorAll('.rahmen-overlay,.editor-rahmen,.bearbeitungs-rahmen,[data-editor-only],[data-role="editor-only"]').forEach(function(n){ n.remove(); });
      node.querySelectorAll('*').forEach(function(n){
        try{
          if(n.attributes){ for(const a of Array.from(n.attributes)){ if(/^on/i.test(a.name)) n.removeAttribute(a.name); } }
          if(n.removeAttribute){ n.removeAttribute('draggable'); n.removeAttribute('contenteditable'); }
          if(n.style){ n.style.pointerEvents='none'; n.style.userSelect='none'; }
        }catch(_){}
      });
      stripTransformsDeep(node);
    }catch(_){}
    return node;
  }

  function swapPNGsToSVGs(container){
    if(!container) return;
    var MAP = window.__SRC_SVG__ || null;
    container.querySelectorAll('img').forEach(function(img){
      var svg = img.getAttribute('data-src-svg');
      if(!svg && MAP){
        var id = img.getAttribute('data-sticker-id') || img.getAttribute('alt') || img.getAttribute('title');
        if(id && MAP[id]) svg = MAP[id];
      }
      if(!svg && img.src){
        if (/^data:image\/png/i.test(img.src)){
          // cannot infer -> leave as is unless we have sticker id
        } else if (/\.png(\?|#|$)/i.test(img.src)){
          svg = img.src.replace(/\.png(\?|#|$)/i, '.svg$1');
        }
      }
      if(svg) img.src = svg;
    });
    container.querySelectorAll('[data-src-svg]').forEach(function(el){
      if(el.tagName==='IMG') return;
      var svg = el.getAttribute('data-src-svg');
      if(!svg && MAP){
        var id = el.getAttribute('data-sticker-id') || el.getAttribute('aria-label');
        if(id && MAP[id]) svg = MAP[id];
      }
      if(!svg){
        try{
          var bg = getComputedStyle(el).backgroundImage||'';
          var u = bg.replace(/^url\((["']?)(.*?)\1\)$/,'$2');
          if(u && /\.png(\?|#|$)/i.test(u)) svg = u.replace(/\.png(\?|#|$)/i, '.svg$1');
        }catch(_){}
      }
      if(svg) el.style.backgroundImage = 'url("'+svg+'")';
    });
  }

  function ensureCards(){
    var st=document.getElementById('druck100-stage'); if(!st) return [];
    if(st.querySelectorAll('.druck-card').length<2){
      st.innerHTML='<div class="druck-card"><div class="wrap"></div></div><div class="druck-card"><div class="wrap"></div></div>';
    }
    var cards=st.querySelectorAll('.druck-card'); return [cards[0],cards[1]];
  }

  function cloneSide(sel){
    var src=document.querySelector('#abschluss-card .wrap '+sel);
    var box=document.createElement('div');
    box.style.position='absolute'; box.style.inset='0'; box.style.width='100%'; box.style.height='100%'; box.style.boxSizing='border-box';
    if(src){
      var cl=sanitize(src.cloneNode(true));
      try{ cl.classList.remove('side','front-side','back-side'); }catch(_){}
      while(cl.firstChild) box.appendChild(cl.firstChild);
    }
    return box;
  }

  
  function forceSymbolPng(container){
    try{
      if(!container) return;
      container.querySelectorAll('img').forEach(function(img){
        var src = img.getAttribute('src') || '';
        if(/\.svg(\?.*)?$/i.test(src)){
          img.setAttribute('src', src.replace(/\.svg(\?.*)?$/i, '_symbol.png$1'));
        }
      });
      container.querySelectorAll('*').forEach(function(el){
        if(!el || !el.style) return;
        var bg = el.style.backgroundImage || '';
        var m = bg && bg.match(/url\(["']?([^"')]+)["']?\)/i);
        if(m && /\.svg(\?.*)?$/i.test(m[1])){
          var url = m[1];
          var nu = url.replace(/\.svg(\?.*)?$/i, '_symbol.png$1');
          el.style.backgroundImage = 'url("'+nu+'")';
        }
      });
    }catch(_){}
  }

function copyAbschlussToDruck(){
    try{
      setStatus('Übernehme …');
      var pair=ensureCards();
      if(!pair.length){ setStatus('Fehler: Druckkarten fehlen'); return; }
      var fw=pair[0].querySelector('.wrap'), bw=pair[1].querySelector('.wrap');
      if(!fw||!bw){ setStatus('Fehler: Wraps fehlen'); return; }
      fw.innerHTML=''; bw.innerHTML='';
      fw.appendChild(cloneSide('.front-side'));
      bw.appendChild(cloneSide('.back-side'));
      // PNG behalten: keine Umstellung mehr auf SVG oder andere Formate – und SVG-Reste hart auf *_symbol.png drehen
      forceSymbolPng(fw);
      forceSymbolPng(bw);
      setStatus('Karte in den Druckbereich übernommen');
    }catch(e){ console.error(e); setStatus('Fehler bei Übernahme'); }
  }

  document.addEventListener('DOMContentLoaded', function(){
    var head = document.getElementsByTagName('head')[0];
    // ensure maps exist (they are embedded by the patch)
    var btn=document.getElementById('ead-copy-print');
    if(btn && !btn.__b){ btn.addEventListener('click', function(e){ e.preventDefault(); copyAbschlussToDruck(); }, true); btn.__b=true; }
  });
})();
</script>
<script id="override-stickerFileFor">
/* PNG-Baseline: Sticker ohne hartcodierte Namen/Endungen – nur noch CSV-Maps */
(function(){
  'use strict';
  function normLabel(s){
    try{
      if (typeof window.stickerNorm === 'function') return window.stickerNorm(s);
      s = String(s||'').trim().toLowerCase();
      s = s.replace(/ä/g,'ae').replace(/ö/g,'oe').replace(/ü/g,'ue').replace(/ß/g,'ss');
      s = s.replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
      return s;
    }catch(_){ return ''; }
  }
  function idFromLabel(label){
    const key = normLabel(label);
    if (!key) return null;
    if (typeof normalizePngMap==='function') normalizePngMap();
    const PNG = window.__SRC_PNG__ || {};
    const cands = [key, key.replace(/-/g,'_'), key.replace(/_/g,'-')];
    for (const id of cands){ if (PNG[id]) return id; }
    return null;
  }
  try{
    var d = Object.getOwnPropertyDescriptor(window,'stickerFileFor');
    if (d && d.writable === false) return;
  }catch(_){}
  window.stickerFileFor = function(label){
    if (typeof normalizePngMap==='function') normalizePngMap();
    const PNG = window.__SRC_PNG__ || {};
    const id = idFromLabel(label);
    return id ? (PNG[id] || '') : '';
  };
})();
</script>
<script id="png-baseline-guard">
/* Abschluss/Druck nach jeder Übernahme hart auf PNG setzen */
(function(){
  'use strict';
  function forceAreaToPNG(root){
    if (typeof normalizePngMap==='function') normalizePngMap();
    const PNG = window.__SRC_PNG__ || {};
    if (!root) return;
    root.querySelectorAll('[data-asset-id]').forEach(el=>{
      const id  = el.getAttribute('data-asset-id');
      const url = id && PNG[id] ? PNG[id] : '';
      if (!url) return;
      el.setAttribute('data-src-png', url);
      el.removeAttribute('data-src-svg');
      const tag = (el.tagName||'').toUpperCase();
      if (tag==='IMG') el.src = url;
      else if (tag==='IMAGE'){ el.setAttribute('href', url); el.setAttribute('xlink:href', url); }
      else el.style.backgroundImage = `url("${url}")`;
    });
  }
  function afterCopy(){
    forceAreaToPNG(document.getElementById('abschluss-stage') || document.getElementById('abschluss-card'));
    forceAreaToPNG(document.getElementById('druck100-stage')  || document.getElementById('druck'));
  }
  const mo = new MutationObserver(afterCopy);
  mo.observe(document.body, {subtree:true, childList:true});
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', afterCopy);
  else afterCopy();
})();
</script>
<script id="png-area-guard">
(function(){
  'use strict';
  function forceAreaToPNG(root){
    if (typeof normalizePngMap==='function') normalizePngMap();
    const PNG = window.__SRC_PNG__ || {};
    if (!root) return;
    root.querySelectorAll('[data-asset-id]').forEach(el=>{
      const id  = el.getAttribute('data-asset-id');
      const url = id && PNG[id] ? PNG[id] : '';
      if (!url) return;
      el.setAttribute('data-src-png', url);
      el.removeAttribute('data-src-svg');
      const tag = (el.tagName||'').toUpperCase();
      if (tag==='IMG') el.src = url;
      else if (tag==='IMAGE'){ el.setAttribute('href', url); el.setAttribute('xlink:href', url); }
      else el.style.backgroundImage = `url("${url}")`;
    });
  }
  function afterCopy(){
    forceAreaToPNG(document.getElementById('abschluss-stage') || document.getElementById('abschluss-card'));
    forceAreaToPNG(document.getElementById('druck100-stage')  || document.getElementById('druck'));
  }
  const mo = new MutationObserver(afterCopy);
  mo.observe(document.body, {subtree:true, childList:true});
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', afterCopy);
  else afterCopy();
})();
</script>
<script id="png-map-normalize">
(function(){
  'use strict';
  // Regel: Aus "…/name.svg" wird "…/name_symbol.png"
  function svgToPngSymbol(u){
    if (!u) return '';
    // nur Dateinamen ohne Ordner nehmen und .svg -> _symbol.png
    const name = String(u).split('/').pop();
    return name.replace(/\.svg(\?|#|$)/i, '_symbol.png');
  }

  function normalizePngMap(){
    const P = (window.__SRC_PNG__ = window.__SRC_PNG__ || {});
    const S = window.__SRC_SVG__ || {};

    // 1) Bestehende PNG-Einträge korrigieren, falls versehentlich .svg drin steht
    for (const [id, url] of Object.entries(P)){
      if (/\.svg(\?|#|$)/i.test(url)) P[id] = svgToPngSymbol(url);
      // Alle Pfade auf Dateinamen reduzieren (GitHub: alle PNGs im Root)
      if (P[id]) P[id] = String(P[id]).split('/').pop();
    }

    // 2) Fehlende PNG-Einträge aus der SVG-Map ableiten (Spalte 3 → Spalte 4)
    for (const [id, svgUrl] of Object.entries(S)){
      if (!P[id] || !/\.png(\?|#|$)/i.test(P[id])) P[id] = svgToPngSymbol(svgUrl);
      if (P[id]) P[id] = String(P[id]).replace(/(^|\/+)sticker\//i, '');
    }
  }

  function run(){
    normalizePngMap();
    // vorhandene Render-Funktion erneut anwenden, damit überall der PNG-Pfad greift
    try{ if (typeof window.applyMode==='function') window.applyMode(); }catch(_){}
    // GitHub-Fix: alle Bildpfade aus Unterordnern ins Root holen
    try{
      document.querySelectorAll('img').forEach(function(img){
        ['src','data-src-png','data-src-svg'].forEach(function(attr){
          var val = (attr === 'src') ? img.getAttribute('src') : img.getAttribute(attr);
          if (!val) return;
          // Nur Dateinamen behalten (alles vor dem letzten / wegwerfen)
          var file = val.split('/').pop();
          if (attr === 'src') img.setAttribute('src', file);
          else img.setAttribute(attr, file);
        });
      });
    }catch(e){ if (window.console && console.warn) console.warn('img-path-flatten failed', e); }
  }

  if (document.readyState==='loading') {
    document.addEventListener('DOMContentLoaded', run);
  } else {
    run();
  }
})();
</script>
<script id="rb-box-icons-png">
(function(){
  'use strict';

  function svgToSymbolPng(u){
    return String(u||'').replace(/\.svg(\?|#|$)/i, '_symbol.png');
  }

  function fixBoxIcons(scope){
    const root = scope || document;
    let cnt = 0;
    root.querySelectorAll('#rb-boxes .rb-icon img').forEach(img=>{
      const src = img.getAttribute('src') || '';
      if (/\.svg(\?|#|$)/i.test(src)){
        const png = svgToSymbolPng(src);
        if (png !== src){
          img.setAttribute('data-src-png', png);
          img.removeAttribute('data-src-svg');
          img.src = png;
          cnt++;
        }
      }
    });
    if (cnt) console.info('[rb-box-icons] umgestellt auf PNG:', cnt);
  }

  // beim Start und bei späteren Änderungen (wenn Boxen neu aufgebaut werden)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => fixBoxIcons());
  } else {
    fixBoxIcons();
  }
  const mo = new MutationObserver(() => fixBoxIcons());
  const host = document.getElementById('rb-boxes') || document.body;
  mo.observe(host, {subtree:true, childList:true});
})();
</script>
<script id="maps-from-existing">
(function(){
  'use strict';
  // Build PNG map from existing SVG map by .svg -> _symbol.png (no hardcoded names)
  function buildPngFromSvg(){
    const S = window.__SRC_SVG__ || {};
    const P = (window.__SRC_PNG__ = window.__SRC_PNG__ || {});
    for (const k in S){
      if (!Object.prototype.hasOwnProperty.call(S,k)) continue;
      const svg = S[k] || '';
      const png = svgToPngSymbol(svg);
      // Only if not already a png
      if (!P[k]){
        P[k] = png;
      } else if (/\.svg(\?|#|$)/i.test(P[k])){
        // sanitize wrong entries
        P[k] = png;
      }
    }
  }
  // Try to run after CSV/import populates __SRC_SVG__
  const run = ()=>{ try{ buildPngFromSvg(); }catch(e){} };
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', run); else run();
  // If __SRC_SVG__ appears later, rebuild once
  let tries=40; const iv=setInterval(()=>{ if (window.__SRC_SVG__){ run(); clearInterval(iv);} if(--tries<=0) clearInterval(iv); }, 200);
})();
</script>
<script id="asset-mode-switch">
(function(){
  'use strict';
  // Mode default
  window.__ASSET_MODE__ = window.__ASSET_MODE__ || 'PNG';

  // Build SVG map once from PNG if empty/missing
  (function ensureSVGonce(){
    const P = window.__SRC_PNG__ || {};
    const S = (window.__SRC_SVG__ = window.__SRC_SVG__ || {});
    let added = 0;
    for (const k in P){
      if (!S[k]){
        S[k] = String(P[k]).replace(/_symbol\.png(\?|#|$)/i, '.svg');
        added++;
      }
    }
    if (added){
      console.log('[asset-mode-switch] built SVG map entries from PNG:', added);
    }
  })();

  function mapFor(mode){
    return (mode==='SVG') ? (window.__SRC_SVG__||{}) : (window.__SRC_PNG__||{});
  }
  function urlForId(id, mode){
    const M = mapFor(mode);
    if (!id) return '';
    const c = [id, id.replace(/-/g,'_'), id.replace(/_/g,'-'), id.replace(/[_-]+/g,'-')];
    for (let i=0;i<c.length;i++){
      const k = c[i];
      if (M[k]) return M[k];
    }
    return M[id] || '';
  }

  function applyAll(){
    const mode = window.__ASSET_MODE__ || 'PNG';
    const root = document;
    const q = root.querySelectorAll.bind(root);

    q('img[data-asset-id]').forEach(img=>{
      const id  = img.getAttribute('data-asset-id') || '';
      const url = urlForId(id, mode);
      if (url) img.src = url;
    });

    q('img[data-asset-src]').forEach(img=>{
      const base = img.getAttribute('data-asset-src') || '';
      if (!base) return;
      if (mode==='SVG'){
        img.src = base.replace(/_symbol\.png(\?|#|$)/i, '.svg');
      } else {
        img.src = base.replace(/\.svg(\?|#|$)/i, '_symbol.png');
      }
    });

    q('[data-asset-bg]').forEach(el=>{
      const id = el.getAttribute('data-asset-bg') || '';
      const url = urlForId(id, mode);
      if (url){
        el.style.backgroundImage = 'url("'+url+'")';
      }
    });

    window.__ASSET_MODE__ = mode;
    const badge = document.getElementById('asset-mode-indicator');
    if (badge) badge.textContent = mode;
  }

  function debounce(fn, wait){
    let t, running=false;
    return function(){
      if (running) return;
      clearTimeout(t);
      const args = arguments;
      t = setTimeout(function(){
        running=true;
        try { fn.apply(null,args); }
        finally { running=false; }
      }, wait||50);
    };
  }
  const applyAllDebounced = debounce(applyAll, 200);

  function setMode(m){
    // Öffentlicher Konfigurator: nur PNG
    window.__ASSET_MODE__ = 'PNG';
    applyAll();
  }
  window.setAssetMode = setMode;

  function bindButtons(){
    const p = document.getElementById('mini-png');
    const s = document.getElementById('mini-svg');
    if (p) p.addEventListener('click', ()=>setMode('PNG'));
    if (s) p.addEventListener('click', ()=>setMode('SVG'));
  }

  function start(){
    bindButtons();
    applyAll();
    const targets = [
      document.getElementById('rb-boxes'),
      document.getElementById('abschluss-card'),
      document.getElementById('druck100-stage'),
      document.getElementById('karte-vorderseite-front-wrapper'),
      document.getElementById('karte-rueckseite-front-wrapper')
    ].filter(Boolean);
    targets.forEach(t => new MutationObserver(applyAllDebounced).observe(t, {childList:true, subtree:true}));
  }

  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', start);
  else start();
})();
</script>
<!-- BEGIN: abschluss-zoom-buttons-wireup -->
<script id="abschluss-zoom-buttons-wireup">
(function(){
  var stage = document.getElementById('abschluss-stage');
  if (!stage) return;

  function setAbsZoom(z){
    // Abschluss bleibt vom Editor entkoppelt
    stage.style.setProperty('--zoom', '1');

    var frame = document.getElementById('abschluss-card-frame');
    var wraps = stage.querySelectorAll('.wrap');

    if (z === 150) {
      stage.classList.add('zoom-150');
      stage.classList.remove('zoom-100');
      if (frame) {
        frame.style.transformOrigin = 'top left';
        frame.style.transform = 'none';
      }
      wraps.forEach(function(w){ w.style.transform = 'none'; w.style.transformOrigin = 'top left'; });
    } else { // 100
      stage.classList.add('zoom-100');
      stage.classList.remove('zoom-150');
      if (frame) {
        frame.style.transformOrigin = 'top center';
        frame.style.transform = 'none';
      }
      wraps.forEach(function(w){ w.style.transform = 'none'; w.style.transformOrigin = 'top left'; });
    }
  }

  // Delegation nur innerhalb der Abschluss-Controls:
  document.addEventListener('click', function(ev){
    var btn = ev.target && ev.target.closest('#abschluss-controls [data-zoom], #abschluss-controls button');
    if (!btn) return;

    // 1) bevorzugt data-zoom nutzen
    var z = btn.hasAttribute('data-zoom') ? Number(btn.getAttribute('data-zoom')) : null;

    // 2) sonst am Text erkennen (z.B. "150 %", "100%")
    if (z == null) {
      var t = (btn.textContent || '').replace(/\s+/g,'').toLowerCase();
      if (/\b150%?\b/.test(t)) z = 150;
      else if (/\b100%?\b/.test(t)) z = 100;
    }
    if (z !== 100 && z !== 150) return;

    // Lokaler Abschluss-Zoom soll gelten – globale alte Handler ausbremsen
    ev.preventDefault();
    ev.stopPropagation();

    setAbsZoom(z);
  }, true); // capture=true: wir greifen vor evtl. alten Handlern
})();
</script>
<!-- END: abschluss-zoom-buttons-wireup -->
<script>
(function(){
  const stage = document.getElementById('abschluss-stage');
  if (!stage) return;

  // Fängt globale Zoom-Handler ab, wenn der Klick aus den Abschluss-Controls kommt
  document.addEventListener('click', function(ev){
    const inAbsCtrl = ev.target && ev.target.closest('#abschluss-controls');
    if (!inAbsCtrl) return;                // nur Abschluss-Buttons abfangen
    ev.stopPropagation(); ev.preventDefault();  // globale Zoom-Logik stilllegen

    // Nur bei echten Zoom-Buttons den Abschluss-Zoom verändern
    const target = ev.target;
    if (!target) return;

    let z = null;
    const dz = (target.getAttribute('data-zoom') || '').trim();
    if (dz === '150' || dz === '100') {
      z = Number(dz);
    } else {
      const t = (target.textContent || '').replace(/\s+/g,'').toLowerCase();
      if (/150%?/.test(t)) z = 150;
      else if (/100%?/.test(t)) z = 100;
    }

    // Kein Zoom-Befehl -> Zoom unverändert lassen
    if (z !== 100 && z !== 150) return;

    stage.style.setProperty('--zoom', z === 150 ? '1.5' : '1');  // Abschluss-Zoom 100/150 % sauber mitziehen
    if (window.setGlobalZoom) {
      window.setGlobalZoom(z === 150 ? 1.5 : 1);
    }
    stage.classList.toggle('zoom-150', z === 150);
    stage.classList.toggle('zoom-100', z !== 150);

    const frame = document.getElementById('abschluss-card-frame');
    if (frame){
      frame.style.transformOrigin = 'top left';
      frame.style.transform = 'none';
    }
    // Doppel-Skalierung über Wrap verhindern
    stage.querySelectorAll('.wrap').forEach(function(w){
      w.style.transform = 'none';
      w.style.transformOrigin = 'top left';
    });
  }, true); // capture=true: vor globalen Handlern greifen
})();
</script>

<script>
(function(){
  "use strict";
  function $(s){ try{return document.querySelector(s)}catch(_){return null} }
  function show(el){
    if(!el) return;
    el.removeAttribute('hidden');
    el.setAttribute('aria-hidden','false');
    if (el.classList){ el.classList.remove('hidden','is-hidden','d-none','invisible','ppk-hide','ppk-off'); }
    if (el.style){
      el.style.removeProperty('display');
      el.style.removeProperty('visibility');
      el.style.removeProperty('opacity');
    }
  }
  function hide(el){ if(el&&el.style) el.style.display='none'; }
  function showEditor(){
    hide($('#abschluss-panel') || $('#abschluss') || $('#abschluss-stage'));
    document.body.classList.remove('show-abschluss','abschluss-open');
    var candidates = ['#karten-editor','#editor','#kartenbereich','.columns','.frame'];
    for (var i=0;i<candidates.length;i++){ var el=$(candidates[i]); if(el){ show(el); break; } }
    var frame=$('.frame'); if(frame){
      Array.from(frame.children||[]).forEach(function(n){
        try{ if(getComputedStyle(n).display==='none') n.style.display=''; }catch(_){}
      });
    }
  }
  function scrollTop(){
    var t=$('.steuerleiste')||$('#editor-top')||$('#kartenbereich')||$('.frame')||document.body;
    try{ t.scrollIntoView({behavior:'smooth',block:'start'}); }
    catch(_){ window.scrollTo({top:0,behavior:'smooth'}); }
  }
  function back(ev){
    if(ev){ ev.preventDefault(); ev.stopPropagation(); if(ev.stopImmediatePropagation) ev.stopImmediatePropagation(); }
    showEditor();
    setTimeout(scrollTop,50); setTimeout(scrollTop,180); setTimeout(scrollTop,320);
  }
  var btn=document.getElementById('btn-abschluss-back');
  if(btn){ try{ btn.removeAttribute('onclick'); }catch(_){ } btn.addEventListener('click', back, true); }
  var panel = document.getElementById('abschluss-panel');
  if (panel && window.MutationObserver){
    try{
      new MutationObserver(function(){
        var vis = !!(panel.offsetParent!==null && getComputedStyle(panel).display!=='none');
        if(!vis){ showEditor(); setTimeout(scrollTop,80); }
      }).observe(panel,{attributes:true,attributeFilter:['style','class','hidden','aria-hidden']});
    }catch(_){}
  }
})();
</script>
<style data-group="other" id="toolbar-fullbleed-like-compare">
  /* Hintergrund direkt auf die Steuerleiste, wie in der Vergleichsdatei */
  .steuerleiste{
    background: url('steuerleiste_bg_980_cropped.png')
                left center / cover no-repeat #e6efe6 !important;
    /* Full-bleed: Rahmen-Padding (16px) links/rechts ausgleichen */
    margin-left: -16px !important;
    margin-right: -16px !important;
    /* Innenabstand beibehalten: eigenes 16px + Ausgleich 16px */
    padding-left: calc(16px + 16px) !important;
    padding-right: calc(16px + 16px) !important;
  }
  /* Falls noch alte ::before-Hintergründe aktiv sind, abschalten */
  .steuerleiste::before{ content: none !important; background: none !important; }
</style>
<style data-group="base" id="wixframe-980-exact">
  /* WIX-Rahmen: 980px zentriert */
  .content, .wrapper, #app, body > main {
    width: 980px !important;
    max-width: 980px !important;
    margin: 0 auto !important;
    box-sizing: border-box !important;
  }

  /* Toolbar-Hintergrund exakt im Rahmen, ohne Bleed */
  .steuerleiste{
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 16px !important;
    padding-right: 16px !important;
    background-position: left center !important;
    background-size: 100% 100% !important;
    background-origin: border-box !important;
    background-clip: border-box !important;
  }
</style>
<style data-group="other" id="feld6-7-caret-minimal">
  /* Beide Dropdowns optisch als Dropdown kenntlich machen, ohne Breite zu verändern */
  #front-controls #spruchSelect,
  #front-controls #smileySelect{
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image:
      url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24'><path fill='black' d='M7 10l5 5 5-5z'/></svg>");
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 14px 14px;
    cursor: pointer;
  }
  /* Farbangleich: Gelb & Kontur wie Feld 6 (falls Style fehlt) */
  #front-controls #spruchSelect,
  #front-controls #smileySelect{
    background-color: #FFD86B !important;
    border: 0.5mm solid #000 !important;
    color: #000 !important;
    border-radius: 6px !important;
  }
  #front-controls #spruchSelect:hover,
  #front-controls #smileySelect:hover{ background-color: #FFD86B !important; }
  #front-controls #spruchSelect:focus,
  #front-controls #smileySelect:focus{
    outline: 0.5mm solid #000 !important;
    outline-offset: 0 !important;
    background-color: #FFC74D !important;
  }
</style>
<style data-group="other" id="feld6-7-dropdown-visibility">
  /* Feld 7 (Custom): Trigger-Button wie Feld 6 einfärben + Caret */
  #front-controls #feld7-trigger{
    background: #FFD86B !important;
    border: 0.5mm solid #000 !important;
    color: #000 !important;
    border-radius: 6px !important;
    line-height: 1.2 !important;
    position: relative !important;
    padding-right: 28px !important; /* Platz für Caret, ohne Breite zu ändern */
    min-height: 40px !important;
    cursor: pointer !important;
  }
  #front-controls #feld7-trigger:hover{ background: #FFD86B !important; }
  #front-controls #feld7-trigger:focus{
    outline: 0.5mm solid #000 !important;
    background: #FFC74D !important;
  }
  #front-controls #feld7-trigger::after{
    content: "" !important;
    position: absolute !important;
    right: 10px !important;
    top: 50% !important;
    transform: translateY(-50%) !important;
    width: 14px !important;
    height: 14px !important;
    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24'><path fill='black' d='M7 10l5 5 5-5z'/></svg>") !important;
    background-repeat: no-repeat !important;
    background-size: 14px 14px !important;
    pointer-events: none !important;
  }

  /* Feld 6 (native select): sichtbares Caret erzwingen */
  #front-controls #spruchSelect{
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    appearance: none !important;
    background-color: #FFD86B !important;
    border: 0.5mm solid #000 !important;
    color: #000 !important;
    border-radius: 6px !important;
    line-height: 1.2 !important;
    padding-right: 28px !important;  /* Platz für Caret */
    min-height: 40px !important;
    cursor: pointer !important;

    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24'><path fill='black' d='M7 10l5 5 5-5z'/></svg>") !important;
    background-repeat: no-repeat !important;
    background-position: right 10px center !important;
    background-size: 14px 14px !important;
  }
  #front-controls #spruchSelect:hover{ background-color: #FFD86B !important; }
  #front-controls #spruchSelect:focus{
    outline: 0.5mm solid #000 !important;
    background-color: #FFC74D !important;
  }
</style>
<style data-group="other" id="feld6-custom-panel-style">
  #spruchCustomPanel{
    display:none;
    position: static;
    margin-top: 10px;
  }
  #spruchCustomPanel .scp-inner{
    background: #FFD86B;
    border: 0.5mm solid #000;
    border-radius: 8px;
    padding: 10px;
    width: 100%;
    box-shadow: none;
  }
  #spruchCustomPanel .scp-label{ display:block; font-weight:700; margin-bottom:6px; }
  #spruchCustomPanel textarea{
    width: 100%; resize: vertical; min-height: 80px;
    border: 0.5mm solid #000; border-radius: 6px; padding: 8px;
    font-family: inherit; font-size: 14px;
    box-sizing: border-box;
  }
  #spruchCustomPanel .scp-hint{ margin-top:6px; font-size:12px; opacity:0.8; }
  #spruchCustomPanel .scp-actions{ display:flex; gap:8px; margin-top:10px; justify-content:flex-end; }
  #spruchCustomPanel .scp-actions button{
    background:#FFF7CC; border:0.5mm solid #000; border-radius:6px; padding:6px 10px; font-weight:600; cursor:pointer;
  }
  #spruchCustomPanel .scp-actions button:hover{ background:#FFD86B; }
</style>
<script id="feld6-custom-panel-script">
(function(){
  var sel    = document.getElementById('spruchSelect');
  var panel  = document.getElementById('spruchCustomPanel');
  var inner  = panel && panel.querySelector('.scp-inner');
  var input  = document.getElementById('spruchCustomInput');
  var apply  = document.getElementById('spruchApplyBtn');
  var cancel = document.getElementById('spruchCancelBtn');
  var slot   = document.getElementById('spruchAnzeige');

  function openPanel(){
    if(!sel || !panel || !inner) return;
    panel.style.display = 'block';
    panel.setAttribute('aria-hidden','false');
    if(slot && input){ input.value = (slot.textContent||'').trim(); }
    if(input){ input.focus(); if (input.select) input.select(); }
  }
  function closePanel(){
    if(!panel) return;
    panel.style.display = 'none';
    panel.setAttribute('aria-hidden','true');
    if(input){ input.blur(); }
  }
  function applyText(){
    if(!input || !slot) { closePanel(); return; }
    var val = (input.value||'').trim();
    slot.textContent = val;
    if(sel){
      var hasCustom = Array.prototype.some.call(sel.options||[], function(o){ return o && o.value==='__custom__'; });
      if(hasCustom) sel.value='__custom__';
    }
    closePanel();
  }

  if(sel){
    sel.addEventListener('change', function(){
      if(sel.value === '__custom__'){
        openPanel();
      } else if(slot){
        var label = sel.options && sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].text : '';
        slot.textContent = sel.value || label || '';
        closePanel();
      }
    });
  }
  if(apply){  apply.addEventListener('click', applyText); }
  if(cancel){ cancel.addEventListener('click', closePanel); }

  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && panel && panel.style.display === 'block'){ closePanel(); }
  });
})();
</script>
<style data-group="other" id="caret-bigger-override">
  /* Größere Carets, ohne Breite zu ändern */
  #front-controls #spruchSelect{
    background-size: 20px 20px !important;
    background-position: right 12px center !important;
    padding-right: 36px !important; /* Platz für größeren Pfeil */
  }
  #front-controls #feld7-trigger::after{
    width: 20px !important;
    height: 20px !important;
    right: 12px !important;
    background-size: 20px 20px !important;
  }
</style>
<style data-group="base" id="feld6-freitext-popup">
  #front-controls, .front-controls{ position:relative; overflow:visible !important; }
  .spruch-popup{
    position:absolute;
    min-width: 320px;
    max-width: 420px;
    background:#FFD86B;
    border:0.5mm solid #000;
    border-radius:8px;
    box-shadow: 0 6px 14px rgba(0,0,0,.2);
    z-index: 50;
    display:none;
  }
  .spruch-popup.open{ display:block; }
  .spruch-popup .sp-head{
    font-weight:700; text-align:center; padding:6px 10px; border-bottom:0.5mm solid #000;
  }
  .spruch-popup .sp-body{ padding:8px 10px; }
  .spruch-popup textarea{
    width:100%; min-height:70px; resize:vertical; box-sizing:border-box;
    border:0.5mm solid #000; border-radius:6px; padding:8px; font:inherit;
  }
  .spruch-popup .sp-hint{
  margin-top: 8px !important;
  background: #fff !important;
  border: 3px solid #b00020 !important;  /* Rot wie im Screenshot */
  color: #000 !important;
  border-radius: 6px !important;
  padding: 10px 12px !important;
  font-size: 13px !important;
  line-height: 1.3 !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.08) !important;
}
  .spruch-popup .sp-actions{
    display:flex; gap:8px; justify-content:flex-end; border-top:0.5mm solid #000; padding:8px 10px;
  }
  .spruch-popup .sp-actions button{
    background:#FFF7CC; border:0.5mm solid #000; border-radius:6px; padding:6px 10px; font-weight:600; cursor:pointer;
  }
  .spruch-popup .sp-actions button:hover{ background:#FFD86B; }
</style>
<script id="feld6-freitext-popup-logic">
(function(){
  var front  = document.getElementById('front-controls') || document.querySelector('.front-controls');
  var sel    = document.getElementById('spruchSelect');
  var popup  = document.getElementById('spruchPopup');
  var input  = document.getElementById('spruchPopupInput');
  var apply  = document.getElementById('spruchPopupApply');
  var cancel = document.getElementById('spruchPopupCancel');
  var slot   = document.getElementById('spruchAnzeige');

  function placePopup(){
    if(!front || !popup || !sel) return;
    var r = sel.getBoundingClientRect();
    var fr = front.getBoundingClientRect();
    var left = (r.left - fr.left);
    popup.style.left = Math.max(0, left) + 'px';
    popup.style.top  = (sel.offsetTop + sel.offsetHeight + 8) + 'px';
  }

  function openPopup(){
    if(!popup) return;
    placePopup();
    popup.classList.add('open');
    popup.setAttribute('aria-hidden', 'false');
    if(slot && input){ input.value = slot.textContent || ''; }
    setTimeout(function(){ input && input.focus(); }, 0);
  }

  function closePopup(){
    if(!popup) return;
    popup.classList.remove('open');
    popup.setAttribute('aria-hidden', 'true');
  }

  function applyText(){
    if(slot && input){ slot.textContent = input.value || ''; }
    closePopup();
    if(sel) sel.selectedIndex = 0;
  }

  if(sel){
    // sicherstellen, dass es eine Freitext-Option gibt
    var hasCustom = false;
    for (var i=0;i<sel.options.length;i++){ if(sel.options[i].value === '__custom__'){ hasCustom = true; break; } }
    if(!hasCustom){
      var opt = document.createElement('option');
      opt.value = '__custom__'; opt.text = '✎ Freitext …';
      sel.appendChild(opt);
    }
    sel.addEventListener('change', function(){
      if(sel.value === '__custom__'){ openPopup(); }
      else { closePopup(); if(slot){ slot.textContent = sel.options[sel.selectedIndex].text; } }
    });
  }

  if(apply)  apply.addEventListener('click', applyText);
  if(cancel) cancel.addEventListener('click', closePopup);

  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape' && popup && popup.classList.contains('open')) closePopup();
  });
  window.addEventListener('resize', placePopup);
  window.addEventListener('scroll', placePopup, true);
})();
</script>
<style data-group="card" id="controls-outside-card-fix">
  /* Ensure the area that contains the card acts as positioning context */
  .front-wrapper, #card-preview, #kartenbereich, .karte-preview, #karte, #kartenframe, .preview-area {
    position: relative;
  }
  /* Push the controls row below the card frame */
  #front-controls, .front-controls {
    position: absolute;
    left: 0; right: 0;
    top: calc(100% + 8mm);      /* 8mm Abstand unterhalb des Kartenrahmens */
    margin: 0 auto;
    width: 100%;
    z-index: 30;
  }
  /* Make sure content within the card does not clip the controls */
  .front-wrapper *, #card-preview *, #kartenbereich * { overflow: visible; }
</style>
<style data-group="other" id="hide-rogue-right-panel">
  /* Falls es noch eine alte rechte Panel-Variante gibt, weg damit */
  .spruch-right-panel, #spruchPanelRight { display: none !important; }
</style>
<script id="kill-custom-text">
(function(){
  function scrubCustomText(root){
    var tree = document.createNodeIterator(root || document.body, NodeFilter.SHOW_TEXT);
    var n;
    while((n = tree.nextNode())){
      if(n.nodeValue && n.nodeValue.trim() === "__custom__"){
        n.nodeValue = "";
      }
    }
  }
  // Initial
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", function(){ scrubCustomText(document.body); });
  } else {
    scrubCustomText(document.body);
  }
  // Changes over time (e.g., when selections update labels)
  var mo = new MutationObserver(function(){
    scrubCustomText(document.body);
  });
  mo.observe(document.body, { subtree: true, childList: true, characterData: true });
})();
</script>
<style data-group="base" id="feld6-popup-compact-2x20">
  .spruch-popup{ min-width: 260px; max-width: 320px; }
  .spruch-popup .sp-body{ padding:6px 8px; }
  .spruch-popup textarea{
    min-height: 2.6em; max-height: 3.2em; line-height:1.2; padding:6px; 
    font-size: 0.95em;
  }
  .spruch-popup .sp-actions{ padding:6px 8px; }
</style>
<script id="feld6-popup-limit-2x20">
(function(){
  var ta = document.getElementById('spruchPopupInput');
  if(!ta) return;
  // ensure attribute rows=2 for screen readers/browsers that respect it
  ta.setAttribute('rows','2');
  function clamp2x20(s){
    s = s.replace(/\r\n?/g, "\n");
    var parts = s.split("\n");
    // keep max 2 lines
    parts = parts.slice(0,2);
    for (var i=0;i<parts.length;i++){
      if (parts[i].length > 20) parts[i] = parts[i].slice(0,20);
    }
    // ensure at most 2 lines; if first is empty and second exists, keep both
    return parts.join("\n");
  }
  function onInput(){
    var cur = ta.value;
    var clamped = clamp2x20(cur);
    if (clamped !== cur){
      var pos = ta.selectionStart;
      ta.value = clamped;
      // reset caret to end (simple + robust)
      ta.selectionStart = ta.selectionEnd = ta.value.length;
    }
  }
  ta.addEventListener('input', onInput);
  // also intercept Enter without Shift to avoid accidental newlines beyond 2
  ta.addEventListener('keydown', function(e){
    if (e.key === 'Enter' && !e.shiftKey){
      // convert to Shift+Enter behavior by preventing default
      e.preventDefault();
    }
  });
  // initial clamp in case of prefilled content
  onInput();
})();
</script>
<style data-group="base" id="o1s-hide-pills-ultimate">
/* O1s: Endgültig alle Pillen-Layouts ausblenden (übersteuert alles) */
body .rb-pills,
body .rb-pill,
body .rb-pills-container,
body .rb-pill-row {
  display: none !important;
  visibility: hidden !important;
  height: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
}
</style>
<style data-group="card" data-note="last override" id="final-back-hint-opaque">
/* Endgültige Erzwingung: Rückseiten-Hinweis deckend weiß, normaler Blend, kein Pseudo-Background */
#karte-rueckseite .slot-hint{
  background-color: #FFFFFF !important;
  background: #FFFFFF !important;
  background-image: none !important;
  border: 0.7mm solid #800020 !important;
  opacity: 1 !important;
  filter: none !important;
  mix-blend-mode: normal !important;
  backdrop-filter: none !important;
}
#karte-rueckseite .slot-hint::before{ display: none !important; }
</style>
<style>
.steuerleiste #sl5-title-overlay #ps-title-fixed.ps-title{
  font-size: 24px !important;
  line-height: 1.15 !important;
}
</style>
<style>
/* Linksbündig in Spalte 1 + 26px */
.steuerleiste #sl5-title-overlay #ps-title-fixed.ps-title{
  justify-self: start !important;
  text-align: left !important;
  padding-left: 12px !important;  /* an Eingabefeld-Indent angelehnt */
  font-size: 26px !important;
  line-height: 1.15 !important;
}
</style>
<style>
/* Titel linksbündig, 28px, ohne Abschneiden */
.steuerleiste #sl5-title-overlay #ps-title-fixed.ps-title{
  font-size: 28px !important;
  line-height: 1.15 !important;
  text-align: left !important;
  justify-self: start !important;
  padding-left: 12px !important;
  white-space: normal !important;     /* darf umbrechen */
  overflow: visible !important;       /* kein Ausblenden */
  text-overflow: clip !important;     /* kein Ellipsis */
  word-break: normal !important;
}
</style>
<style>
.steuerleiste #sl5-title-overlay #ps-title-fixed.ps-title{
  font-size: 30px !important;
  line-height: 1.15 !important;
}
</style>
<script id="asset-mode-local">
(function(){
  'use strict';
  window.__ASSET_MODE__ = window.__ASSET_MODE__ || 'PNG';

  function toPNG(u){
    if (!u) return '';
    if (/_symbol\.png(\?|#|$)/i.test(u)) return u;
    if (/\.svg(\?|#|$)/i.test(u)) return u.replace(/\.svg(\?|#|$)/i, '_symbol.png$1');
    if (/\.png(\?|#|$)/i.test(u)) return u.replace(/\.png(\?|#|$)/i, '_symbol.png$1');
    return u;
  }
  function toSVG(u){
    if (!u) return '';
    if (/\.svg(\?|#|$)/i.test(u)) return u;
    if (/_symbol\.png(\?|#|$)/i.test(u)) return u.replace(/_symbol\.png(\?|#|$)/i, '.svg$1');
    if (/\.png(\?|#|$)/i.test(u)) return u.replace(/\.png(\?|#|$)/i, '.svg$1');
    return u;
  }

  function getSrc(el){
    const tag = (el.tagName||'').toUpperCase();
    if (tag === 'IMG')   return el.getAttribute('src') || '';
    if (tag === 'IMAGE') return el.getAttribute('href') || el.getAttribute('xlink:href') || '';
    const bg = (getComputedStyle(el).backgroundImage||'');
    const m = /^url\(["']?(.*?)["']?\)/.exec(bg);
    return m ? m[1] : '';
  }
  function setSrc(el, url){
    const tag = (el.tagName||'').toUpperCase();
    if (!url) return;
    if (tag === 'IMG')        el.src = url;
    else if (tag === 'IMAGE'){ el.setAttribute('href', url); el.setAttribute('xlink:href', url); }
    else                      el.style.backgroundImage = 'url("'+url+'")';
  }

  // nur Sticker-Elemente – eng gefasst
  const SELECTOR = [
    '#rb-boxes .rb-row .rb-icon img',
    '.karte-overlay img[data-rb-origin="sticker"]',
    'img[data-type="sticker"]','image[data-type="sticker"]',
    '#abschluss-card img[data-type="sticker"]','#abschluss-card image[data-type="sticker"]',
    '#druck100-stage img[data-type="sticker"]','#druck100-stage image[data-type="sticker"]',
    '[data-asset-id][data-type="sticker"]','[data-asset-kind="sticker"]'
  ].join(',');

  function forceSwitch(mode){
    let changed = 0;
    document.querySelectorAll(SELECTOR).forEach(el => {
      const ds = el.dataset || {};
      if (!ds.srcPng || !ds.srcSvg){
        const cur = getSrc(el);
        ds.srcPng = ds.srcPng || toPNG(cur);
        ds.srcSvg = ds.srcSvg || toSVG(cur);
        el.dataset.srcPng = ds.srcPng;
        el.dataset.srcSvg = ds.srcSvg;
      }
      const target = (mode === 'SVG') ? el.dataset.srcSvg : el.dataset.srcPng;
      if (target && target !== getSrc(el)){ setSrc(el, target); changed++; }
    });
    const s = document.getElementById('asset-mini-status');
    if (s) s.textContent = '— ' + mode + ' · geändert: ' + changed;
  }

  window.setAssetMode = function(mode){
    if (mode!=='PNG' && mode!=='SVG') return;
    window.__ASSET_MODE__ = mode;
    forceSwitch(mode);
  };

  function boot(){
    forceSwitch(window.__ASSET_MODE__);
    let t;
    const ids = ['rb-boxes','abschluss-card','druck100-stage','karte-vorderseite-front-wrapper','karte-rueckseite-front-wrapper'];
    ids.map(id => document.getElementById(id)).filter(Boolean).forEach(node => {
      new MutationObserver(() => { clearTimeout(t); t=setTimeout(()=>forceSwitch(window.__ASSET_MODE__),120); })
        .observe(node, {childList:true, subtree:true});
    });
  }

  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
<script id="asset-mode-console-exact">
/* ASSET-MODE: PNG <-> SVG, Abschluss & Druck – robust + Diagnose */
(() => {
  function toPNG(u){
    if (!u) return '';
    if (/_symbol\.png(\?|#|$)/i.test(u)) return u;
    if (/\.svg(\?|#|$)/i.test(u)) return u.replace(/\.svg(\?|#|$)/i,'_symbol.png$1');
    if (/\.png(\?|#|$)/i.test(u)) return u.replace(/\.png(\?|#|$)/i,'_symbol.png$1');
    return u;
  }
  function toSVG(u){
    if (!u) return '';
    if (/\.svg(\?|#|$)/i.test(u)) return u;
    if (/_symbol\.png(\?|#|$)/i.test(u)) return u.replace(/_symbol\.png(\?|#|$)/i,'.svg$1');
    if (/\.png(\?|#|$)/i.test(u)) return u.replace(/\.png(\?|#|$)/i,'.svg$1');
    return u;
  }
  function getSrc(el){
    const t=(el.tagName||'').toUpperCase();
    if (t==='IMG') return el.getAttribute('src')||'';
    if (t==='IMAGE') return el.getAttribute('href')||el.getAttribute('xlink:href')||'';
    const m=/^url\(["']?(.*?)["']?\)/.exec((getComputedStyle(el).backgroundImage||'')); 
    return m?m[1]:'';
  }
  function setSrc(el,url){
    const t=(el.tagName||'').toUpperCase();
    if (!url) return;
    if (t==='IMG') el.src=url;
    else if (t==='IMAGE'){ el.setAttribute('href',url); el.setAttribute('xlink:href',url); }
    else el.style.backgroundImage='url("'+url+'")';
  }

  // --- Zielbereiche robuster finden ---
  function regionNodes(){
    const roots = new Set();
    ['abschluss-card','druck100-stage','abschluss','druck','druckbereich','druck-100','abschlussbereich']
      .forEach(id=>{ const el=document.getElementById(id); if (el) roots.add(el); });
    document.querySelectorAll('[id*="abschluss" i],[class*="abschluss" i],[id*="druck" i],[class*="druck" i]')
      .forEach(el=>roots.add(el));
    const sels = ['img','image'];
    const list = [];
    roots.forEach(root=>sels.forEach(s=>root.querySelectorAll(s).forEach(el=>list.push(el))));
    return list;
  }

  function forceSwitch(mode){
    const conv = mode==='SVG'?toSVG:toPNG;
    const nodes = regionNodes();
    let changed=0;
    nodes.forEach(el=>{
      const u0=getSrc(el), u1=conv(u0);
      if (u1 && u1!==u0){ setSrc(el,u1); changed++; }
      if (mode==='SVG'){ el.removeAttribute?.('data-src-png'); el.setAttribute?.('data-src-svg',u1); }
      else              { el.removeAttribute?.('data-src-svg'); el.setAttribute?.('data-src-png',u1); }
    });
    const s = document.getElementById('mode-status')||document.getElementById('asset-mini-status');
    if (s) s.textContent = 'Modus aktiv: '+mode+' — gefunden: '+nodes.length+' · geändert: '+changed;
    window.__DEBUG__ && console.info('[asset switch]', mode, 'nodes=',nodes.length,'changed=',changed);
  }

  window.setAssetMode = function(mode){
    if (mode!=='PNG' && mode!=='SVG') return;
    window.__ASSET_MODE__ = mode;
    forceSwitch(mode);
  };

  // Nur Abschluss/Druck beobachten
  let t;
  const obs = ()=>{ clearTimeout(t); t=setTimeout(()=>forceSwitch(window.__ASSET_MODE__||'PNG'),120); };
  ['abschluss','abschluss-card','abschlussbereich','druck','druckbereich','druck100-stage','druck-100']
    .map(id=>document.getElementById(id)).filter(Boolean)
    .forEach(node=> new MutationObserver(obs).observe(node,{childList:true,subtree:true}));

  window.__ASSET_MODE__ = window.__ASSET_MODE__ || 'PNG';
  setTimeout(()=>forceSwitch(window.__ASSET_MODE__), 50);
})();
</script>
<script>
// === Step 1: Abschluss PNG-Baseline for non-sticker assets ===
// Heuristics: Sticker have filenames ending with *_symbol.(png|svg).
// Backgrounds/lineal do NOT have "_symbol" and must be PNG in Abschlussbereich.
// We do NOT modify the Editor or the Druckbereich here.

(function(){
  function isStickerSrc(url){
    return /_symbol\.(png|svg)(\?.*)?$/i.test(url || '');
  }
  function getSrc(el){
    return el.getAttribute('src') || el.getAttribute('href') || '';
  }
  function setSrc(el, url){
    if (!url) return;
    var tag = (el.tagName||'').toLowerCase();
    if (tag === 'image') {
      el.setAttribute('href', url);
    } else {
      el.setAttribute('src', url);
    }
  }
  function enforceAbschlussPngBaseline(){
    var nodes = document.querySelectorAll('#abschluss-card img, #abschluss-card image');
    nodes.forEach(function(el){
      var src = getSrc(el);
      if(!src) return;
      if(!isStickerSrc(src)){
        // non-sticker (background / lineal) → force .png
        var png = src.replace(/\.svg(\?.*)?$/i, '.png');
        if (png !== src) setSrc(el, png);
      }
    });
  }

  // Run once after DOM is ready (first baseline). Further hooks will be added in later steps.
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', enforceAbschlussPngBaseline, {once:true});
  } else {
    enforceAbschlussPngBaseline();
  }

  // Expose for later steps/tests without polluting too much:
  window._rb_enforceAbschlussPngBaseline = enforceAbschlussPngBaseline;
})();
</script>
<script>
// === Step 2: Abschluss PNG-Baseline — auto-reapply on changes + PNG->SVG fallback ===
(function(){
  var _rb_guard = false;
  var _rb_debounceTimer = null;

  function isStickerSrc(url){
    return /_symbol\.(png|svg)(\?.*)?$/i.test(url || '');
  }
  function getSrc(el){
    return el.getAttribute('src') || el.getAttribute('href') || '';
  }
  function setSrc(el, url){
    if (!url) return;
    var tag = (el.tagName||'').toLowerCase();
    if (tag === 'image') {
      el.setAttribute('href', url);
    } else {
      el.setAttribute('src', url);
    }
  }
  function toPngNonSticker(src){
    // For non-stickers (no *_symbol), force .png (idempotent)
    return (src || '').replace(/\.svg(\?.*)?$/i, '.png');
  }
  function toSvgFromNonSticker(src){
    return (src || '').replace(/\.png(\?.*)?$/i, '.svg');
  }

  function fallbackIfPngMissing(el){
    // Try load a probe image for PNG; on error, revert to SVG for visibility.
    try {
      var src = getSrc(el);
      if (!src) return;
      if (isStickerSrc(src)) return; // stickers not handled here

      // Only test when target looks like PNG
      if (!/\.png(\?.*)?$/i.test(src)) return;

      var test = new Image();
      test.onload = function(){ /* ok */ };
      test.onerror = function(){
        // Revert to SVG for this element; mark with data-flag.
        var svg = toSvgFromNonSticker(src);
        setSrc(el, svg);
        el.setAttribute('data-rb-fallback', 'svg');
        // Optional: console notice for diagnostics
        try { console.info('PNG missing in Abschluss; reverted to SVG:', src); } catch(e){}
      };
      test.src = src;
    } catch(e){}
  }

  function enforceAbschlussPngBaseline(){
    if (_rb_guard) return;
    _rb_guard = true;
    try {
      var nodes = document.querySelectorAll('#abschluss-card img, #abschluss-card image');
      nodes.forEach(function(el){
        var src = getSrc(el);
        if(!src) return;
        if(!isStickerSrc(src)){
          var png = toPngNonSticker(src);
          if (png !== src) setSrc(el, png);
          // If PNG cannot be loaded, fallback to SVG for that element:
          fallbackIfPngMissing(el);
        }
      });
    } finally {
      _rb_guard = false;
    }
  }

  // Debounced re-apply (prevents loops)
  function scheduleEnforce(){
    if (_rb_debounceTimer) clearTimeout(_rb_debounceTimer);
    _rb_debounceTimer = setTimeout(enforceAbschlussPngBaseline, 160);
  }

  // Observe only the Abschluss container for src/href changes
  function installObserver(){
    var root = document.querySelector('#abschluss-card');
    if (!root) return;
    var obs = new MutationObserver(function(muts){
      // If attributes src/href changed on images -> re-apply baseline
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        if (m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'href')){
          scheduleEnforce();
          break;
        }
      }
    });
    obs.observe(root, {
      subtree: true,
      attributes: true,
      attributeFilter: ['src','href']
    });
    // Expose for testing if needed
    window._rb_abschlussObserver = obs;
  }

  // Initial run + observer
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      enforceAbschlussPngBaseline();
      installObserver();
    }, {once:true});
  } else {
    enforceAbschlussPngBaseline();
    installObserver();
  }

  // Expose again (overwriting previous reference from step 1)
  window._rb_enforceAbschlussPngBaseline = enforceAbschlussPngBaseline;
})();
</script>
<script>
// === Step 3: Persist fallback — do not overwrite elements marked as fallback ===
(function(){
  // Patch only if Step 2 objects exist
  function patch(){
    // Re-declare helpers mirroring Step 2 environment
    function isStickerSrc(url){
      return /_symbol\.(png|svg)(\?.*)?$/i.test(url || '');
    }
    function getSrc(el){
      return el.getAttribute('src') || el.getAttribute('href') || '';
    }
    function setSrc(el, url){
      if (!url) return;
      var tag = (el.tagName||'').toLowerCase();
      if (tag === 'image') {
        el.setAttribute('href', url);
      } else {
        el.setAttribute('src', url);
      }
    }
    function toPngNonSticker(src){
      return (src || '').replace(/\.svg(\?.*)?$/i, '.png');
    }
    function toSvgFromNonSticker(src){
      return (src || '').replace(/\.png(\?.*)?$/i, '.svg');
    }

    // Override fallback to set the flag BEFORE switching to SVG (avoid observer flip-flop)
    window._rb_fallbackIfPngMissing = function(el){
      try {
        var src = getSrc(el);
        if (!src) return;
        if (isStickerSrc(src)) return;
        if (!/\.png(\?.*)?$/i.test(src)) return;

        var test = new Image();
        test.onload = function(){ /* ok: PNG exists */ };
        test.onerror = function(){
          // Mark fallback and then set SVG (order matters to avoid immediate re-baseline)
          el.setAttribute('data-rb-fallback', 'svg');
          var svg = toSvgFromNonSticker(src);
          setSrc(el, svg);
          try { console.info('Fallback persisted (no PNG available). Kept as SVG in Abschluss:', src); } catch(e){}
        };
        test.src = src;
      } catch(e){}
    };

    // Override baseline to respect fallback flag
    window._rb_enforceAbschlussPngBaseline = function(){
      var nodes = document.querySelectorAll('#abschluss-card img, #abschluss-card image');
      nodes.forEach(function(el){
        var src = getSrc(el);
        if(!src) return;

        // Respect explicit fallback marker: stay SVG in Abschluss
        if (el.getAttribute('data-rb-fallback') === 'svg') return;

        if(!isStickerSrc(src)){
          var png = toPngNonSticker(src);
          if (png !== src) setSrc(el, png);
          // test and persist fallback if PNG missing
          window._rb_fallbackIfPngMissing(el);
        }
      });
    };

    // Re-run once to apply persistent fallback
    window._rb_enforceAbschlussPngBaseline();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', patch, {once:true});
  } else {
    patch();
  }
})();
</script>
<script>
// === Step 4: Abschluss PNG Hard-Lock for non-sticker assets ===
(function(){
  var _lock_guard = false;

  function isStickerSrc(url){
    return /_symbol\.(png|svg)(\?.*)?$/i.test(url || '');
  }
  function getSrc(el){
    return el.getAttribute('src') || el.getAttribute('href') || '';
  }
  function setSrc(el, url){
    if (!url) return;
    var tag = (el.tagName||'').toLowerCase();
    if (tag === 'image') {
      el.setAttribute('href', url);
    } else {
      el.setAttribute('src', url);
    }
  }
  function toPngNonSticker(src){
    return (src || '').replace(/\.svg(\?.*)?$/i, '.png');
  }

  function correctIfNeeded(target){
    if (!target) return;
    if (_lock_guard) return;
    var src = getSrc(target);
    if (!src) return;
    if (isStickerSrc(src)) return; // stickers dürfen wechseln
    // Non-sticker: muss PNG sein
    if (/\.svg(\?.*)?$/i.test(src)) {
      _lock_guard = true;
      try {
        setSrc(target, toPngNonSticker(src));
        target.setAttribute('data-rb-lock', 'png');
      } finally {
        _lock_guard = false;
      }
    }
  }

  function installHardLockObserver(){
    var root = document.querySelector('#abschluss-card');
    if (!root) return;
    var obs = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        var m = muts[i];
        if (m.type === 'attributes' && (m.attributeName === 'src' || m.attributeName === 'href')){
          correctIfNeeded(m.target);
        }
      }
    });
    obs.observe(root, {
      subtree: true,
      attributes: true,
      attributeFilter: ['src','href']
    });

    // Initial pass (in case DOM already set to SVG)
    root.querySelectorAll('img, image').forEach(correctIfNeeded);

    window._rb_abschlussHardLockObserver = obs;
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', installHardLockObserver, {once:true});
  } else {
    installHardLockObserver();
  }
})();
</script>
<script>
// === Step 5: Abschluss PNG Strong-Lock (src/href + background-image) ===
(function(){
  var _guard = false;
  var _recheckTimer = null;
  var _burstTimer = null;

  function isStickerUrl(u){ return /_symbol\.(png|svg)(\?.*)?$/i.test(u||''); }
  function toPng(u){ return (u||'').replace(/\.svg(\?.*)?$/i, '.png'); }
  function hasSvg(u){ return /\.svg(\?.*)?$/i.test(u||''); }

  function forcePngOnImg(el){
    var src = el.getAttribute('src') || el.getAttribute('href') || '';
    if (!src) return;
    if (isStickerUrl(src)) return; // stickers dürfen wechseln
    if (hasSvg(src)){
      var png = toPng(src);
      if ((el.tagName||'').toLowerCase()==='image') el.setAttribute('href', png);
      else el.setAttribute('src', png);
      el.setAttribute('data-rb-lock','png');
    }
  }

  function forcePngOnBackground(el){
    // inline style only (wir überschreiben nur, wenn ein SVG drinsteht)
    var bg = el.style && el.style.backgroundImage || '';
    if (!bg) return;
    // extract URL
    var m = bg.match(/url\((['"]?)([^)'"]+)\1\)/i);
    if (!m) return;
    var url = m[2] || '';
    if (!url || isStickerUrl(url)) return;
    if (hasSvg(url)){
      var png = toPng(url);
      el.style.backgroundImage = 'url("'+png+'")';
      el.setAttribute('data-rb-lock','png-bg');
    }
  }

  function enforceAll(){
    if (_guard) return;
    _guard = true;
    try{
      var root = document.querySelector('#abschluss-card');
      if (!root) return;
      root.querySelectorAll('img, image').forEach(forcePngOnImg);
      root.querySelectorAll('[style*="background-image"]').forEach(forcePngOnBackground);
    } finally {
      _guard = false;
    }
  }

  function recheckBurst(){
    if (_burstTimer) clearInterval(_burstTimer);
    var count = 0;
    _burstTimer = setInterval(function(){
      enforceAll();
      count++;
      if (count >= 15){ // ~1.5s @100ms
        clearInterval(_burstTimer);
        _burstTimer = null;
      }
    }, 100);
  }

  function scheduleEnforce(){
    if (_recheckTimer) clearTimeout(_recheckTimer);
    _recheckTimer = setTimeout(function(){
      enforceAll();
      recheckBurst();
    }, 60);
  }

  function installObserver(){
    var root = document.querySelector('#abschluss-card');
    if (!root) return;
    var obs = new MutationObserver(function(muts){
      scheduleEnforce();
    });
    obs.observe(root, {
      subtree: true,
      attributes: true,
      childList: true,
      characterData: false
    });
    window._rb_abschlussStrongLockObserver = obs;
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      enforceAll();
      installObserver();
      recheckBurst(); // initial burst
    }, {once:true});
  } else {
    enforceAll();
    installObserver();
    recheckBurst();
  }
})();
</script>
<script>
(function(){
  var logBuf = [];
  var watching = true;
  var moAttr=null, moChild=null;

  function isSticker(u){ return /_symbol\.(png|svg)(\?.*)?$/i.test(u||''); }
  function isSvg(u){ return /\.svg(\?.*)?$/i.test(u||''); }
  function getSrc(el){ return el.getAttribute('src') || el.getAttribute('href') || ''; }

  function log(msg, obj){
      var el = document.getElementById('rb-diag-log');
      var ts = '['+new Date().toLocaleTimeString()+'] ';
      var extra = '';
      if (obj !== undefined) {
        try { extra = ' ' + JSON.stringify(obj); } catch(_) { extra = ' ' + String(obj); }
      }
      var line = ts + String(msg||'') + extra;
      logBuf.push(line);
      if (el){ el.textContent += line + "\n"; el.scrollTop = el.scrollHeight; }
      try{ console.debug('[RB-DIAG]', msg, obj||''); }catch(_){}
    }
    function clearLog(){
    logBuf = []; var el = document.getElementById('rb-diag-log'); if (el) el.textContent='';
  }
  function exportLog(){
    var blob = new Blob([logBuf.join("\n")], {type:'text/plain'});
    var a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='abschluss_diag_log.txt'; a.click();
    setTimeout(function(){ URL.revokeObjectURL(a.href); }, 1000);
  }

  function detectMode(){
    // Heuristik: im DRUCK-Bereich sollte die Karte bei SVG sichtbar sein.
    var dr = document.querySelector('#druck100-stage img, #druck100-stage image');
    var s = dr ? getSrc(dr) : '';
    var m = isSvg(s) ? 'SVG' : (s ? 'PNG' : 'unbekannt');
    var el = document.getElementById('rb-mode'); if (el) el.textContent = m;
    return m;
  }

  function paint(){
    var root = document.querySelector('#abschluss-card');
    if (!root) return {png:0, svg:0, sticker:0};
    var c = {png:0, svg:0, sticker:0};
    root.querySelectorAll('img, image').forEach(function(el){
      var s = getSrc(el);
      if (!s) return;
      if (isSticker(s)){ c.sticker++; el.setAttribute('data-rbdiag','sticker'); return; }
      if (isSvg(s)){ c.svg++; el.setAttribute('data-rbdiag','nonsticker-svg'); }
      else { c.png++; el.setAttribute('data-rbdiag','nonsticker-png'); }
    });
    var sum = document.getElementById('rb-sum');
    if (sum){
      sum.textContent = 'non-sticker: '+c.png+' PNG / '+c.svg+' SVG • sticker: '+c.sticker;
      sum.className = 'pill ' + (c.svg>0 ? 'bad' : 'ok');
    }
    return c;
  }

  function installObservers(){
    var root = document.querySelector('#abschluss-card');
    if (!root) return;
    if (moAttr) moAttr.disconnect();
    if (moChild) moChild.disconnect();

    moAttr = new MutationObserver(function(muts){
      muts.forEach(function(m){
        if (m.type==='attributes' && (m.attributeName==='src' || m.attributeName==='href' || m.attributeName==='style')){
          log('ATTR change', {
            attr:m.attributeName, tag:m.target.tagName, src:getSrc(m.target),
            id:m.target.id||null, class:m.target.className||null
          });
        }
      });
      paint();
    });
    moAttr.observe(root, {subtree:true, attributes:true, attributeFilter:['src','href','style']});

    moChild = new MutationObserver(function(muts){
      log('CHILD change', {len:muts.length});
      paint();
    });
    moChild.observe(root, {subtree:true, childList:true});
  }

  // Monkey-patch setAttribute in Abschluss subtree (logs call sites)
  (function(){
    var _set = Element.prototype.setAttribute;
    Element.prototype.setAttribute = function(name, value){
      try{
        if ((name==='src'||name==='href'||name==='style') && this.closest && this.closest('#abschluss-card')){
          log('setAttribute('+name+')', {value:value, tag:this.tagName, id:this.id||null, class:this.className||null});
        }
      }catch(_){}
      return _set.apply(this, arguments);
    };
  })();

  // UI
  document.addEventListener('click', function(ev){
    var t=ev.target;
    if (!t) return;
    if (t.id==='rb-scan'){ detectMode(); paint(); log('Scan'); }
    if (t.id==='rb-clear'){ clearLog(); }
    if (t.id==='rb-export'){ exportLog(); }
    if (t.id==='rb-watch'){
      watching = !watching;
      t.textContent = 'Watch: ' + (watching? 'an':'aus');
      if (watching) installObservers(); else { if (moAttr) moAttr.disconnect(); if (moChild) moChild.disconnect(); }
    }
  });

  // init
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){ detectMode(); paint(); installObservers(); }, {once:true});
  } else {
    detectMode(); paint(); installObservers();
  }
})();
</script>
<style>
  /* Print only the standalone print area */
  @media print{
    body *{ visibility:hidden !important; }
    #druck-standalone, #druck-standalone *{ visibility:visible !important; }
    #druck-standalone{ position:absolute; left:0; top:0; width:100%; margin:0; }
  }
  #druck-standalone{
    margin: 28px auto;
    max-width: 1600px;
    padding: 8px 12px;
    background: #fafafa;
    border: 1px solid #e1e1e1;
    border-radius: 8px;
  }
  #druck-standalone .spacer{ height: 8px; }
  /* Hide the old anchor immediately to avoid layout shift flash */
  #druck100-anchor{ display:none !important; }
</style>
<script>
(function(){
  function safeRemove(node){
    if(!node) return;
    try{ node.remove(); }catch(e){ if(node.parentNode) node.parentNode.removeChild(node); }
  }
  function killDiagnostics(){
    var ids=['rb-diag-panel','rb-diag','rbdiag2','rb-mini','rbdiag','rbdiag-panel'];
    ids.forEach(id=>safeRemove(document.getElementById(id)));
    document.querySelectorAll('[aria-label*="Diagnose"],[aria-label*="diagnose"]').forEach(safeRemove);
    document.querySelectorAll('.diagnose,.diag,.rb-diag').forEach(safeRemove);
    // remove diag scripts
    document.querySelectorAll('script').forEach(s=>{
      var t=s.textContent||'';
      if(/Diagnose|RB DIAG|Abschluss PNG\/SVG|rb-diag/i.test(t)) safeRemove(s);
    });
  }
  function killAnchor(){
    safeRemove(document.getElementById('druck100-anchor'));
    // Also remove any label/button remnants
    document.querySelectorAll('strong,button,a').forEach(el=>{
      var txt=(el.textContent||'').trim().toLowerCase();
      if(txt==='druckbereich:' || txt==='zum druckbereich') safeRemove(el.closest('#druck100-anchor')||el);
    });
  }
  function ensureStandalone(){
    var host=document.getElementById('druck-standalone');
    if(!host){
      host=document.createElement('section');
      host.id='druck-standalone';
      host.setAttribute('aria-label','Druckbereich (standalone)');
      document.body.appendChild(host);
    }
    return host;
  }
  function moveToStandalone(){
    var host=ensureStandalone();
    var moved = 0;

    // 1) Move the MODE TOOLBAR (blue marked)
    var toolbar = document.getElementById('asset-mode-toolbar');
    if (toolbar && !host.contains(toolbar)){
      host.appendChild(toolbar); moved++;
    }
    var mini = document.getElementById('asset-mode-mini');
    if (mini && !host.contains(mini)){
      host.appendChild(mini); moved++;
    }
    // spacer between toolbar and panel
    var sp=document.createElement('div'); sp.className='spacer'; host.appendChild(sp);

    // 2) Move the PRINT PANEL
    var panel = document.getElementById('druck100-panel');
    if (panel && !host.contains(panel)){
      host.appendChild(panel); moved++;
    }

    // 3) Move associated modal/backdrop if they exist
    var extras = [];
    var backdrop = document.querySelector('.order-modal-backdrop');
    if (backdrop) extras.push(backdrop);
    var orderModal = document.getElementById('order-modal');
    if (orderModal) extras.push(orderModal);
    extras.forEach(el=>{ if(el && !host.contains(el)) host.appendChild(el); });

    window.__DEBUG__ && console.info('[Move] moved elements:', moved, 'into #druck-standalone');
  }
  function start(){
    killDiagnostics();
    killAnchor();
    moveToStandalone();
    // short observer for late injections
    var stopAt=Date.now()+4000;
    var mo=new MutationObserver(()=>{
      killDiagnostics(); killAnchor();
      var tb=document.getElementById('asset-mode-toolbar');
      var st=document.getElementById('druck-standalone');
      if(tb && tb.parentNode!==st) moveToStandalone();
      if(Date.now()>stopAt){ try{ mo.disconnect(); }catch(e){} }
    });
    mo.observe(document.documentElement,{subtree:true,childList:true});
    setTimeout(()=>{ try{ mo.disconnect(); }catch(e){} }, 4500);
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', start, {once:true}); }
  else start();
})();
</script>
<style>
  /* ---- Druck: nur Karten + Kundendaten, A4 hochkant, Ein-Seiten-Zwang ---- */
  @media print {
    @page { size: A4 portrait; margin: 10mm; }
    body * { display: none !important; }
    #druck-print-wrap, #druck-print-wrap * { display: initial !important; visibility: visible !important; }
    #druck-print-wrap { break-inside: avoid; page-break-inside: avoid; }
  }
  /* Skalierung im Screen-Modus */
  #druck100-panel.scale-100 { transform: scale(1); transform-origin: top left; }
  #druck100-panel.scale-150 { transform: scale(1.5); transform-origin: top left; margin-bottom: 40px; }

  /* UI: kleine Steuerleiste im Druckbereich */
  #druck-scale-controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:6px 0; }
  #druck-scale-controls .btn{ padding:4px 10px; border:1px solid #666; border-radius:6px; background:#fff; cursor:pointer; }
  #druck-scale-badge{ padding:2px 8px; border:1px solid #bbb; border-radius:999px; background:#eee; }

  /* Kundendaten direkt unter den Karten */
  
  #druck-kundendaten h3{ margin:0 0 8px; font-size:18px; }
  #druck-kundendaten .grid{ display:grid; grid-template-columns:repeat(2, minmax(260px,1fr)); gap:10px; }
  #druck-kundendaten textarea{ grid-column:1/-1; min-height:80px; }
  #druck-kundendaten input, #druck-kundendaten textarea{ padding:6px 8px; border:1px solid #bbb; border-radius:6px; width:100%; box-sizing:border-box; }
  #druck-kd-actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
  #druck-kd-actions .btn{ padding:6px 12px; border:1px solid #888; border-radius:6px; background:#fff; cursor:pointer; }
</style>
<script>
(function(){
  /* === Hilfsfunktionen === */
  const $ = (sel,root)=> (root||document).querySelector(sel);
  const $id = id => document.getElementById(id);

  /* === 1) Mini-Panel (#asset-mini) STABIL direkt unter die Moduszeile über dem Druckbereich setzen === */
  function looksMode(el){
    if(!el) return false;
    const t = (el.textContent||'').toLowerCase();
    return t.includes('modus') && t.includes('png') && t.includes('svg');
  }
  function findModeHeader(panel){
    if(!panel) return null;
    let p = panel.previousElementSibling;
    for(let i=0;i<8 && p;i++,p=p.previousElementSibling){
      if(looksMode(p)) return p;
      if(p.querySelector){
        const hit = [...p.querySelectorAll('*')].find(looksMode);
        if(hit) return hit.closest(':scope > *') || p;
      }
    }
    // fallback im selben Parent
    const sibs = panel.parentElement ? [...panel.parentElement.children] : [];
    const idx = sibs.indexOf(panel);
    for(let i=idx-1; i>=0; i--){
      const el = sibs[i];
      if(looksMode(el)) return el;
      const hit = el.querySelector && [...el.querySelectorAll('*')].find(looksMode);
      if(hit) return hit.closest(':scope > *') || el;
    }
    return null;
  }
  function placeMini(){
    const mini = $id('asset-mini');
    const panel= $id('druck100-panel');
    if(!mini || !panel) return;
    const header = findModeHeader(panel);
    if(header && header.parentNode){
      header.insertAdjacentElement('afterend', mini);
      mini.style.marginTop = '6px';
    }
  }

  /* === 2) 100% / 150% in den Druckbereich einsetzen === */
  function ensureScaleControls(){
    const panel = $id('druck100-panel'); if(!panel) return;
    if($id('druck-scale-controls')) return;
    // Header-Host (erste Zeile im Panel)
    const host = panel.querySelector('div,section,header') || panel;
    const ctrl = document.createElement('div');
    ctrl.id = 'druck-scale-controls';
    ctrl.innerHTML = '<span id="druck-scale-badge">100%</span> ' +
      '<button class="btn" id="druck-btn-100">100%</button>' +
      '<button class="btn" id="druck-btn-150">150%</button>' +
      '<button class="btn" id="druck-btn-save">Druckdatei speichern</button>';
    host.insertBefore(ctrl, host.firstChild);
  }
  function setScale(val){
    const panel = $id('druck100-panel'); if(!panel) return;
    panel.classList.toggle('scale-100', val===100);
    panel.classList.toggle('scale-150', val===150);
    const b = $id('druck-scale-badge'); if(b) b.textContent = (val===150?'150%':'100%');
    try{ localStorage.setItem('druckScale', String(val)); }catch(_){}
    window.__DRUCKSCALE__ = val;
  }
  
  function initScale(){
    // Druckbereich startet immer bei 100 %, unabhängig von Editor/Abschluss
    setScale(100);
  }

  /* === 3) Kundendaten unter Karten einfügen (falls nicht vorhanden) === */
  function ensureCustomerForm(){
    const panel = $id('druck100-panel'); if(!panel) return;
    if($id('druck-kundendaten')) return;
    const sec = document.createElement('section');
    sec.id = 'druck-kundendaten';
    sec.innerHTML = [
      '<div id="druck-kd-actions">',
      '  <label>Speichername (optional): <input id="kd-filename" type="text" placeholder="Pflanzenname"></label>',
      '</div>',
      '<h3>Kundendaten</h3>',
      '<form id="druck-kd-form" class="grid">',
      '  <input id="kd-name"     type="text" placeholder="Kund*in – Name">',
      '  <input id="kd-auftrag"  type="text" placeholder="Auftrags-/Bestellnummer">',
      '  <input id="kd-kontakt"  type="text" placeholder="Kontakt (E-Mail/Telefon)">',
      '  <input id="kd-adresse"  type="text" placeholder="Adresse">',
      '  <textarea id="kd-hinweise" placeholder="Hinweise (optional)"></textarea>',
      '</form>'
    ].join('');
    panel.parentNode.insertBefore(sec, panel.nextSibling);
  }
  function getData(){
    return {
      name: $('#kd-name')?.value||'',
      auftrag: $('#kd-auftrag')?.value||'',
      kontakt: $('#kd-kontakt')?.value||'',
      adresse: $('#kd-adresse')?.value||'',
      hinweise: $('#kd-hinweise')?.value||'',
      scale: (typeof window.__DRUCKSCALE__==='number'? window.__DRUCKSCALE__: 100)
    };
  }
  function setData(d){
    if(!d) return;
    if($('#kd-name'))     $('#kd-name').value = d.name||'';
    if($('#kd-auftrag'))  $('#kd-auftrag').value = d.auftrag||'';
    if($('#kd-kontakt'))  $('#kd-kontakt').value = d.kontakt||'';
    if($('#kd-adresse'))  $('#kd-adresse').value = d.adresse||'';
    if($('#kd-hinweise')) $('#kd-hinweise').value = d.hinweise||'';
    if(typeof d.scale==='number') setScale(d.scale);
  }
  function saveLS(){ try{ localStorage.setItem('druckKunde', JSON.stringify(getData())); }catch(_){ } }
  function loadLS(){ try{ const r = localStorage.getItem('druckKunde'); if(r) setData(JSON.parse(r)); }catch(_){ } }

  /* === 4) Speichern: eine HTML mit eingebetteten Daten === */
  function guessPlantName(){
    const panel = $id('druck100-panel'); if(!panel) return '';
    const cand = panel.querySelector('h1,h2,h3,.title,.kartentitel,.kartenname,[data-plant],strong,b');
    return cand && cand.textContent ? cand.textContent.trim() : '';
  }
  function buildFilename(){
    let base = "fertige Karten für Druck";
    const plant = ($('#kd-filename')?.value.trim() || guessPlantName());
    if(plant) base += " - " + plant;
    return base.replace(/[\\/:*?"<>|]+/g, "_") + ".html";
  }
  
  function saveFile(){
    try{
      const panel = document.getElementById('druck100-panel');
      if (!panel){
        alert('Druckbereich nicht gefunden.');
        return;
      }
      // Neues, minimales Dokument für die Druckdatei erzeugen
      const doc = document.implementation.createHTMLDocument('Druckdatei');
      const head = doc.head || doc.getElementsByTagName('head')[0];
      const body = doc.body || doc.getElementsByTagName('body')[0];

      // Relevante Styles für den Druckbereich übernehmen
      const cssIds = ['druck100-css'];
      cssIds.forEach(id=>{
        const el = document.getElementById(id);
        if (el){
          head.appendChild(el.cloneNode(true));
        }
      });

      // Druckbereich selbst übernehmen
      const clone = panel.cloneNode(true);
      body.appendChild(clone);

      const htmlOut = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
      const blob = new Blob([htmlOut], {type:'text/html'});
      const url  = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = (typeof buildFilename === 'function' ? buildFilename() : 'druckdatei.html');
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 200);
    }catch(e){
      console.error(e);
      alert('Fehler beim Erzeugen der Druckdatei: ' + (e && e.message ? e.message : e));
    }
  }

  /* === 5) Nur Karten + Kundendaten drucken & One-Page-Fit === */
  function mmToPx(mm){ return mm * (96/25.4); }
  function ensurePrintWrap(){
    const panel = $id('druck100-panel'); if(!panel) return null;
    let wrap = $id('druck-print-wrap');
    const kd = $id('druck-kundendaten');
    if(!wrap){
      wrap = document.createElement('div');
      wrap.id = 'druck-print-wrap';
      panel.parentNode.insertBefore(wrap, panel);
    }
    if(panel.parentNode !== wrap) wrap.appendChild(panel);
    if(kd && kd.parentNode !== wrap) wrap.appendChild(kd);
    return wrap;
  }
  function fitOnePage(){
    const wrap = ensurePrintWrap(); if(!wrap) return;
    wrap.style.transformOrigin = 'top left';
    // Keine automatische Verkleinerung mehr: immer 1:1 drucken
    wrap.style.transform = 'scale(1)';
  }
  function hookPrint(){
    const printBtn = $id('druck-btn-print');
    if(printBtn){
      printBtn.addEventListener('click', e=>{
        e.preventDefault();
        fitOnePage();
        setTimeout(()=>window.print(), 50);
      });
    }
    window.addEventListener('beforeprint', fitOnePage);
    window.addEventListener('afterprint', ()=>{
      const wrap = $id('druck-print-wrap');
      if(wrap){ wrap.style.transform=''; }
    });
  }

  /* === 6) Event-Bindings & kleiner Wächter gegen Re-Renders === */
  function bind(){
    ensureScaleControls();
    ensureCustomerForm();
    placeMini();
    loadLS();
    if(window.__DRUCKKUNDENDATEN__) setData(window.__DRUCKKUNDENDATEN__);
    initScale();
    $('#druck-kd-form')?.addEventListener('input', saveLS);
    $('#druck-btn-100')?.addEventListener('click', e=>{e.preventDefault(); setScale(100);});
    $('#druck-btn-150')?.addEventListener('click', e=>{e.preventDefault(); setScale(150);});
    $('#druck-btn-save')?.addEventListener('click', e=>{e.preventDefault(); exportDruckdatei();});
    hookPrint();

    // 3s kurzer Wächter, falls DOM später noch einmal umbaut
    const until = Date.now()+3000;
    const mo = new MutationObserver(()=>{
      placeMini();
      if(Date.now()>until){ try{mo.disconnect();}catch(e){} }
    });
    mo.observe(document.documentElement, {subtree:true, childList:true});
    setTimeout(()=>{ try{mo.disconnect();}catch(e){} }, 3200);
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bind, {once:true});
  else bind();
})();
</script>
<!-- EXPORT EINZELDOKUMENT FORCECOPY -->
<script id="export-einzeldokument-forcecopy">
(function(){
  // === Build base (unzoomed) font-size overrides for back fields and force --zoom:1 in export ===
  function __rb_injectZoomSafeBackText(html){
    try{
      var zVal = getComputedStyle(document.documentElement).getPropertyValue('--zoom') || '1';
      var Z = parseFloat(zVal) || 1;
      var ids = ['feld17','feld18','feld19','feld20','feld21','feld22','feld23','feld24','feld25'];
      var rules = [':root{ --zoom: 1 !important; }']; // prevent double-scaling in exported file
      ids.forEach(function(id){
        var el = document.getElementById(id);
        if(!el) return;
        var cs = getComputedStyle(el);
        var fsPx = parseFloat(cs.fontSize)||0;  // includes editor zoom
        var basePx = Z > 0 ? (fsPx / Z) : fsPx; // unzoomed px
        if(basePx>0){
          // bake base size; the viewer's transform (100/150) will scale uniformly
          rules.push('#'+id+'{ font-size:'+basePx.toFixed(2)+'px !important; }');
        }
      });
      var block = '<style id="rb-zoomsafe-backtext">\n' + rules.join('\n') + '\n</style>';
      html = html.replace('</head>', block + '</head>');
    }catch(e){/* no-op */}
    return html;
  }

  // === Measure effective scale (transforms + CSS zoom) up the DOM tree ===
  function __rb_effectiveScale(el){
    var s = 1;
    for (var n = el; n && n !== document; n = n.parentElement){
      var cs = getComputedStyle(n);
      // CSS transform
      try{
        var tf = cs.transform;
        if (tf && tf !== 'none'){
          var m = tf.match(/matrix\(([^)]+)\)/);
          if (m){
            var p = m[1].split(',').map(parseFloat);
            var a = p[0], b = p[1];
            var sc = Math.sqrt(a*a + b*b);
            if (sc && isFinite(sc)) s *= sc;
          }
        }
      }catch(_){}
      // CSS zoom (legacy but used in some UIs)
      var z = parseFloat(cs.zoom);
      if (z && isFinite(z)) s *= z;
    }
    return s;
  }

  // === Build override CSS for back fields based on *effective* size & weight ===
  function __rb_buildBackTextOverrides(){
    var ids = ['feld17','feld18','feld19','feld20','feld21','feld22','feld23','feld24','feld25'];
    var rules = [];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if(!el) return;
      var cs = getComputedStyle(el);
      var basePx = parseFloat(cs.fontSize) || 0;
      var w = cs.fontWeight || '700';
      var scale = __rb_effectiveScale(el);
      var effPx = basePx * (scale || 1);
      if (effPx > 0){
        rules.push('#'+id+'{ font-size:'+effPx.toFixed(2)+'px !important; font-weight:'+w+' !important; }');
      }
    });
    if(!rules.length) return '';
    return '<style id="rb-backtext-override">\n' + rules.join('\n') + '\n</style>';
  }

  // === Inject into exported head; also normalize --zoom to 1 and avoid faux bold ===
  function __rb_applyBackTextOverrides(html){
    try{
      var block = __rb_buildBackTextOverrides();
      if(block){
        // Ensure we don't double-scale in the standalone
        html = html.replace(/--zoom:\s*[^;]+;/, '--zoom: 1;');
        // Avoid faux-bold differences
        if (!/id="rb-font-thickness-fix"/.test(html)){
          html = html.replace('</head>', '<style id="rb-font-thickness-fix">:root{font-synthesis:none}</style></head>');
        }
        html = html.replace('</head>', block + '</head>');
      }
    }catch(e){/* no-op */}
    return html;
  }

  function $id(id){ return document.getElementById(id); }
  function q(s,r){ return (r||document).querySelector(s); }
  function qa(s,r){ return Array.from((r||document).querySelectorAll(s)); }
  function normFilename(s){ return String(s||'ohne Namen').replace(/[\\\/:*?"<>|]+/g,'-').replace(/\s+/g,' ').trim(); }

  function toDataURL(img){
    return new Promise(function(resolve){
      var c = document.createElement('canvas'), ctx = c.getContext('2d');
      var w = img.naturalWidth || img.width, h = img.naturalHeight || img.height;
      if(!w || !h){ resolve(null); return; }
      c.width=w; c.height=h;
      try{ ctx.drawImage(img,0,0); resolve(c.toDataURL('image/png')); }catch(e){ resolve(null); }
    });
  }
  async function inlineImages(root){
    var imgs = root.querySelectorAll('img');
    for (var i=0;i<imgs.length;i++){
      var im = imgs[i];
      if(/^data:/.test(im.src)) continue;
      if(!im.complete){
        await new Promise(r=>{ im.addEventListener('load', r, {once:true}); im.addEventListener('error', r, {once:true}); });
      }
      var data = await toDataURL(im);
      if(data) im.setAttribute('src', data);
    }
    return root;
  }
  function stripEditorBits(root){
    qa('.rahmen-overlay,.editor-rahmen,.bearbeitungs-rahmen,[data-editor-only],[data-role="editor-only"]', root).forEach(function(x){ x.remove(); });
    return root;
  }

  function buildPrintHTML(frontHTML, backHTML, plantName){
    var title = 'fertige Karten für Druck – ' + normFilename(plantName||'');
    var tpl = `<!DOCTYPE html>
<html lang="de"><head>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&display=swap" rel="stylesheet">

<meta charset="utf-8"><title>${title}</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
:root{ --gap:15mm; --card-w:54mm; --card-h:85mm; --zoom:1; font-family: 'Playfair Display', serif; font-kerning: normal; font-synthesis: none; }
body{ margin:0; background:#fff; }
#panel{ max-width:980px; margin:16px auto; padding:12px; background:#f6f6f6; border:1px solid #ddd; border-radius:10px; }
#controls{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
#controls .btn{ padding:6px 12px; border:1px solid #333; border-radius:8px; background:#fff; cursor:pointer; }
#badge{ padding:2px 8px; border:1px solid #bbb; border-radius:999px; background:#eee; font-size:12px; }
#wrap{ display:block; margin-top:8px; }
#stage{ display:flex; gap:var(--gap); align-items:flex-start; isolation:isolate; transform-origin: top left; font-family: 'Playfair Display', serif; }
.druck-card{ position:relative; width:var(--card-w); height:var(--card-h); background:#fff; outline:0.2mm dashed rgba(0,0,0,.25); box-sizing:border-box; }
.druck-card .wrap{ position:relative; width:100%; height:100%; overflow:hidden; }
#kundendaten{ margin:16px auto 8px; padding:12px 14px; border:1px solid #ddd; border-radius:10px; background:#fcfcfc; width: calc(2 * var(--card-w) + var(--gap)); max-width:100%; box-sizing:border-box; }
#kundendaten h3{ margin:0 0 8px; font-size:16px; }
#kd-form{ display:grid; grid-template-columns:repeat(2, minmax(260px,1fr)); gap:10px; }
#kd-form textarea{ grid-column:1/-1; min-height:80px; }
#kd-form input, #kd-form textarea{ padding:8px; border:1px solid #bbb; border-radius:6px; width:100%; box-sizing:border-box; }
@media print {
  @page { size: A4 portrait; margin: 10mm; }
  body *{ visibility:hidden !important; }
  #print, #print *{ visibility:visible !important; }
  #print{ break-inside:avoid; page-break-inside:avoid; }
}

/* Anpassung öffentlicher Konfigurator: Inhalte in der Druckkarte einpassen */
.druck-card .wrap{
  display:block;
  background-size: contain;
  background-position: center center;
  background-repeat: no-repeat;
}
.druck-card .wrap img{
  max-width:100%;
  max-height:100%;
  object-fit:contain;
}
</style>
<!-- BEGIN: abschluss-zoom-isolation (A: Abschluss startet 100% und ist vom Editor-Zoom entkoppelt) -->
<style id="abschluss-zoom-isolation">
  /* Abschluss vom globalen --zoom entkoppeln */
  #abschluss-stage {
    --zoom: 1 !important;
  }
  /* alte Wrap-Skalierung im Abschluss neutralisieren (verhindert Double-Scale) */
  #abschluss-stage .wrap {
    transform: none !important;
    transform-origin: top left !important;
  }
  /* Skalier-Pivot für den Rahmen (wir skalieren den Frame, nicht die Wrap) */
  #abschluss-card-frame {
    transform-origin: top center !important;
  }
  /* Lokale Zoomlogik: 100% = keine Transform, 150% = Frame skalieren */
  #abschluss-stage.zoom-100 #abschluss-card-frame { transform: none !important; }
  #abschluss-stage.zoom-150 #abschluss-card-frame { transform: scale(1.5) !important; }
</style>
<!-- END: abschluss-zoom-isolation -->
</head>
<body>
<section id="panel" aria-label="Druck">
  <div id="controls">
    <span id="badge">100%</span>
    <button class="btn" id="btn100" type="button">100%</button>
    <button class="btn" id="btn150" type="button">150%</button>
    <button class="btn" id="btnPrint" type="button">Drucken</button>
  </div>
  <div id="print">
    <div id="wrap"><div id="stage">
      <div class="druck-card"><div class="wrap" id="front"></div></div>
      <div class="druck-card"><div class="wrap" id="back"></div></div>
    </div></div>
    <section id="kundendaten">
      <label>Speichername (optional): <input id="kd-filename" type="text" placeholder="Pflanzenname" value="${(plantName||'').replace(/\"/g,'&quot;')}"></label>
      <h3>Kundendaten</h3>
      <form id="kd-form">
        <input id="kd-name" type="text" placeholder="Kund*in – Name">
        <input id="kd-auftrag" type="text" placeholder="Auftrags-/Bestellnummer">
        <input id="kd-kontakt" type="text" placeholder="Kontakt (E-Mail/Telefon)">
        <input id="kd-adresse" type="text" placeholder="Adresse">
        <textarea id="kd-hinweise" placeholder="Hinweise (optional)"></textarea>
      </form>
    </section>
  </div>
</section>
<script>(function(){
  function $id(id){ return document.getElementById(id); }
  function measure(el){ var p=el.style.transform; el.style.transform='none'; var r=el.getBoundingClientRect(); el.style.transform=p; return {w:r.width,h:r.height}; }
  function applyScale(scale){
    var stage=$id('stage'); var wrap=$id('wrap'); if(!stage||!wrap) return;
    var m=measure(stage); stage.style.transform='scale('+scale+')';
    wrap.style.width=(m.w*scale)+'px'; wrap.style.height=(m.h*scale)+'px'; // global --zoom removed: Druckzoom ist jetzt komplett entkoppelt

    $id('badge').textContent=(scale>1?'150%':'100%');
    try{ localStorage.setItem('druckScale', (scale>1?150:100)); }catch(_){}
  }
  function initScale(){ var s=100; try{ s=parseInt(localStorage.getItem('druckScale')||'100',10);}catch(_){}
    applyScale(s===150?1.5:1); }
  (function(){
    var form=$id('kd-form'); if(!form) return;
    form.addEventListener('submit', function(e){ e.preventDefault(); e.stopPropagation(); });
    form.addEventListener('keydown', function(e){ if(e.key==='Enter'||e.key==='Escape'||(e.ctrlKey&&(e.key==='s'||e.key==='S'))) e.stopPropagation(); }, true);
    Array.prototype.forEach.call(form.querySelectorAll('input,textarea'), function(inp){
      inp.addEventListener('keydown', function(e){ if(e.key==='Enter'||e.key==='Escape'||(e.ctrlKey&&(e.key==='s'||e.key==='S'))) e.stopPropagation(); }, true);
    });
  })();
  $id('btn100').addEventListener('click', function(e){ e.preventDefault(); applyScale(1); });
  $id('btn150').addEventListener('click', function(e){ e.preventDefault(); applyScale(1.5); });
  $id('btnPrint').addEventListener('click', function(e){ e.preventDefault(); setTimeout(function(){ window.print(); }, 30); });
  $id('front').innerHTML = FRONT_HTML;
  $id('back').innerHTML  = BACK_HTML;
  initScale();
})();<\/script>

<!-- BEGIN: abschluss-zoom-default-100 (A) -->
<script id="abschluss-zoom-default-100">
  (function(){
    function initAbschluss100(){
      var stage = document.getElementById('abschluss-stage');
      if(!stage) return;
      try{
        // Abschluss immer mit Basiszoom 1 starten
        stage.style.setProperty('--zoom', '1');
        stage.classList.remove('zoom-150');
        stage.classList.add('zoom-100');
        // Sicherstellen, dass der Frame bei 100% keinen residualen Transform hat
        var frame = document.getElementById('abschluss-card-frame');
        if (frame) {
          frame.style.transformOrigin = 'top center';
          // 100% = keine transform:
          frame.style.transform = 'none';
        }
        // Doppelskalierung via .wrap verhindern (falls andere Scripts erneut setzen)
        var wraps = stage.querySelectorAll('.wrap');
        wraps.forEach(function(w){
          w.style.transform = 'none';
          w.style.transformOrigin = 'top left';
        });
      }catch(e){ try{ console.warn('[Abschluss 100% init]', e); }catch(_){ } }
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initAbschluss100);
    } else {
      initAbschluss100();
    }
  })();
<\/script>
<!-- END: abschluss-zoom-default-100 -->
</body></html>`;
    return tpl;
  }

  function pickLargest(cands){
    var best=null, bestArea=0;
    cands.forEach(function(el){
      var r = el.getBoundingClientRect();
      var a = Math.max(0,r.width) * Math.max(0,r.height);
      if(a>bestArea){ bestArea=a; best=el; }
    });
    return best;
  }

  async function getFrontBackEnsured(){
    // First attempt: Druckbereich wraps
    var stage = $id('druck100-stage');
    var wraps = stage ? stage.querySelectorAll('.druck-card .wrap') : [];
    if(wraps && wraps.length>=2 && (wraps[0].children.length || wraps[1].children.length)){
      return [wraps[0], wraps[1]];
    }
    // Force "Für Druck übernehmen" when available
    var copyBtn = $id('ead-copy-print');
    if(copyBtn){
      copyBtn.click();
      await new Promise(r=>setTimeout(r, 120));
      stage = $id('druck100-stage');
      wraps = stage ? stage.querySelectorAll('.druck-card .wrap') : [];
      if(wraps && wraps.length>=2 && (wraps[0].children.length || wraps[1].children.length)){
        return [wraps[0], wraps[1]];
      }
    }
    // Fallback: Abschluss – pick largest descendants for front/back
    var frontCands = qa('#abschluss-front, [id*=\"front\" i], [class*=\"front\" i]');
    var backCands  = qa('#abschluss-back,  [id*=\"back\"  i], [class*=\"back\"  i]');
    var af = pickLargest(frontCands);
    var ab = pickLargest(backCands);
    if(af && ab) return [af, ab];
    return null;
  }

  async function exportDruckdatei(){
    var pair = await getFrontBackEnsured();
    if(!pair){ alert('Kein Karteninhalt gefunden. Bitte Abschluss zeigen oder „Für Druck übernehmen“.'); return; }

    var front = pair[0].cloneNode(true);
    var back  = pair[1].cloneNode(true);
    stripEditorBits(front); stripEditorBits(back);
    await inlineImages(front); await inlineImages(back);

    var plantName = ($id('kd-filename') && $id('kd-filename').value) || (q('[data-plant-name]') ? q('[data-plant-name]').textContent : '');
    var html = buildPrintHTML(front.innerHTML, back.innerHTML, plantName);
    html = __rb_injectZoomSafeBackText(html);
    html = __rb_applyBackTextOverrides(html);
    html = html.replace('FRONT_HTML', JSON.stringify(front.innerHTML)).replace('BACK_HTML', JSON.stringify(back.innerHTML));

    var blob = new Blob([html], {type:'text/html'});
    var a = document.createElement('a'); a.href = URL.createObjectURL(blob);
    a.download = 'fertige Karten für Druck – ' + normFilename(plantName) + '.html';
    document.body.appendChild(a); a.click(); setTimeout(function(){ URL.revokeObjectURL(a.href); a.remove(); }, 600);
  }

  function mountButton(){
    var host = $id('druck100-controls') || $id('druck100-panel');
    if(!host) return;
    var btn = $id('druck-btn-save');
    if(!btn){
      btn = document.createElement('button');
      btn.id='druck-btn-save'; btn.type='button'; btn.className='btn';
      btn.textContent='Druckdatei speichern';
      host.appendChild(btn);
    }
    var fresh = btn.cloneNode(true);
    btn.replaceWith(fresh);
    fresh.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); exportDruckdatei(); }, false);
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', mountButton, {once:true});
  else mountButton();
})();
</script>
<script id="feld7-dnd-wiring-v2">
(function(){
  try{
    var menu = document.getElementById('feld7-menu');
    if (menu){
      menu.querySelectorAll('.feld7-item').forEach(function(li){
        // Make li and inner img draggable
        if (!li.getAttribute('draggable')) li.setAttribute('draggable','true');
        var img = li.querySelector('img');
        if (img && !img.getAttribute('draggable')) img.setAttribute('draggable','true');
        var start = function(ev){
          try{
            var src = (img && img.getAttribute('src')) || li.getAttribute('data-img') || li.getAttribute('data-altimg');
            var val = li.getAttribute('data-value') || '';
            if (src){
              var html = '<img alt="'+(val||'symbol')+'" src="'+src+'" style="max-width:100%; max-height:100%;">';
              ev.dataTransfer.setData('text/html', html);
              ev.dataTransfer.setData('text/plain', html);
              ev.dataTransfer.effectAllowed = 'copyMove';
            }
          }catch(_){}
        };
        li.addEventListener('dragstart', start);
        if (img) img.addEventListener('dragstart', start);
      });
    }
  }catch(_){}
})();
</script>
<script id="feld7-dnd-fixpayload">
(function(){
  try{
    var menu = document.getElementById('feld7-menu');
    if (!menu) return;
    function bind(){
      menu.querySelectorAll('.feld7-item').forEach(function(li){
        var img = li.querySelector('img');
        var url = (img && img.getAttribute('src')) || li.getAttribute('data-img') || li.getAttribute('data-altimg') || '';
        if (!url) return;
        // ensure draggable
        if (!li.getAttribute('draggable')) li.setAttribute('draggable','true');
        if (img && !img.getAttribute('draggable')) img.setAttribute('draggable','true');
        var start = function(ev){
          try{
            // IMPORTANT: send ONLY the URL as text/plain
            ev.dataTransfer.setData('text/plain', url);
            ev.dataTransfer.effectAllowed = 'copy';
          }catch(_){}
        };
        if (!li.__f7FixBound){ li.addEventListener('dragstart', start); li.__f7FixBound = true; }
        if (img && !img.__f7FixBound){ img.addEventListener('dragstart', start); img.__f7FixBound = true; }
      });
    }
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bind, {once:true});
    } else {
      bind();
    }
    new MutationObserver(bind).observe(menu, {childList:true, subtree:true});
  }catch(_){}
})();
</script>
<script id="feld7-trash-fallback">
(function(){
  var bin = document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
  if (!bin || bin.__f7Fallback) return;
  bin.addEventListener('drop', function(ev){
    try{
      var id = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
      if (id === 'feld7'){
        var slot = document.getElementById('feld7');
        if (slot){
          var img = slot.querySelector('img');
          if (img) img.remove();
          try{ delete slot.dataset.rbOriginSticker; }catch(_){}
          ev.preventDefault();
          ev.stopImmediatePropagation();
        }
      }
    }catch(_){}
  }, true);
  bin.__f7Fallback = true;
})();
</script>
<script id="feld7-hand-cursor">
(function(){
  var menu = document.getElementById('feld7-menu');
  var f7   = document.getElementById('feld7');
  function setGrab(el){ try{ el.style.cursor='grab'; }catch(_){ } }
  function setGrabbing(el){ try{ el.style.cursor='grabbing'; }catch(_){ } }

  if(menu){
    // initial cursor on icons
    menu.querySelectorAll('.feld7-item img').forEach(setGrab);
    // switch on drag start/end
    menu.addEventListener('dragstart', function(e){
      var t = e.target && (e.target.tagName==='IMG' ? e.target : (e.target.querySelector ? e.target.querySelector('img') : null));
      if(t) setGrabbing(t);
    }, true);
    menu.addEventListener('dragend', function(e){
      var t = e.target && (e.target.tagName==='IMG' ? e.target : (e.target.querySelector ? e.target.querySelector('img') : null));
      if(t) setGrab(t);
    }, true);
  }

  if(f7){
    setGrab(f7);
    f7.addEventListener('dragenter', function(){ setGrabbing(f7); }, true);
    f7.addEventListener('dragleave', function(){ setGrab(f7); }, true);
    f7.addEventListener('drop',      function(){ setGrab(f7); }, true);
  }
})();
</script>
<script id="auswahl-stop-react">
(function(){
  var root = document.getElementById('rb-boxes') || document.querySelector('#rb-boxes, .rb-boxes');
  if (!root || root.__auswahlStopReact) return;

  function isAuswahlRectTarget(t){
    return !!(t && t.closest && t.closest('.rb-box-rect.is-auswahl'));
  }
  function clearHighlight(t){
    var el = t && t.closest && t.closest('.rb-box-rect.is-auswahl');
    if (!el) return;
    el.classList.remove('drag-over','is-drop-target','rb-drop-target');
    // If there is a pseudo highlight via style attr, try to reset border style
    if (el.style && /dashed/.test(el.style.border || '')) el.style.borderStyle='solid';
  }

  // Capture phase: swallow drag events on Auswahl-Rects so their own handlers don't run
  ['dragenter','dragover','dragleave'].forEach(function(type){
    root.addEventListener(type, function(e){
      if (isAuswahlRectTarget(e.target)){
        try{ if (e.dataTransfer) e.dataTransfer.dropEffect = 'none'; }catch(_){}
        clearHighlight(e.target);
        e.stopPropagation(); // don't bubble to handlers that add dashed outlines
        // IMPORTANT: don't call preventDefault here -> element won't become a drop target
      }
    }, true);
  });

  root.addEventListener('drop', function(e){
    if (isAuswahlRectTarget(e.target)){
      clearHighlight(e.target);
      e.stopPropagation();
      e.preventDefault(); // ensure nothing processes a drop here
    }
  }, true);

  root.__auswahlStopReact = true;
})();
</script>
<script id="next-click-clears-card">
(function(){
  function bind(){
    var nextBtn = document.getElementById('btn-abschluss-next');
    var clearBtn = document.getElementById('btn-leeren');
    if(!nextBtn || !clearBtn || nextBtn.__nextClearBound) return;
    nextBtn.addEventListener('click', function(){
      try{ clearBtn.click(); }catch(_){}
    }, false); // bubble phase; does not interfere with drag/drop
    nextBtn.__nextClearBound = true;
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', bind, {once:true});
  }else{
    bind();
  }
})();
</script>
<script id="auswahl-rect-shield">
(function(){
  function bindOn(el){
    if (!el || el.__auswahlShield) return;
    var stopEnter = function(e){
      try{ if (e.dataTransfer) e.dataTransfer.dropEffect = 'none'; }catch(_){}
      // remove dashed highlight classes if any
      try{ el.classList.remove('drag-over','is-drop-target','rb-drop-target'); }catch(_){}
      e.stopPropagation(); // don't bubble to container logic
      // IMPORTANT: do NOT preventDefault here, so it won't become a drop target
    };
    var stopOver = function(e){
      try{ if (e.dataTransfer) e.dataTransfer.dropEffect = 'none'; }catch(_){}
      e.stopPropagation();
    };
    var stopLeave = function(e){
      try{ el.classList.remove('drag-over','is-drop-target','rb-drop-target'); }catch(_){}
      e.stopPropagation();
    };
    var stopDrop = function(e){
      try{ el.classList.remove('drag-over','is-drop-target','rb-drop-target'); }catch(_){}
      e.preventDefault();   // actively block a drop here
      e.stopPropagation();  // and don't let parent handlers run
    };
    el.addEventListener('dragenter', stopEnter, true);
    el.addEventListener('dragover',  stopOver,  true);
    el.addEventListener('dragleave', stopLeave, true);
    el.addEventListener('drop',      stopDrop,  true);
    el.__auswahlShield = true;
  }

  function scan(){
    var list = document.querySelectorAll('.rb-box-rect.is-auswahl');
    list.forEach(bindOn);
  }

  // Initial + dynamic
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', scan, {once:true});
  } else { scan(); }

  var rb = document.getElementById('rb-boxes') || document.querySelector('.rb-boxes') || document.body;
  new MutationObserver(function(){ scan(); }).observe(rb, {childList:true, subtree:true});
})();
</script>
<script id="auswahl-rect-only-shield">
(function(){
  // Finds exactly the Auswahl-Rect in the row with title "Zimmerpflanze"
  function findZimmerpflanzeAuswahl(){
    var boxes = document.getElementById('rb-boxes') || document.querySelector('#rb-boxes, .rb-boxes');
    if (!boxes) return null;
    var rows = boxes.querySelectorAll('.rb-row');
    for (var i=0;i<rows.length;i++){
      var row = rows[i];
      var titleEl = row.querySelector('.rb-box-titel');
      if (!titleEl) continue;
      var t = (titleEl.textContent || '').trim().toLowerCase();
      if (t === 'zimmerpflanze'){ // exact match
        var rect = row.querySelector('.rb-box-rect.selectable.is-auswahl');
        if (rect) return rect;
      }
    }
    return null;
  }

  function applyShield(rect){
    if (!rect || rect.__shielded) return;
    function stopEnter(e){
      try{ if (e.dataTransfer) e.dataTransfer.dropEffect = 'none'; }catch(_){}
      rect.classList.remove('drag-over','is-drop-target','rb-drop-target');
      e.stopPropagation();
    }
    function stopOver(e){
      try{ if (e.dataTransfer) e.dataTransfer.dropEffect = 'none'; }catch(_){}
      e.stopPropagation();
    }
    function stopLeave(e){
      rect.classList.remove('drag-over','is-drop-target','rb-drop-target');
      e.stopPropagation();
    }
    function stopDrop(e){
      rect.classList.remove('drag-over','is-drop-target','rb-drop-target');
      e.preventDefault();
      e.stopPropagation();
    }
    rect.addEventListener('dragenter', stopEnter, true);
    rect.addEventListener('dragover',  stopOver,  true);
    rect.addEventListener('dragleave', stopLeave, true);
    rect.addEventListener('drop',      stopDrop,  true);
    rect.__shielded = true;
  }

  function scanAndShield(){
    var rect = findZimmerpflanzeAuswahl();
    if (rect) applyShield(rect);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', scanAndShield, {once:true});
  } else {
    scanAndShield();
  }

  // If layout re-renders, re-apply
  var root = document.getElementById('rb-boxes') || document.body;
  new MutationObserver(function(){ scanAndShield(); }).observe(root, {childList:true, subtree:true});
})();
</script>
<!-- === rb-next-equals-clear-v2 (2025-11-11) === -->
<script id="rb-next-equals-clear-v2">
(function(){
  'use strict';

  // zentrale Clear-Funktion – gleiche Logik wie beim 'rb-clear-failsafe' Button
  function rbClearCard(){
    try{
      // 1) Felder 1..25 leeren (Sticker/Text)
      for (var i=1;i<=25;i++){
        var el = document.getElementById('feld'+i);
        if (el) el.innerHTML = '';
      }
      // Feld 1 Anzeige leeren
      var f1 = document.getElementById('feld1NameAnzeige'); if (f1) f1.textContent = '';

      // 2) Textkapseln mit data-slot neutralisieren
      try{
        document.querySelectorAll('.karte-overlay [data-slot]').forEach(function(n){ n.textContent=''; });
      }catch(_){}

      // 3) Spruch & Smiley zurücksetzen
      var spr = document.getElementById('spruchSelect');  if (spr)  spr.selectedIndex = 0;
      var smi = document.getElementById('smileySelect');  if (smi)  smi.selectedIndex = 0;
      var sprA = document.getElementById('spruchAnzeige'); if (sprA) sprA.textContent = '';
      var symA = document.getElementById('symbolAnzeige'); if (symA) symA.textContent = '';

      // 4) Zähler neutralisieren
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){}

      // 5) Rückseiten-Hinweis (slot-hint) + Raised-Klasse entfernen
      try{
        document.querySelectorAll('#karte-rueckseite .slot-hint').forEach(function(n){ n.remove(); });
        var fig = document.getElementById('karte-rueckseite'); if (fig) fig.classList.remove('hint-raise');
      }catch(_){}
    }catch(_){ /* silent */ }
  }
  window.rbClearCard = window.rbClearCard || rbClearCard;

  document.addEventListener('DOMContentLoaded', function(){
    var nextBtn = document.getElementById('btn-abschluss-next');
    if (!nextBtn || nextBtn.__rbNextEqBound) return;

    // Alle bestehenden Listener loswerden: Knoten klonen und ersetzen
    var clone = nextBtn.cloneNode(true);
    clone.id = nextBtn.id; // id beibehalten
    nextBtn.parentNode.replaceChild(clone, nextBtn);

    // Unser Handler: exakt wie "Karte leeren"
    clone.addEventListener('click', function(ev){
      try{
        if (ev){ ev.preventDefault(); ev.stopPropagation(); if (ev.stopImmediatePropagation) ev.stopImmediatePropagation(); }
      }catch(_){}
      try{ window.rbClearCard(); }catch(_){}
      return false;
    }, false);

    clone.__rbNextEqBound = true;
  });
})();
</script>
<!-- === rb-auswahl-dragonly (2025-11-11) === -->
<script id="rb-auswahl-dragonly">
(function(){
  'use strict';
  function blockDrop(el){
    if (!el || el.__rbNoDropBound) return;
    ['dragenter','dragover','drop'].forEach(function(ev){
      el.addEventListener(ev, function(e){
        try{ e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation(); }catch(_){}
        return false;
      }, true); // capture, um vor globalen Drop-Handlern zu greifen
    });
    // Sicherheit: HTML5 dropzone deaktivieren
    try{ el.setAttribute('dropzone',''); }catch(_){}
    el.__rbNoDropBound = true;
  }

  function apply(){
    document.querySelectorAll('.rb-box-rect.selectable').forEach(blockDrop);
  }

  // Initial nach DOM-Ladung
  document.addEventListener('DOMContentLoaded', apply);

  // Und falls Boxen dynamisch aufgebaut werden: beobachten
  var mo = new MutationObserver(function(muts){
    for (var i=0;i<muts.length;i++){
      var t = muts[i].target;
      if (!(t instanceof Element)) continue;
      if (t.matches && t.matches('.rb-box-rect.selectable')) blockDrop(t);
      if (t.querySelectorAll){
        t.querySelectorAll('.rb-box-rect.selectable').forEach(blockDrop);
      }
    }
  });
  try{ mo.observe(document.documentElement || document.body, {subtree:true, childList:true}); }catch(_){}
})();
</script>
<!-- Back-to-Editor – stabil, ohne Druckbereich zu verstecken -->
<script defer="" id="mount-back-button">
(function(){
  const $ = s => document.querySelector(s);

  // App-API für Rückweg (bevorzugt showEditor/zeigeEditor)
  const goBack = window.showEditor
               || window.zeigeEditor
               || (window.setAssetMode ? () => window.setAssetMode('editor') : null);

  // Nur den Abschluss ausblenden (Druckbereich bleibt!)
  function hideAbschlussOnly(){
    const abschluss = $('#abschluss-panel, #abschluss, [data-panel="abschluss"], #abschluss-standalone');
    if (abschluss) abschluss.style.display = 'none';
  }

  // Editor sichtbar & interaktiv erzwingen (falls Flags/Klassen bremsen)
  function unlockEditor(){
    const editor = $('.columns, #editor, #editor-panel, [data-panel="editor"]');
    if (!editor) return;
    editor.style.removeProperty('display');
    editor.hidden = false;
    editor.removeAttribute('hidden');
    editor.removeAttribute('inert');
    editor.style.pointerEvents = '';
    editor.querySelectorAll('[inert]').forEach(el => el.removeAttribute('inert'));
    editor.querySelectorAll('[disabled]').forEach(el => { try{ el.disabled = false; }catch(_){} });
    document.body.classList.remove('abschluss-mode','abschluss-active','print-mode','no-edit');
    if (document.body.dataset) document.body.dataset.mode = 'editor';
  }

  function scrollTop(){
    const toolbar = $('.steuerleiste, #toolbar, [data-role="toolbar"], [aria-label*="Steuerleiste"]')
                 || $('.columns, #editor, #editor-panel') || document.body;
    if (toolbar && toolbar.scrollIntoView) toolbar.scrollIntoView({behavior:'smooth', block:'start'});
    else window.scrollTo({top:0, behavior:'smooth'});
  }

  // Globaler Click-Handler (Capture) – überlebt Re-Renders
  function globalBackHandler(e){
    const btn = e.target.closest('#btn-abschluss-back, #btn-editor-back-clean, button');
    if (!btn) return;
    const txt = (btn.textContent || '').replace(/\s+/g,' ').trim().toLowerCase();
    if (!/zurück zur bearbeitung/.test(txt)) return; // nur „Zurück zur Bearbeitung“

    e.preventDefault(); e.stopPropagation();

    if (goBack) { try { goBack(); } catch(err){ console.error('showEditor/zeigeEditor Fehler:', err); } }
    hideAbschlussOnly();
    unlockEditor();
    // Zwei kurze Re-Enforcements gegen Observer
    setTimeout(()=>{ hideAbschlussOnly(); unlockEditor(); }, 50);
    setTimeout(()=>{ hideAbschlussOnly(); unlockEditor(); }, 150);
    scrollTop();
  }

  // Nur einmal registrieren
  if (!window.__back_handler_installed__) {
    document.addEventListener('click', globalBackHandler, true); // capture!
    window.__back_handler_installed__ = true;
  }

  // Falls dein Abschluss neu gerendert wird: Button sicherstellen
  function ensureBackButton(){
    const existing = $('#btn-abschluss-back, #btn-editor-back-clean');
    if (existing) return;
    const host = $('#abschluss-controls') || $('#abschluss-panel') || document.body;
    const btn = document.createElement('button');
    btn.id = 'btn-editor-back-clean';
    btn.type = 'button';
    btn.className = 'btn';
    btn.textContent = 'Zurück zur Bearbeitung';
    host.insertBefore(btn, host.firstChild || null);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureBackButton, {once:true});
  } else {
    ensureBackButton();
  }
  // Beobachten, falls der Abschlussbereich DOM neu aufbaut
  const mo = new MutationObserver(() => { ensureBackButton(); });
  mo.observe(document.body, {childList:true, subtree:true});
})();
</script>
<script id="ppk-unified-toggle_v4">
/* PNG/SVG-Schalter vereinheitlicht (Editor+Abschluss+Druck) – Lineal bleibt ausgenommen. */
(function(){
  const MODE_KEY = 'assetMode';
  const ROOTS = ['#kartenbereich', '#abschluss-grid', '#druck100-panel', 'body'];

  function roots(){ return ROOTS.map(s=>document.querySelector(s)).filter(Boolean); }
  function getMode(){ try { return (localStorage.getItem(MODE_KEY)||'PNG').toUpperCase(); } catch(_){ return 'PNG'; } }
  function setMode(m){ try { localStorage.setItem(MODE_KEY, m); } catch(_){ } }

  function isLinealEl(el){
    const idc = ((el && el.id)||'') + ' ' + ((el && el.className)||'');
    return /\blineal\b/i.test(idc) || /\blineal-container\b/i.test(idc);
  }

  function isLinealUrl(u){
    if (!u) return false;
    return /lineal/i.test(String(u));
  }

  function toSvgUrl(url){
    if (!url) return url;
    let out = String(url);
    let query = '';
    const qm = out.match(/(\?.*|#.*)$/);
    if (qm){ query = qm[1]; out = out.slice(0, qm.index); }
    if (isLinealUrl(out)) return out + query;
    out = out.replace(/_symbol\.png$/i, '.svg');
    if (/\/(sticker|karten)\//i.test(out)){
      out = out.replace(/\.png$/i, '.svg');
    }
    return out + query;
  }

  function toPngUrl(url){
    if (!url) return url;
    let out = String(url);
    let query = '';
    const qm = out.match(/(\?.*|#.*)$/);
    if (qm){ query = qm[1]; out = out.slice(0, qm.index); }
    if (isLinealUrl(out)) return out + query;
    if (/\/sticker\//i.test(out)){
      out = out.replace(/\.svg$/i, '_symbol.png');
    } else if (/\/karten\//i.test(out)){
      out = out.replace(/\.svg$/i, '.png');
    }
    return out + query;
  }

  function apply(mode){
    mode = 'PNG'; // öffentlicher Konfigurator: immer PNG
    const toUrl = toPngUrl;

    roots().forEach(root=>{
      root.querySelectorAll('img').forEach(img=>{
        if (isLinealEl(img)) return;
        const src = img.getAttribute('src') || '';
        if (!src) return;
        const next = toUrl(src);
        if (next && next!==src){
          img.setAttribute('src', next);
        }
      });

      root.querySelectorAll('[data-bg-kind]').forEach(el=>{
        if (isLinealEl(el)) return;
        const style = window.getComputedStyle(el);
        const bgImg = style.backgroundImage || '';
        const m = bgImg.match(/url\(["']?(.*?)["']?\)/i);
        if (!m) return;
        const src = m[1];
        if (!src) return;
        const next = toUrl(src);
        if (next && next!==src){
          el.style.backgroundImage = 'url("'+next+'")';
        }
      });
    });

    const badge = document.getElementById('asset-mode-indicator');
    if (badge) badge.textContent = mode;
  }

  const origSet = window.setAssetMode;
  window.setAssetMode = function(mode){
    const m = 'PNG';
    if (typeof origSet === 'function'){
      try { origSet(m); } catch(_){}
    }
    setMode(m);
    apply(m);
  };

  document.addEventListener('DOMContentLoaded', function(){
    const m = getMode();
    apply(m);
    setTimeout(()=>apply(getMode()), 40);
  }, {once:true});
})();
</script>
<!-- BEGIN: Präsentations-Export – final (direkt #abschluss-card-frame) -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script>
(function(){
  const $ = s => document.querySelector(s);
  const sleep = ms => new Promise(r=>setTimeout(r,ms));

  function getCaptureEl(){
    // Bevorzuge die komplette Abschlusskarte (inkl. Sticker/Text), nicht nur den Rahmen
    var el = document.querySelector('#abschluss-card') || document.querySelector('#abschluss-card-frame');
    if (!el) throw new Error('Abschlusskarte nicht gefunden (#abschluss-card).');
    return el;
  }

  function ensureSide(side){
    const card = document.querySelector('#abschluss-card');
    if (card) card.classList.toggle('show-back', side === 'back');
  }

  function getBaseName(){
    const t = (document.querySelector('#feld1NameAnzeige')?.textContent
           || document.querySelector('#feld1')?.value || 'karte')
           .trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_+|_+$/g,'');
    return t || 'karte';
  }

  async function withZoom100(run){
    const stage = document.querySelector('#abschluss-stage') || document.body;
    const had100 = stage.classList.contains('zoom-100');
    const had150 = stage.classList.contains('zoom-150');
    try{
      stage.classList.add('zoom-100'); stage.classList.remove('zoom-150');
      document.body.offsetHeight; await sleep(30);
      return await run();
    } finally {
      if (had150){ stage.classList.add('zoom-150'); stage.classList.remove('zoom-100'); }
      else if (!had100){ stage.classList.remove('zoom-100'); }
    }
  }

  async function renderPNG(el){
    if (document.fonts && document.fonts.ready) { try { await document.fonts.ready; } catch(e){} }
    const canvas = await html2canvas(el, {
      backgroundColor: '#ffffff',
      scale: 4,
      useCORS: true,
      logging: false
    });
    const data = canvas.toDataURL('image/png');
    if (!data || data.length < 20000) throw new Error('PNG leer/zu klein');
    return data;
  }

  
  function buildViewerHTML(title, front, back){
    const safe = title.replace(/</g,'&lt;').replace(/>/g,'&gt;');
    return `<!doctype html><html lang="de"><head><meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>${safe} – Präsentationskarte</title>
<style>
:root{ --zoom:1; }
html,body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:#fff; color:#111; }
.wrap{ max-width:980px; margin:16px auto; padding:0 12px; }
.controls{ display:flex; gap:8px; flex-wrap:wrap; margin-bottom:10px; }
button{ padding:8px 12px; border:1px solid #000; background:#fff; border-radius:8px; cursor:pointer; }
button:hover{ background:#f7f7f7; }
.stage{ display:grid; place-items:center; }
.cardframe{ display:inline-block; background:#fff; padding:0; transform-origin: top center; transform: scale(var(--zoom)); }
.img{ display:block; width:54mm; height:85mm; object-fit:fill; image-rendering:auto; }
.hidden{ display:none !important; }
.title{ font-weight:700; margin:8px 0 12px; }
</style>
<style id="help-button-style">
/* Hilfe-Button "Anleitung / Hinweise" im linken Pflegehinweis-Panel */
#spalte-links .help-button-row{
  margin:8px 0 12px;
  display:flex;
  justify-content:flex-end; /* weiter rechts, nahe Trenner */
  position:sticky;
  top:4px;
  z-index:5;
}
#spalte-links .help-link{
  text-decoration:none;
}
#spalte-links .help-pill{
  display:inline-flex;
  align-items:center;
  gap:8px;
  background:#ffffff;
  border-radius:8px;
  padding:6px 14px;
  box-shadow:0 2px 4px rgba(0,0,0,0.25);
}
#spalte-links .help-icon{
  width:42px;
  height:42px;
  border-radius:50%;
  background:#0057d8;
  color:#ffffff;
  display:flex;
  align-items:center;
  justify-content:center;
  font-family:"Adobe Caslon Pro","Times New Roman",serif;
  font-weight:700;
  font-size:34px;
  line-height:1;
}
#spalte-links .help-text{
  font-weight:700;
  line-height:1.1;
  color:#000000;
}
#spalte-links .help-text span{
  display:block;
}
</style>

</head><body>
<div class="wrap">
  <div class="title">${safe}</div>
  <div class="controls">
    <button id="btnFlip">Wenden</button>
    <button id="btnZ100">Zoom 100 %</button>
    <button id="btnZ150">Zoom 150 %</button>
  </div>
  <div class="stage">
    <div id="cardframe" class="cardframe">
      <img id="front" class="img" src="${front}" alt="Vorderseite">
      <img id="back" class="img hidden" src="${back}" alt="Rückseite">
    </div>
  </div>
</div>
<script>(function(){
  var back=false, z=1, f=document.getElementById('front'), b=document.getElementById('back');
  document.getElementById('btnFlip').onclick=function(){ back=!back; f.classList.toggle('hidden', back); b.classList.toggle('hidden', !back); };
  document.getElementById('btnZ100').onclick=function(){ z=1;   document.documentElement.style.setProperty('--zoom', z); };
  document.getElementById('btnZ150').onclick=function(){ z=1.5; document.documentElement.style.setProperty('--zoom', z); };
})();<\/script>
</body></html>`;
  }
function downloadFile(filename, content){
    const blob = new Blob([content], {type:'text/html'});
    const url  = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  }

  async function runExport(){
    alert('Praesentations-Export gestartet');
    try{
      const base = getBaseName();
      const el = getCaptureEl();
      await withZoom100(async ()=>{
        ensureSide('front'); await sleep(20);
        const pngFront = await renderPNG(el);
        ensureSide('back');  await sleep(20);
        const pngBack  = await renderPNG(el);
        const html = buildViewerHTML(base.replace(/_/g,' '), pngFront, pngBack);
        downloadFile(base + '_praesentation.html', html);
      });
      ensureSide('front');
    }catch(e){
      alert('Export-Fehler: ' + (e?.message || e));
      console.error(e);
    }
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    const btn = document.getElementById('btnPraesentation');
    if (btn) btn.addEventListener('click', runExport);
  });
})();
</script>
<!-- END: Präsentations-Export – final (direkt #abschluss-card-frame) -->
<!-- BEGIN: Abschluss – Backfields 17–25 baseline offset (-0.3mm) -->
<style id="abschluss-backfields-offset">
  /* Nur im Abschlussbereich, nur Rückseite: Text minimal nach oben schieben (optisch) */
  #abschluss-card .back-side #feld17,
  #abschluss-card .back-side #feld18,
  #abschluss-card .back-side #feld19,
  #abschluss-card .back-side #feld20,
  #abschluss-card .back-side #feld21,
  #abschluss-card .back-side #feld22,
  #abschluss-card .back-side #feld23,
  #abschluss-card .back-side #feld24,
  #abschluss-card .back-side #feld25{
    transform: translateY(-0.3mm);
  }
</style>
<!-- END: Abschluss – Backfields 17–25 baseline offset -->
<!-- === rb-next-equals-clear-v2 (2025-11-11) === -->
<script id="rb-next-equals-clear-v2">
(function(){
  'use strict';

  // zentrale Clear-Funktion – gleiche Logik wie beim 'rb-clear-failsafe' Button
  function rbClearCard(){
    try{
      // 1) Felder 1..25 leeren (Sticker/Text)
      for (var i=1;i<=25;i++){
        var el = document.getElementById('feld'+i);
        if (el) el.innerHTML = '';
      }
      // Feld 1 Anzeige leeren
      var f1 = document.getElementById('feld1NameAnzeige'); if (f1) f1.textContent = '';

      // 2) Textkapseln mit data-slot neutralisieren
      try{
        document.querySelectorAll('.karte-overlay [data-slot]').forEach(function(n){ n.textContent=''; });
      }catch(_){}

      // 3) Spruch & Smiley zurücksetzen
      var spr = document.getElementById('spruchSelect');  if (spr)  spr.selectedIndex = 0;
      var smi = document.getElementById('smileySelect');  if (smi)  smi.selectedIndex = 0;
      var sprA = document.getElementById('spruchAnzeige'); if (sprA) sprA.textContent = '';
      var symA = document.getElementById('symbolAnzeige'); if (symA) symA.textContent = '';

      // 4) Zähler neutralisieren
      try{ var slot0=document.getElementById('ppk-remaining'); if(slot0){ slot0.textContent='Verfügbar: —'; } }catch(_){}

      // 5) Rückseiten-Hinweis (slot-hint) + Raised-Klasse entfernen
      try{
        document.querySelectorAll('#karte-rueckseite .slot-hint').forEach(function(n){ n.remove(); });
        var fig = document.getElementById('karte-rueckseite'); if (fig) fig.classList.remove('hint-raise');
      }catch(_){}
    }catch(_){ /* silent */ }
  }
  window.rbClearCard = window.rbClearCard || rbClearCard;

  document.addEventListener('DOMContentLoaded', function(){
    var nextBtn = document.getElementById('btn-abschluss-next');
    if (!nextBtn || nextBtn.__rbNextEqBound) return;

    // Alle bestehenden Listener loswerden: Knoten klonen und ersetzen
    var clone = nextBtn.cloneNode(true);
    clone.id = nextBtn.id; // id beibehalten
    nextBtn.parentNode.replaceChild(clone, nextBtn);

    // Unser Handler: exakt wie "Karte leeren"
    clone.addEventListener('click', function(ev){
      try{
        if (ev){ ev.preventDefault(); ev.stopPropagation(); if (ev.stopImmediatePropagation) ev.stopImmediatePropagation(); }
      }catch(_){}
      try{ window.rbClearCard(); }catch(_){}
      return false;
    }, false);

    clone.__rbNextEqBound = true;
  });
})();
</script>
<!-- === rb-auswahl-dragonly (2025-11-11) === -->
<script id="rb-auswahl-dragonly">
(function(){
  'use strict';
  function blockDrop(el){
    if (!el || el.__rbNoDropBound) return;
    ['dragenter','dragover','drop'].forEach(function(ev){
      el.addEventListener(ev, function(e){
        try{ e.preventDefault(); e.stopPropagation(); if (e.stopImmediatePropagation) e.stopImmediatePropagation(); }catch(_){}
        return false;
      }, true); // capture, um vor globalen Drop-Handlern zu greifen
    });
    // Sicherheit: HTML5 dropzone deaktivieren
    try{ el.setAttribute('dropzone',''); }catch(_){}
    el.__rbNoDropBound = true;
  }

  function apply(){
    document.querySelectorAll('.rb-box-rect.selectable').forEach(blockDrop);
  }

  // Initial nach DOM-Ladung
  document.addEventListener('DOMContentLoaded', apply);

  // Und falls Boxen dynamisch aufgebaut werden: beobachten
  var mo = new MutationObserver(function(muts){
    for (var i=0;i<muts.length;i++){
      var t = muts[i].target;
      if (!(t instanceof Element)) continue;
      if (t.matches && t.matches('.rb-box-rect.selectable')) blockDrop(t);
      if (t.querySelectorAll){
        t.querySelectorAll('.rb-box-rect.selectable').forEach(blockDrop);
      }
    }
  });
  try{ mo.observe(document.documentElement || document.body, {subtree:true, childList:true}); }catch(_){}
})();
</script>
<!-- Feld 6 – Drag-Karte zwischen Selects + echter Drop-Slot im Overlay -->
<style id="f6-style">
  #spruchDragCard{
    display:inline-flex; align-items:center; gap:.6em;
    padding:.5em .8em; border:1px solid #999; border-radius:12px; background:#fff;
    font-size:15px; line-height:1.25; user-select:none; cursor:grab;
    white-space:nowrap;
  }
  #spruchDragCard .f6-pill{ max-width:360px; overflow:hidden; text-overflow:ellipsis; }
</style>
<script id="f6-slot-and-dnd">
(function(){
  'use strict';
  const sel   = document.getElementById('spruchSelect');
  const smile = document.getElementById('smileySelect');
  const out   = document.getElementById('spruchAnzeige');
  const ovl   = document.getElementById('karte_vorderseite_overlay');
  if(!sel || !smile || !out || !ovl) return;

  // --- 1) Drag-Karte: genau zwischen Spruch-Select und Smiley einfügen ---
  let card = document.getElementById('spruchDragCard');
  if(!card){
    card = document.createElement('div');
    card.id = 'spruchDragCard';
    card.setAttribute('draggable','true');
    card.innerHTML = '<span style="font-weight:600;opacity:.8">ziehen:</span><span class="f6-pill">–</span>';
    const controls = sel.parentElement; // .front-controls
    // Karte direkt vor den Smiley-Select setzen -> garantiert sichtbar
    controls.insertBefore(card, smile);
  }

  const T    = s => String(s||'').trim();
  const norm = s => String(s||'').replace(/\s*\/\s*/g, '\n');
  function currentText(){
    let t = sel.value || (sel.options[sel.selectedIndex] && sel.options[sel.selectedIndex].text) || '';
    t = T(t);
    if (/^kein\s+Spruch/i.test(t) || t==='–') return '';
    return t;
  }
  function syncCard(){
    const t = currentText();
    card.querySelector('.f6-pill').textContent = t || '–';
    card.style.pointerEvents = t ? 'auto' : 'none';
    card.style.opacity       = t ? '1'   : '.45';
  }
  sel.addEventListener('change', syncCard); syncCard();

  card.addEventListener('dragstart', ev=>{
    const t = currentText();
    ev.dataTransfer.setData('text/plain', t || '');
    ev.dataTransfer.effectAllowed = 'copy';
    // kleines DragImage als Feedback
    const gi = document.createElement('div');
    gi.style.cssText='position:fixed;top:-9999px;left:-9999px;padding:6px 10px;border:1px solid #bbb;border-radius:8px;background:#fff;font:14px/1.2 system-ui;';
    gi.textContent = t || '';
    document.body.appendChild(gi);
    try{ ev.dataTransfer.setDragImage(gi, Math.min(100, gi.offsetWidth/2), Math.min(14, gi.offsetHeight/2)); }catch(_){}
    setTimeout(()=>{ try{ gi.remove(); }catch(_){} }, 0);
  });

  // --- 2) ECHTES Drop-Ziel für Feld 6 im gleichen Overlay wie 2–5 & 7 ---
  let slot6 = document.getElementById('feld6_slot');
  if(!slot6){
    slot6 = document.createElement('div');
    slot6.id = 'feld6_slot';
    slot6.setAttribute('aria-label','Slot (Feld 6)');
    slot6.style.position = 'absolute';
    slot6.style.zIndex   = '11';          // auf Slot-Ebene
    slot6.style.background = 'transparent';
    slot6.style.pointerEvents = 'auto';
    ovl.appendChild(slot6);
  }

  // Position von #spruchAnzeige 1:1 übernehmen (beide im Overlay-Koordinatensystem)
  function place(){
    const s = out.style;
    if (s.left && s.top && s.width && s.height){
      slot6.style.left = s.left;  slot6.style.top = s.top;
      slot6.style.width = s.width; slot6.style.height = s.height;
    } else {
      // Fallback relativ zum Overlay
      const ob = ovl.getBoundingClientRect();
      const rb = out.getBoundingClientRect();
      slot6.style.left = (rb.left - ob.left) + 'px';
      slot6.style.top  = (rb.top  - ob.top)  + 'px';
      slot6.style.width  = rb.width + 'px';
      slot6.style.height = rb.height + 'px';
    }
    slot6.style.display = (parseFloat(getComputedStyle(out).width)||0)>0 ? 'block' : 'none';
  }
  place();
  window.addEventListener('resize', place, {passive:true});
  new MutationObserver(place).observe(out, {attributes:true, attributeFilter:['style','class']});

  // Drop-Logik: reinen Text setzen, Sticker/Slot-IDs ignorieren
  slot6.ondragover = e => { e.preventDefault(); };
  slot6.ondrop = e =>{
    e.preventDefault(); e.stopPropagation();
    const payload = (e.dataTransfer && e.dataTransfer.getData('text/plain')) || '';
    const t = T(payload);
    if (!t || /^sticker\//i.test(t) || /^feld\d+$/i.test(t)) return;

    out.textContent = norm(t);

    // Select mitführen (Option oder __custom__)
    let matched=false, customIdx=-1;
    for (let i=0;i<sel.options.length;i++){
      const o = sel.options[i];
      if (o && o.value==='__custom__') customIdx=i;
      if (T(o.text)===t || T(o.value)===t){ sel.selectedIndex=i; matched=true; break; }
    }
    if(!matched && customIdx>=0) sel.selectedIndex=customIdx;
    try{ sel.dispatchEvent(new Event('change', {bubbles:true})); }catch(_){}
  };
})();
</script>
<!-- Feld 6: Klick-Übernahme vorrübergehend blockieren, Drag bleibt -->
<script id="f6-test-block-click">
(function(){
  'use strict';
  var sel  = document.getElementById('spruchSelect');
  var out  = document.getElementById('spruchAnzeige');
  if(!sel || !out) return;

  // Test-Flag: Klick->Feld6 blockieren
  window.__F6_BLOCK_CLICK_TO_FIELD6__ = true;

  // 1) Eigene Change-Logik für die Drag-Karte weiterlaufen lassen (nur Anzeige),
  //    aber ALLE anderen Change-Listener stoppen (die den Text sofort ins Feld 6 schreiben würden).
  sel.addEventListener('change', function(e){
    if (window.__F6_BLOCK_CLICK_TO_FIELD6__) {
      // unsere eigene Sync-Funktion für die Drag-Karte erneut triggern (falls vorhanden)
      try { sel.dispatchEvent(new Event('f6_sync_only', {bubbles:false})); } catch(_){}
      e.stopImmediatePropagation(); // verhindert die bestehenden Handler, die Feld 6 sofort befüllen
      // NICHT preventDefault -> Auswahl darf sich ändern, damit du etwas zum Ziehen hast
    }
  }, true); // capture, damit wir garantiert VOR den bestehenden Handlern drankommen

  // 2) Optional: kleine Hilfsfunktionen, falls du während des Testens umschalten willst
  window.f6EnableClickToField6  = function(){ window.__F6_BLOCK_CLICK_TO_FIELD6__ = false; };
  window.f6DisableClickToField6 = function(){ window.__F6_BLOCK_CLICK_TO_FIELD6__ = true;  };

  // 3) Minimales Sync-Signal für unsere Drag-Karte (falls du meinen Drag-Karten-Patch drin hast)
  //    Wer keinen hat, ignoriert dieses Ereignis einfach.
  sel.addEventListener('f6_sync_only', function(){
    var card = document.getElementById('spruchDragCard');
    if (!card) return;
    var pill = card.querySelector('.f6-pill');
    if (!pill) return;
    var t = (sel.value || (sel.options[sel.selectedIndex] && sel.options[sel.selectedIndex].text) || '').trim();
    if (/^kein\s+Spruch/i.test(t)) t = '–';
    pill.textContent = t || '–';
    card.style.pointerEvents = (/^–$/.test(t)) ? 'none' : 'auto';
    card.style.opacity       = (/^–$/.test(t)) ? '.45'  : '1';
  });
})();
</script>
<script>

// === Feld6 unified setter (Drag&Drop + restore) ===
function rbSetFeld6FromText(raw) {
  try {
    var text = (raw || "").toString();
    // normalize slashes to newlines if someone dragged text with "/" as soft break
    // Keep both "\n" and "<br>" consistent in view; for #spruchAnzeige we keep plain text.
    text = text.replace(/\/\s*/g, "\n").replace(/\r\n/g, "\n");

    var anzeige = document.getElementById("spruchAnzeige");
    if (anzeige) {
      anzeige.textContent = text;
    }

    // sync select: find exact match (trimmed), else select __custom__ when present
    var sel = document.getElementById("spruchSelect");
    if (sel) {
      var trimmed = text.trim();
      var matchedIndex = -1;
      for (var i = 0; i < sel.options.length; i++) {
        var opt = sel.options[i];
        if (opt && (opt.text || "").trim() === trimmed) {
          matchedIndex = i;
          break;
        }
      }
      if (matchedIndex >= 0) {
        sel.selectedIndex = matchedIndex;
      } else {
        // try to set custom option if available
        var customIndex = -1;
        for (var j = 0; j < sel.options.length; j++) {
          if (sel.options[j].value === "__custom__") { customIndex = j; break; }
        }
        if (customIndex >= 0) {
          sel.selectedIndex = customIndex;
          // when using custom, keep the view in anzeige only
        }
      }
    }
  } catch (e) {
    console.error("rbSetFeld6FromText error:", e);
  }
}

// Ensure Feld 6 has a robust drop target
(function setupFeld6DropOnce(){
  var slot = document.getElementById("feld6_slot") || document.querySelector('[data-slot-id="feld6_slot"]');
  if (!slot) return;
  if (slot.__rbDropBound) return;
  slot.__rbDropBound = true;

  slot.addEventListener("dragover", function(ev){
    try { ev.preventDefault(); } catch(_){}
    // Optional visual cue: slot.classList.add("rb-drop-ok");
  }, {passive:false});

  slot.addEventListener("dragleave", function(ev){
    // Optional visual cue: slot.classList.remove("rb-drop-ok");
  });

  slot.addEventListener("drop", function(ev){
    try {
      ev.preventDefault();
      var dt = ev.dataTransfer;
      var txt = dt ? (dt.getData("text/plain") || dt.getData("text") || "") : "";
      // accept only plain text (ignore file/URL/sticker ids for Feld 6)
      rbSetFeld6FromText(txt);
    } catch (e) {
      console.error("Feld6 drop error:", e);
    } finally {
      // Optional visual cue reset
      // slot.classList.remove("rb-drop-ok");
    }
  });
})();

// Keep a lightweight sync for the draggable "Spruch" card so you can drag the currently selected option
(function syncSpruchDragCard(){
  var sel = document.getElementById("spruchSelect");
  var dragCard = document.getElementById("spruchDragCard");
  if (!sel || !dragCard) return;
  var pill = dragCard.querySelector(".spruch-pill") || dragCard;

  function updateDragSource(){
    var valText = "";
    if (sel.selectedIndex >= 0) valText = sel.options[sel.selectedIndex].text || "";
    pill.textContent = valText || "–";
    // ensure draggable true and setData on dragstart
    dragCard.setAttribute("draggable", "true");
  }
  sel.addEventListener("change", updateDragSource);
  updateDragSource();

  dragCard.addEventListener("dragstart", function(ev){
    try {
      var t = pill.textContent || "";
      ev.dataTransfer.setData("text/plain", t);
    } catch(e) { console.warn(e); }
  });
})();

</script>
<script>
window.rbRestoreFeld6 = function(text){
  rbSetFeld6FromText(text||"");
};
</script>
<script>
(function(){
  function mkChip(text){
    var d = document.createElement('div');
    d.className = 'chip';
    d.textContent = text;
    d.setAttribute('draggable','true');
    d.addEventListener('dragstart', function(ev){
      try{ ev.dataTransfer.setData('text/plain', text); }catch(e){}
    });
    return d;
  }

  function rebuildSpruchChips(){
    var sel = document.getElementById('spruchSelect');
    var wrap = document.getElementById('spruchChips');
    if (!sel || !wrap){ return; }
    wrap.innerHTML = '';
    for (var i=0; i<sel.options.length; i++){
      var opt = sel.options[i];
      if (!opt) continue;
      var val = (opt.value||'').trim();
      var txt = (opt.text||'').trim();
      if (!txt) continue;
      // skip placeholder / custom holder labels
      if (val === '__custom__') continue;
      if (/kein\s*Spruch/i.test(txt)) continue;
      wrap.appendChild(mkChip(txt));
    }
  }

  function setupFreeChip(){
    var free = document.getElementById('spruchFreeChip');
    if (!free) return;
    free.setAttribute('draggable', 'true');
    free.addEventListener('dragstart', function(ev){
      try{ ev.dataTransfer.setData('text/plain', free.textContent || ''); }catch(e){}
    });
  }

  function observeSelectChanges(){
    var sel = document.getElementById('spruchSelect');
    if (!sel) return;
    // Rebuild on option mutations (plant change repopulates options)
    var mo = new MutationObserver(function(muts){
      var changed = muts.some(m => m.type === 'childList');
      if (changed) rebuildSpruchChips();
    });
    mo.observe(sel, {childList:true});
  }

  document.addEventListener('DOMContentLoaded', function(){
    rebuildSpruchChips();
    setupFreeChip();
    observeSelectChanges();
  });

  // expose for external refresh after data loads
  window.rbRebuildSpruchChips = rebuildSpruchChips;
})();
</script>
<script>
(function(){
  // limits
  var MAX_LINES = 2, MAX_CHARS = 18;

  function norm(t){ return (t||"").replace(/\r\n/g,"\n"); }
  function clamp(text){
    var parts = norm(text).split("\n").slice(0, MAX_LINES);
    for (var i=0;i<parts.length;i++){
      if (parts[i].length > MAX_CHARS) parts[i] = parts[i].slice(0, MAX_CHARS);
    }
    return parts.join("\n");
  }
  function counts(text){
    var p = norm(text).split("\n");
    return {l1:(p[0]||"").length, l2:(p[1]||"").length};
  }
  function updateCounters(){
    var ta = document.getElementById('spruchFreeArea');
    var c = document.getElementById('spruchFreeCounters');
    if (!ta || !c) return;
    var cl = clamp(ta.value);
    if (ta.value !== cl) ta.value = cl;
    var cnt = counts(ta.value);
    c.textContent = "Zeile 1: " + cnt.l1 + "/18 · Zeile 2: " + cnt.l2 + "/18";
  }
  function onKey(e){
    var ta = document.getElementById('spruchFreeArea');
    if (!ta) return;
    if (e.key === "Enter" && !e.shiftKey){ e.preventDefault(); return; }
    setTimeout(updateCounters, 0);
  }
  function onInput(){ updateCounters(); }
  function onPaste(e){
    e.preventDefault();
    var t = (e.clipboardData && e.clipboardData.getData('text/plain')) || "";
    document.execCommand('insertText', false, t);
  }
  function setupDrag(){
    var handle = document.getElementById('spruchDragHandle');
    var ta = document.getElementById('spruchFreeArea');
    if (!handle || !ta) return;
    handle.addEventListener('dragstart', function(ev){
      try{ ev.dataTransfer.setData('text/plain', clamp(ta.value)); }catch(_){}
    });
  }
  document.addEventListener('DOMContentLoaded', function(){
    var ta = document.getElementById('spruchFreeArea');
    if (ta){
      ta.addEventListener('keydown', onKey);
      ta.addEventListener('input', onInput);
      ta.addEventListener('paste', onPaste);
      updateCounters();
    }
    setupDrag();
    // Accordion: change caret symbol
    var acc = document.getElementById('spruchAccordion');
    var sum = acc ? acc.querySelector('.spruch-acc-summary') : null;
    if (acc && sum){
      acc.addEventListener('toggle', function(){
        sum.textContent = acc.open ? 'Spruch ▴' : 'Spruch ▾';
      });
    }
  });
})();
</script>
<script>
  function closeSpruchRegal(ev){
    if(ev && ev.preventDefault) ev.preventDefault();
    var acc = document.getElementById('spruchAccordion');
    if(acc){ acc.open = false; }
  }
</script>
<script>
(function strengthenFeld6DnD(){
  function bindDrop(el){
    if (!el || el.__rbDropBound) return;
    el.__rbDropBound = true;
    el.addEventListener("dragover", function(ev){ try{ ev.preventDefault(); }catch(_){ } }, {passive:false});
    el.addEventListener("drop", function(ev){
      try{
        var kb = document.getElementById("kartenbereich");
        if (kb && kb.classList && kb.classList.contains("back-top")) return;
      }catch(_){ }

      try{
        ev.preventDefault();
        var dt = ev.dataTransfer;
        var txt = dt ? (dt.getData("text/plain") || dt.getData("text") || "") : "";
        if (typeof rbSetFeld6FromText === 'function') rbSetFeld6FromText(txt);
      }catch(e){ console.error("Feld6 drop (alt) error:", e); }
    });
  }
  function init(){
    bindDrop(document.getElementById("feld6_slot"));
    bindDrop(document.getElementById("spruchAnzeige"));
    var alias = document.querySelector('[data-slot-id="feld6_slot"]');
    bindDrop(alias);
  }
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }

  // Global fallback: if user drops near Feld 6 card area, treat as Feld 6
  document.addEventListener("drop", function(ev){
    try{
      var kb = document.getElementById("kartenbereich");
      if (kb && kb.classList && kb.classList.contains("back-top")) return;

      var a = document.getElementById("spruchAnzeige");
      if (!a) return;
      var r = a.getBoundingClientRect();
      var x = ev.clientX, y = ev.clientY;
      var inside = (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom);
      if (!inside) return;
      var txt = (ev.dataTransfer && (ev.dataTransfer.getData("text/plain") || ev.dataTransfer.getData("text") || "")) || "";
      if (!txt) return;
      if (typeof rbSetFeld6FromText === 'function') {
        ev.preventDefault();
        rbSetFeld6FromText(txt);
      }
    }catch(e){}
  }, {capture:true});
})();
</script>
<script>
(function reinforceFeld7Drop(){
  function bind(el){
    if (!el || el.__rbF7Bound) return;
    el.__rbF7Bound = true;
    el.addEventListener('dragover', function(ev){ try{ ev.preventDefault(); ev.dataTransfer.dropEffect='copy'; }catch(_){} }, {passive:false});
    el.addEventListener('drop', function(ev){
      try{
        ev.preventDefault();
        if (typeof empfangeSticker === 'function'){
          empfangeSticker(ev, 'symbolAnzeige');
        }
      }catch(e){ console.error('Feld7 drop error:', e); }
    });
  }
  function init(){
    bind(document.getElementById('symbolAnzeige'));
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
<script>
// Robust capture-level fallback for Feld 6: accept text drops inside either feld6_slot or spruchAnzeige rects.
(function(){
  function insideRect(el, x, y){
    if (!el) return false;
    var r = el.getBoundingClientRect();
    return (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom);
  }
    function handleDocDrop(ev){
    try{
      var kb = document.getElementById("kartenbereich");
      if (kb && kb.classList && kb.classList.contains("back-top")) return;

      var x = ev.clientX, y = ev.clientY;
      var s6 = document.getElementById('feld6_slot');
      var an = document.getElementById('spruchAnzeige');
      if (!(insideRect(s6, x, y) || insideRect(an, x, y))) return;
      var txt = (ev.dataTransfer && (ev.dataTransfer.getData('text/plain') || ev.dataTransfer.getData('text') || '')) || '';
      if (!txt) return;
      if (typeof rbSetFeld6FromText === 'function'){
        ev.preventDefault();
        ev.stopPropagation();
        rbSetFeld6FromText(txt);
      }
    }catch(e){}
  }
  document.addEventListener('drop', handleDocDrop, true);
    document.addEventListener('dragover', function(ev){
    // Allow drop if hovering Feld 6 area
    try{
      var kb = document.getElementById('kartenbereich');
      if (kb && kb.classList && kb.classList.contains('back-top')) return;

      var x=ev.clientX, y=ev.clientY;
      var s6 = document.getElementById('feld6_slot');
      var an = document.getElementById('spruchAnzeige');
      if (insideRect(s6,x,y) || insideRect(an,x,y)){
        ev.preventDefault();
        ev.dataTransfer.dropEffect='copy';
      }
    }catch(_){}
  }, true);
})();
</script>
<script>
(function(){
  if (typeof rbSetFeld6FromText === 'function' && !rbSetFeld6FromText.__wrappedClose){
    var _orig = rbSetFeld6FromText;
    window.rbSetFeld6FromText = function(raw){
      var res = _orig.apply(this, arguments);
      try {
        var acc = document.getElementById('spruchAccordion');
        if (acc && acc.open && (raw||'').toString().trim().length){
          acc.open = false; // auto-zuklappen
        }
      } catch(_){}
      return res;
    };
    window.rbSetFeld6FromText.__wrappedClose = true;
  }
})();
</script>
<script>
(function ensureFeld7NextToFeld6(){
  function findAnchor(){
    var candidates = Array.from(document.querySelectorAll("figure[id*='vorder'], figure[id*='front'], figure[id*='rueck'], figure[id*='back'], figure.karte, figure"));
    if (candidates.length){
      var best = candidates[0], maxB = -1;
      candidates.forEach(function(el){
        var r = el.getBoundingClientRect();
        var b = (r ? r.bottom + window.scrollY : 0);
        if (b > maxB){ maxB = b; best = el; }
      });
      return best;
    }
    return document.querySelector("figure") || document.body;
  }
  function containerAfter(anchor){
    var wrap = document.getElementById("underCardSelectors");
    if (wrap) return wrap;
    wrap = document.createElement("div");
    wrap.id = "underCardSelectors";
    if (anchor.nextSibling) anchor.parentNode.insertBefore(wrap, anchor.nextSibling);
    else anchor.parentNode.appendChild(wrap);
    return wrap;
  }
  function panel(id){
    var el = document.getElementById(id);
    if (el) return el;
    var p = document.createElement("div");
    p.className = "uc-panel";
    p.id = id;
    return p;
  }
  function move(el, host){
    if (!el || !host) return;
    host.appendChild(el);
  }

  function init(){
    var anchor = findAnchor();
    var host = containerAfter(anchor);

    // Ensure two panels exist
    var p6 = panel("uc-p6");
    var p7 = panel("uc-p7");
    if (!p6.parentNode) host.appendChild(p6);
    if (!p7.parentNode) host.appendChild(p7);

    // Feld 6 accordion/regal
    var f6 = document.getElementById("spruchAccordion") || document.getElementById("spruchRegal");
    if (f6 && f6.parentNode !== p6) move(f6, p6);

    // Feld 7: prefer custom dropdown (#feld7-dd); fallback to native #smileySelect
    var f7dd = document.getElementById("feld7-dd");
    var f7sel = document.getElementById("smileySelect");
    var ui = null;
    if (f7dd){
      ui = f7dd;
      // make sure it's visible
      f7dd.style.display = "inline-block";
      f7dd.style.visibility = "visible";
    } else if (f7sel){
      ui = document.createElement("div");
      ui.className = "picker-row";
      var lab = document.createElement("label");
      lab.textContent = "Smiley:";
      ui.appendChild(lab);
      // unhide select and move
      f7sel.style.display = "block";
      f7sel.style.visibility = "visible";
      ui.appendChild(f7sel);
    }
    if (ui){
      if (ui.parentNode !== p7) move(ui, p7);
    }
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();
</script>
<script>
(function placeSelectorsInEditorBeforeFinish(){
  function findFinishButton(){
    var cands = Array.from(document.querySelectorAll("button, input[type='button'], .btn, .button"));
    for (var i=0;i<cands.length;i++){
      var t = (cands[i].textContent || cands[i].value || "").trim().toLowerCase();
      if (t === "karte fertig" || t.indexOf("karte")>=0 && t.indexOf("fertig")>=0){
        return cands[i];
      }
    }
    return null;
  }
  function findCardFigures(){
    return Array.from(document.querySelectorAll("figure[id*='vorder'], figure[id*='front'], figure[id*='rueck'], figure[id*='back']"));
  }
  function ensureContainer(){
    var wrap = document.getElementById("underCardSelectors");
    if (!wrap){
      wrap = document.createElement("div");
      wrap.id = "underCardSelectors";
      wrap.style.marginTop = "10px";
      wrap.style.display = "grid";
      wrap.style.gridTemplateColumns = "1fr 1fr";
      wrap.style.gap = "12px";
      wrap.style.alignItems = "start";
    } else {
      // detach to relocate if needed
      if (wrap.parentNode) wrap.parentNode.removeChild(wrap);
    }
    return wrap;
  }
  function makePanels(wrap){
    var p6 = document.getElementById("uc-p6"); if (!p6){ p6 = document.createElement("div"); p6.id="uc-p6"; p6.className="uc-panel"; }
    var p7 = document.getElementById("uc-p7"); if (!p7){ p7 = document.createElement("div"); p7.id="uc-p7"; p7.className="uc-panel"; }
    var pF = document.getElementById("uc-pF"); if (!pF){ pF = document.createElement("div"); pF.id="uc-pF"; pF.className="uc-panel"; }
    wrap.appendChild(p6); wrap.appendChild(p7); wrap.appendChild(pF);
    return {p6:p6, p7:p7, pF:pF};
  }
  function move(el, host){ if (el && host && el.parentNode !== host) host.appendChild(el); }

  function init(){
    var finishBtn = findFinishButton();
    var wrap = ensureContainer();
    var panels = makePanels(wrap);

    // Move Feld 6 accordion
    var f6 = document.getElementById("spruchAccordion") || document.getElementById("spruchRegal");
    if (f6) move(f6, panels.p6);

    // Move Feld 7 UI
    var f7dd = document.getElementById("feld7-dd");
    var f7sel = document.getElementById("smileySelect");
    if (f7dd){
      f7dd.style.display="inline-block"; f7dd.style.visibility="visible";
      move(f7dd, panels.p7);
    } else if (f7sel){
      f7sel.style.display="block"; f7sel.style.visibility="visible";
      move(f7sel, panels.p7);
    }

    if (finishBtn && finishBtn.parentNode){
      finishBtn.parentNode.insertBefore(wrap, finishBtn);
    } else {
      // Fallback: after last card figure
      var figs = findCardFigures();
      if (figs.length){
        var last = figs.reduce(function(a,b){
          var ra=a.getBoundingClientRect(), rb=b.getBoundingClientRect();
          return (rb.bottom>ra.bottom?b:a);
        });
        if (last.nextSibling) last.parentNode.insertBefore(wrap, last.nextSibling);
        else last.parentNode.appendChild(wrap);
      } else {
        document.body.appendChild(wrap);
      }
    }

    if (finishBtn){
      move(finishBtn, panels.pF);
      var row = document.getElementById("abschluss-trigger-row");
      if (row && row.children.length === 0){
        row.style.display = "none";
      }
    }
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", init);
  else init();
})();
</script>
<script>
(function tidyAndAddArrows(){
  function removeEmptyCapsules(){
    // Remove any empty uc-panels or old underCardSelectors that ended up elsewhere
    document.querySelectorAll('.uc-panel').forEach(function(p){
      if (!p.children || p.children.length===0) p.remove();
    });
    // Remove empty wrappers with just whitespace
    document.querySelectorAll('#underCardSelectors').forEach(function(w){
      if (!w.children || w.children.length===0) w.remove();
    });
  }

  function ensureArrows(){
    var p6 = document.getElementById('uc-p6');
    var p7 = document.getElementById('uc-p7');
    if (p6 && !p6.querySelector('
    if (p7 && !p7.querySelector('
  }

  function centerX(el){
    var r = el.getBoundingClientRect();
    return r.left + r.width/2 + window.scrollX;
  }

  function positionArrows(){
    var s6 = document.getElementById('feld6_slot') || document.getElementById('spruchAnzeige');
    var s7 = document.getElementById('feld7') || document.getElementById('symbolAnzeige');
    var a6 = document.getElementById('uc-arrow-6');
    var a7 = document.getElementById('uc-arrow-7');
    var p6 = document.getElementById('uc-p6');
    var p7 = document.getElementById('uc-p7');
    try{
      if (a6 && p6 && s6){
        var target = centerX(s6);
        var base   = p6.getBoundingClientRect().left + window.scrollX;
        a6.style.left = (target - base) + "px";
      }
      if (a7 && p7 && s7){
        var target2 = centerX(s7);
        var base2   = p7.getBoundingClientRect().left + window.scrollX;
        a7.style.left = (target2 - base2) + "px";
      }
    }catch(e){}
  }

  function init(){
    removeEmptyCapsules();
    ensureArrows();
    positionArrows();
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  window.addEventListener('resize', positionArrows);
  window.addEventListener('scroll', positionArrows);
})();
</script>
<script>
(function zoomAwareSelectorOffset(){
  var CM = 37.7952755906; // px per cm @96dpi
  var lastZoom = null;
  function readZoom(){
    // read CSS var --zoom from :root (default 1)
    var z = 1;
    try{
      var v = getComputedStyle(document.documentElement).getPropertyValue('--zoom').trim();
      if (v) z = parseFloat(v);
      if (!isFinite(z) || z<=0) z = 1;
    }catch(_){}
    return z;
  }
  function computeOffsetPx(z){
    // Specific requests:
    // - at 1.0 -> 2.0 cm up
    // - at 1.5 -> 2.7 cm up
    // - otherwise: proportional fallback
    if (Math.abs(z - 1.0) < 0.05) return - (2.0 * CM);
    if (Math.abs(z - 1.5) < 0.11) return - (2.7 * CM);
    return - (2.0 * z * CM);
  }
  function apply(){
    var wrap = document.getElementById('underCardSelectors');
    if (!wrap) return;
    var z = readZoom();
    if (z === lastZoom) return;
    lastZoom = z;
    var off = computeOffsetPx(z);
    wrap.style.marginTop = off.toFixed(2) + 'px';
    // re-run arrow positioning if present
    if (typeof window.positionArrows === 'function'){
      try{ window.positionArrows(); }catch(_){}
    } else {
      // try to request a custom event in our earlier block
      var ev = new Event('uc-reposition', {bubbles:false});
      document.dispatchEvent(ev);
    }
  }
  function loop(){
    apply();
    window.requestAnimationFrame(loop);
  }
  document.addEventListener('DOMContentLoaded', function(){
    apply();
    loop();
  });
  window.addEventListener('resize', apply);
})();
</script>
<script>
(function measuredZoomOffsets(){
  var CM = 37.7952755906; // px per cm @96dpi
  var CARD_H_MM = 85;     // known card height
  var BASE_PX = CARD_H_MM * 3.77952755906; // 1 mm = 3.7795 px
  var lastK = null;

  function getCardRect(){
    var figs = document.querySelectorAll("figure[id*='vorder'], figure[id*='front'], figure[id*='rueck'], figure[id*='back']");
    var best = null, maxB = -1;
    figs.forEach(function(el){
      var r = el.getBoundingClientRect();
      if (r && (r.bottom > maxB)){ maxB = r.bottom; best = el; }
    });
    return best ? best.getBoundingClientRect() : null;
  }

  function readZoomByHeight(){
    try{
      var r = getCardRect();
      if (!r) return 1;
      var k = r.height / BASE_PX; // scale factor
      if (!isFinite(k) || k<=0) k = 1;
      return k;
    }catch(_){ return 1; }
  }

  function desiredOffsetPx(k){
    // exact wishes:
    // 100% => -2.0 cm
    // 150% => -2.7 cm
    if (Math.abs(k - 1.0) < 0.08) return -2.0 * CM;
    if (Math.abs(k - 1.5) < 0.12) return -2.7 * CM;
    // otherwise proportional to scale (based on 2.0 cm at 1.0)
    return -2.0 * k * CM;
  }

  function apply(){
    var wrap = document.getElementById('underCardSelectors');
    if (!wrap) return;
    var k = readZoomByHeight();
    if (lastK !== null && Math.abs(k - lastK) < 0.01) return;
    lastK = k;
    var off = desiredOffsetPx(k);
    wrap.style.marginTop = off.toFixed(2) + 'px';
    // also re-position arrows if our helper exists
    if (typeof window.positionArrows === 'function') {
      try{ window.positionArrows(); }catch(_){}
    }
  }

  var ro = new ResizeObserver(apply);
  document.addEventListener('DOMContentLoaded', function(){
    apply();
    var card = document.querySelector("figure[id*='vorder'], figure[id*='front']") || document.querySelector("figure");
    if (card) ro.observe(card);
  });
  window.addEventListener('resize', apply);
  window.addEventListener('scroll', apply);
})();
</script>
<style id="spruch-acc-summary-border">
/* Spruch-Auswahlfeld (gelbe Zeile "Spruch ▾") mit 0,5 mm schwarzer Kontur */
.spruch-acc-summary{
  border: 0.5mm solid #000 !important;
  border-radius: 10px !important;
}
</style>
<style id="feld6-7-border-arrow-clean">
/* Feld 6 (Spruch) & Feld 7 (Smiley): schwarze Kontur + Pfeil nach oben,
   ohne Klicklogik (details/summary, Dropdown) zu stören. */
.spruch-acc-summary,
#feld7-trigger{
  border: 0.5mm solid #000 !important;
  border-radius: 8px !important;          /* wie "Karte fertig" */
  position: relative;                     /* Anker für Pfeil */
}

/* Schwarzer Pfeil aus der Kontur nach oben */

.spruch-acc-summary::after,
#feld7-trigger::after{
  content:"";
  position:absolute;
  top:-8px;
  left:10px !important;       /* Pfeil auf der Kontur, 10px von links */
  transform:none !important;
  width:0;
  height:0;
  border-left:7px solid transparent;
  border-right:7px solid transparent;
  border-bottom:8px solid #000;  /* innerer Pfeil ebenfalls schwarz */
  pointer-events:none;
}

/* Leichte horizontale Justierung für Feld 7, ohne Transform-Tricks */
#feld7-trigger{
  margin-left: 6mm;                        /* optische Annäherung an Slot für Feld 7 */
}
body.zoom-150 #feld7-trigger{
  margin-left: 6mm;                        /* bei 150 % identisch, kein doppeltes Skalieren */
}
</style>
<style id="feld6-7-position-100-150">
/* Positionierung der Auswahlbuttons unter der Karte */

/* 100 %: 1,8 cm höher und 3 mm nach rechts – jetzt mit eigenem Layer über der Karte */
#underCardSelectors{
  margin-top: -18mm !important;
  margin-left: 3mm !important;
  position: relative;
  z-index: 5000; /* über Karten-Overlay, damit Klicks ankommen */
}

/* 150 %: 2,7 cm höher und 2,7 cm nach rechts – gleicher Layer */
body.zoom-150 #underCardSelectors{
  margin-top: -27mm !important;
  margin-left: 27mm !important;
  position: relative;
  z-index: 5000;
}
</style>
<style id="feld7-hide-fallback-select">
/* Feld 7: altes Fallback-Select im weißen Regal ausblenden */
.uc-panel select#smileySelect{
  display: none !important;
  visibility: hidden !important;
}
</style>
<style id="spruchFreeArea-burgundy-border">
/* Freitext-Eingabefeld im Spruchregal: Rahmen wie bei den anderen Hinweisen */
#spruchFreeArea{
  border: 1mm solid #800020 !important;
  border-radius: 8px !important;
  overflow: hidden !important;
  resize: none !important;
}
</style>
<style id="rb-kose-hint-style">
/* Kosename-Hinweis direkt unter das Kosenamefeld setzen und sichtbar machen */
#rb-kose-hint{
  margin-top: 4px;
  background: #FFFFFF;
  border: 0.5mm solid #800020; /* weinrot wie andere Hinweise */
  border-radius: 8px;
  position: relative;
  z-index: 10;
}
</style>
<style id="rb-kose-kachel-css">
/* Kosename-Kachel: Button + Hinweis stapeln in derselben Grid-Zelle (koseSet) */
#rb-kose-kachel{
  grid-area: koseSet;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 4px;
}
#rb-kose-kachel > #btn-uebernehmen-kosename{
  width: 100%;
}
/* Hinweis vollbreit direkt unter dem Button, ohne eigene Positionierung zu verlieren */
#rb-kose-hint{
  position: relative !important;
  margin: 4px 0 0 0 !important;
  max-width: 100% !important;
  align-self: flex-start !important;
}
</style>

<script id="feld6-trash-drag-v4">
(function(){
  'use strict';
  // Helper: safe query
  function $(sel){ return document.querySelector(sel); }

  // 1) Feld 6 (Spruch) draggable machen – wir hängen uns an #spruchAnzeige (Fallback: #feld6_slot)
  function bindFeld6Drag(){
    var el = $('#spruchAnzeige') || $('#feld6_slot') || $('#feld6');
    if (!el || el.__f6DragBound) return;
    // Nur sinnvoll, wenn Inhalt vorhanden ist; trotzdem erlauben wir den Start generell.
    if (!el.getAttribute('draggable')) el.setAttribute('draggable', 'true');
    el.addEventListener('dragstart', function(ev){
      try{
        // Kennzeichner, den der Mülleimer versteht
        ev.dataTransfer.setData('text/plain', 'feld6');
      }catch(_){}
    });
    el.__f6DragBound = true;
  }

  // 2) Mülleimer: Drop von Feld 6 leeren + Zähler dekrementieren
  function bindTrashForFeld6(){
    var bin = document.getElementById('trash') || document.querySelector('.panel-tools .icon[title="Mülleimer"]');
    if (!bin || bin.__f6TrashBound) return;
    bin.addEventListener('dragover', function(ev){
      try{ 
        var t = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
        if (t === 'feld6'){ ev.preventDefault(); }
      }catch(_){}
    }, true);
    bin.addEventListener('drop', function(ev){
      try{
        var payload = (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || '';
        if (payload !== 'feld6') return;
        ev.preventDefault();
        ev.stopImmediatePropagation();
        var f6 = $('#spruchAnzeige') || $('#feld6_slot') || $('#feld6');
        if (!f6) return;
        // Zähler (rbOrigin) abbuchen, falls vorhanden
        try{
          if (f6.dataset && f6.dataset.rbOrigin && typeof window.dec === 'function'){
            window.dec(f6.dataset.rbOrigin);
          }
        }catch(_){}
        try{ if (f6.dataset && 'rbOrigin' in f6.dataset) delete f6.dataset.rbOrigin; }catch(_){}
        // Inhalt löschen (wie bei Reset)
        try{
          if (typeof window.clearNode === 'function'){ window.clearNode(f6); }
          else { while (f6.firstChild) f6.removeChild(f6.firstChild); f6.textContent = ''; }
        }catch(_){}
      }catch(_){}
    }, true);
    bin.__f6TrashBound = true;
  }

  function init(){
    bindFeld6Drag();
    bindTrashForFeld6();
  }
  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); }
  else { init(); }
})();
</script>
<style id="feld6-drag-handle-css-v6">
#feld6-drag-handle{
  position:absolute;
  inset:0;
  cursor: grab;
  pointer-events: auto !important;
  background: transparent;
  z-index: 10010; /* über Feld-Overlays */
}
#feld6-drag-handle:active{ cursor: grabbing; }
.trash-hover{ outline: 2px dashed #000; outline-offset: 2px; }
</style>
<script id="feld6-drag-handle-js-v6">
(function(){
  'use strict';
  var MIME = 'application/x-feld6';
  function $(s){ return document.querySelector(s); }
  function up(el,sel){
    while(el){ try{ if(el.matches && el.matches(sel)) return el; }catch(_){} el = el.parentElement; }
    return null;
  }
  function findTrash(el){
    return up(el, "#trash, #muelleimer, .trash, [data-role='trash'], [data-drop='trash'], .icon[title*='Müll' i], button[title*='Müll' i], [aria-label*='Müll' i], .icon[title*='trash' i], [aria-label*='trash' i]");
  }
  function ensureHandle(){
    var host = $('#spruchAnzeige') || $('#feld6_slot') || $('#feld6');
    if(!host || host.__f6HandleBound) return;
    if(getComputedStyle(host).position === 'static'){
      host.style.position = 'relative';
    }
    var h = document.createElement('div');
    h.id = 'feld6-drag-handle';
    h.setAttribute('draggable','true');
    h.addEventListener('dragstart', function(ev){
      try{
        ev.dataTransfer.setData(MIME, '1');
        ev.dataTransfer.effectAllowed = 'copyMove';
        window.__dragFeld6 = true;
      }catch(_){ window.__dragFeld6 = true; }
    });
    h.addEventListener('dragend', function(){ window.__dragFeld6 = false; });

    host.appendChild(h);
    host.__f6HandleBound = true;
  }

  function clearFeld6(){
    var f6 = $('#spruchAnzeige') || $('#feld6_slot') || $('#feld6');
    if(!f6) return;
    try{
      if (f6.dataset && f6.dataset.rbOrigin && typeof window.dec === 'function'){
        window.dec(f6.dataset.rbOrigin);
      }
    }catch(_){}
    try{ if (f6.dataset && 'rbOrigin' in f6.dataset) delete f6.dataset.rbOrigin; }catch(_){}
    try{
      if (typeof window.clearNode === 'function'){ window.clearNode(f6); }
      else { while (f6.firstChild) f6.removeChild(f6.firstChild); f6.textContent = ''; }
    }catch(_){}
  }

  function bindDelegatedTrash(){
    if (document.__f6TrashDelegated) return;

    document.addEventListener('dragover', function(ev){
      try{
        var t = ev.dataTransfer && ev.dataTransfer.types;
        var overTrash = findTrash(ev.target);
        // Chrome: getData in dragover gibt oft "", also auf types oder global Flag prüfen
        if(overTrash && ( (t && Array.prototype.indexOf.call(t, MIME) !== -1) || window.__dragFeld6 === true )){
          ev.preventDefault();
          overTrash.classList && overTrash.classList.add('trash-hover');
        }
      }catch(_){}
    }, true);

    document.addEventListener('dragleave', function(ev){
      var overTrash = findTrash(ev.target);
      if(overTrash && overTrash.classList){ overTrash.classList.remove('trash-hover'); }
    }, true);

    document.addEventListener('drop', function(ev){
      try{
        var overTrash = findTrash(ev.target);
        var allowed = false;
        if(ev.dataTransfer){
          var t = ev.dataTransfer.types;
          allowed = (t && Array.prototype.indexOf.call(t, MIME) !== -1) || window.__dragFeld6 === true;
        }else{
          allowed = window.__dragFeld6 === true;
        }
        if(overTrash && allowed){
          ev.preventDefault();
          ev.stopPropagation();
          if(overTrash.classList){ overTrash.classList.remove('trash-hover'); }
          clearFeld6();
          window.__dragFeld6 = false;
        }
      }catch(_){}
    }, true);

    document.__f6TrashDelegated = true;
  }

  function init(){ ensureHandle(); bindDelegatedTrash(); }
  if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, {once:true}); }
  else { init(); }
})();
</script>
<script id="f6-trash-explicit-binder-v6b">
(function(){
  'use strict';
  var MIME = 'application/x-feld6';
  function $(s){ return document.querySelector(s); }
  function typesHas(dt, t){ try{ return dt && dt.types && Array.prototype.indexOf.call(dt.types, t)!==-1; }catch(_){ return false; } }
  function bind(){
    var trash = $('#trash.icon') || $('#trash');
    if(!trash || trash.__f6Bound) return;
    trash.addEventListener('dragover', function(ev){
      if(window.__dragFeld6===true || typesHas(ev.dataTransfer, MIME)){ ev.preventDefault(); }
    }, true);
    trash.addEventListener('drop', function(ev){
      if(window.__dragFeld6===true || typesHas(ev.dataTransfer, MIME)){
        ev.preventDefault(); ev.stopPropagation();
        // Clear Feld 6 using existing helper from v6
        try{
          var f6 = document.querySelector('#spruchAnzeige') || document.querySelector('#feld6_slot') || document.querySelector('#feld6');
          if(f6){
            if(f6.dataset && f6.dataset.rbOrigin && typeof window.dec==='function'){ window.dec(f6.dataset.rbOrigin); }
            if(f6.dataset && 'rbOrigin' in f6.dataset) delete f6.dataset.rbOrigin;
            if(typeof window.clearNode==='function'){ window.clearNode(f6); } else { while(f6.firstChild) f6.removeChild(f6.firstChild); f6.textContent=''; }
          }
        }catch(_){}
        window.__dragFeld6=false;
      }
    }, true);
    trash.__f6Bound = true;
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bind, {once:true}); }
  else{ bind(); }
})();
</script>
<style id="f6-float-handle-css-v6d">
#f6-float-handle{
  position: fixed;            /* unabhängig vom Layout der Karte */
  left: -9999px; top: -9999px;
  width: 1px; height: 1px;
  z-index: 30000;             /* über allen Overlays */
  cursor: grab;
  pointer-events: auto;
  background: transparent;
}
#f6-float-handle.dragging{ cursor: grabbing; }

/* zweiten (mittigen) Pfeil über Spruch/Smiley ausblenden */
.spruch-acc-summary::before,
#feld7-trigger::before{
  content: none !important;
  border: none !important;
}

/* Abstand: "Bestellung aufgeben" im Abschlussbereich ca. 2cm tiefer */
#btn-abschluss-checkout{
  margin-top: 120px !important;  /* ~3 cm, etwa 1 cm tiefer als vorher */
  display: inline-block;
}
</style>
<script id="f6-float-handle-js-v6d">
(function(){
  'use strict';
  var MIME = 'application/x-feld6';
  var handle, ticking=false;
  function $(s){ return document.querySelector(s); }
  function rect(el){ try{ return el.getBoundingClientRect(); }catch(_){ return null; } }
  function ensureHandle(){
    if(handle) return handle;
    handle = document.createElement('div');
    handle.id = 'f6-float-handle';
    handle.setAttribute('draggable','true');
    handle.addEventListener('dragstart', function(e){
      try{ e.dataTransfer.setData(MIME,'1'); e.dataTransfer.effectAllowed='copyMove'; }catch(_){}
      window.__dragFeld6 = true;
      handle.classList.add('dragging');
    });
    handle.addEventListener('dragend', function(){ window.__dragFeld6=false; handle.classList.remove('dragging'); });
    document.body.appendChild(handle);
    return handle;
  }
  function place(){
    var host = $('#spruchAnzeige') || $('#feld6_slot') || $('#feld6');
    if(!host) return;
    var r = rect(host);
    if(!r || r.width<2 || r.height<2){
      handle.style.left = '-9999px'; handle.style.top='-9999px'; handle.style.width='1px'; handle.style.height='1px';
      return;
    }
    // Position den Handle deckungsgleich über Feld 6
    handle.style.left = (Math.floor(r.left))+'px';
    handle.style.top  = (Math.floor(r.top))+'px';
    handle.style.width= Math.ceil(r.width)+'px';
    handle.style.height= Math.ceil(r.height)+'px';
  }
  function schedule(){
    if(ticking) return; ticking = true;
    requestAnimationFrame(function(){ ticking=false; place(); });
  }
  function init(){
    ensureHandle(); place();
    addEventListener('scroll', schedule, { passive:true });
    addEventListener('resize', schedule, { passive:true });
    // manche UI toggles verändern Position per Klasse/Zoom – poll sparsam
    setInterval(place, 400);
  }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); }
  else { init(); }
})();
</script>
<!-- === BEGIN MOBILE TAP STICKER: Tap-Auswahl für Sticker auf Touch-Geräten === -->
<script id="rb-mobile-tap-sticker">
(function(){
  'use strict';

  if (window.__rbMobileTapStickerInstalled) return;
  window.__rbMobileTapStickerInstalled = true;

  function isTouchDevice(){
    try{
      return (
        ('ontouchstart' in window) ||
        (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
        (navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 0)
      );
    }catch(_){
      return false;
    }
  }

  if (!isTouchDevice()) return;
  if (typeof window.empfangeSticker !== 'function') return;

  document.addEventListener('DOMContentLoaded', function(){
    var scope = document.getElementById('rb-scope');
    if (!scope) return;

    var selectedImg = null;

    function clearSelection(){
      if (!selectedImg) return;
      try{
        var oldBox = selectedImg.closest('.rb-box');
        if (oldBox && oldBox.classList){
          oldBox.classList.remove('rb-mobile-sticker-selected');
        }
      }catch(_){}
      selectedImg = null;
    }

    // Sticker-Icon in den gelben Boxen auswählen
    scope.addEventListener('click', function(ev){
      try{
        var img = ev.target && ev.target.closest && ev.target.closest('#rb-boxes .rb-row .rb-icon img');
        if (!img) return;

        ev.preventDefault();
        ev.stopPropagation();

        if (selectedImg === img){
          clearSelection();
          return;
        }

        clearSelection();
        selectedImg = img;

        var box = img.closest('.rb-box');
        if (box && box.classList){
          box.classList.add('rb-mobile-sticker-selected');
        }
      }catch(_){}
    }, true);

    // Sticker-Slots auf Karte (Felder 2–5, 7, 8–16)
    var slotIds = [2,3,4,5,7,8,9,10,11,12,13,14,15,16].map(function(n){ return 'feld' + n; });

    slotIds.forEach(function(id){
      var slot = document.getElementById(id);
      if (!slot) return;

      slot.addEventListener('click', function(ev){
        try{
          if (!selectedImg) return;

          ev.preventDefault();
          ev.stopPropagation();

          // Dragstart synthetisch auslösen, damit rb-sticker-usage currentLabelSticker setzen kann
          try{
            var dragEv;
            try{
              dragEv = new DragEvent('dragstart', { bubbles:true, cancelable:true });
            }catch(e){
              dragEv = new Event('dragstart', { bubbles:true, cancelable:true });
            }
            selectedImg.dispatchEvent(dragEv);
          }catch(_){}

          // Sticker-URL ermitteln (PNG/SVG-Switch berücksichtigt)
          var url = '';
          try{
            if (selectedImg.dataset && selectedImg.dataset.srcPng){
              url = selectedImg.dataset.srcPng;
            }else{
              url = selectedImg.getAttribute('src') || '';
            }
          }catch(_){}

          if (!url) return;

          // Fake-Event für empfangeSticker nachbauen
          var fakeEvent = {
            preventDefault: function(){},
            stopPropagation: function(){},
            dataTransfer: {
              getData: function(type){
                if (type === 'text/plain'){
                  try{
                    return JSON.stringify({ type:'sticker', url:url });
                  }catch(_){}
                  return url;
                }
                return '';
              }
            }
          };

          window.empfangeSticker(fakeEvent, id);
        }catch(_){}
      }, true);
    });
  });
})();
</script>
<!-- === END MOBILE TAP STICKER === -->
